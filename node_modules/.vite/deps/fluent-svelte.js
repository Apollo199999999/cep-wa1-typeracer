import {
  createFocusTrap
} from "./chunk-6WAWMVTG.js";
import {
  isTabbable,
  tabbable
} from "./chunk-FNZBOP6L.js";
import {
  writable
} from "./chunk-DY7FSUYH.js";
import {
  fade,
  fly,
  scale
} from "./chunk-YCKTV2FB.js";
import {
  circOut
} from "./chunk-M6MB33T7.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_flush_callback,
  add_location,
  add_render_callback,
  add_resize_listener,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  createEventDispatcher,
  create_bidirectional_transition,
  create_component,
  create_in_transition,
  create_out_transition,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_binding_group_value,
  get_current_component,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  listen,
  listen_dev,
  mount_component,
  noop,
  onMount,
  outro_and_destroy_block,
  prevent_default,
  prop_dev,
  run_all,
  safe_not_equal,
  self,
  setContext,
  set_attributes,
  set_custom_element_data_map,
  set_data_dev,
  set_input_value,
  set_store_value,
  set_style,
  set_svg_attributes,
  space,
  src_url_equal,
  stop_propagation,
  svg_element,
  text,
  tick,
  to_number,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_dynamic_element,
  validate_each_argument,
  validate_each_keys,
  validate_slots,
  validate_store,
  validate_void_dynamic_element
} from "./chunk-K6MJRMI7.js";

// node_modules/fluent-svelte/ComboBox/ComboBoxItem.svelte
var file = "node_modules\\fluent-svelte\\ComboBox\\ComboBoxItem.svelte";
function add_css(target) {
  append_styles(target, "svelte-6pu4ku", '.combo-box-item.svelte-6pu4ku.svelte-6pu4ku{align-items:center;background-color:var(--fds-subtle-fill-transparent);block-size:32px;border-radius:var(--fds-control-corner-radius);box-sizing:border-box;color:var(--fds-text-primary);cursor:default;display:flex;flex:0 0 auto;font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;line-height:20px;margin:4px;outline:none;padding:0 11px;position:relative;text-decoration:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.combo-box-item.svelte-6pu4ku.svelte-6pu4ku:before{background-color:var(--fds-accent-default);block-size:0;border-radius:3px;content:"";inline-size:3px;inset-inline-start:0;opacity:0;position:absolute;transition:transform var(--fds-control-fast-duration) var(--fds-control-fast-out-slow-in-easing)}.combo-box-item.svelte-6pu4ku.svelte-6pu4ku:focus-visible{box-shadow:var(--fds-focus-stroke)}.combo-box-item.selected.svelte-6pu4ku.svelte-6pu4ku,.combo-box-item.svelte-6pu4ku.svelte-6pu4ku:hover{background-color:var(--fds-subtle-fill-secondary)}.combo-box-item.svelte-6pu4ku.svelte-6pu4ku:active{background-color:var(--fds-subtle-fill-tertiary);color:var(--fds-text-secondary)}.combo-box-item.svelte-6pu4ku.svelte-6pu4ku:active:before{transform:scaleY(.625)}.combo-box-item.disabled.svelte-6pu4ku.svelte-6pu4ku{background-color:var(--fds-subtle-fill-transparent);color:var(--fds-text-disabled);pointer-events:none}.combo-box-item.disabled.selected.svelte-6pu4ku.svelte-6pu4ku{background-color:var(--fds-subtle-fill-secondary)}.combo-box-item.disabled.selected.svelte-6pu4ku.svelte-6pu4ku:before{background-color:var(--fds-accent-disabled)}.combo-box-item.selected.svelte-6pu4ku.svelte-6pu4ku:before{block-size:16px;opacity:1}.combo-box-item.svelte-6pu4ku>span.svelte-6pu4ku{flex:1 1 auto;max-inline-size:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.combo-box-item.svelte-6pu4ku>svg{fill:currentColor;-webkit-margin-end:16px;block-size:auto;inline-size:16px;margin-inline-end:16px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29tYm9Cb3hJdGVtLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUF1QlEsMkNBQUEsQ0FBZ0IsWUFBQSxNQUFrQixDQUFDLGlCQUFBLElBQUEsNkJBQUEsQ0FBbUQsQ0FBQyxXQUFBLElBQWUsQ0FBQyxjQUFBLElBQUEsMkJBQUEsQ0FBOEMsQ0FBQyxXQUFBLFVBQXFCLENBQUMsTUFBQSxJQUFBLGtCQUFBLENBQTZCLENBQUMsT0FBQSxPQUFjLENBQUMsUUFBQSxJQUFZLENBQUMsS0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLElBQWEsQ0FBQyxZQUFBLElBQUEsc0JBQUEsQ0FBdUMsQ0FBQyxVQUFBLElBQUEsb0JBQUEsQ0FBbUMsQ0FBQyxZQUFBLEdBQWUsQ0FBQyxZQUFBLElBQWdCLENBQUMsT0FBQSxHQUFVLENBQUMsUUFBQSxJQUFZLENBQUMsUUFBQSxDQUFBLENBQUEsSUFBYyxDQUFDLFNBQUEsUUFBaUIsQ0FBQyxnQkFBQSxJQUFvQixDQUFDLG9CQUFBLElBQXdCLENBQUMsaUJBQUEsSUFBcUIsQ0FBQyxnQkFBQSxJQUFvQixDQUFDLFlBQUEsSUFBZ0IsQ0FBQywyQ0FBQSxPQUFBLENBQXVCLGlCQUFBLElBQUEsb0JBQUEsQ0FBMEMsQ0FBQyxXQUFBLENBQVksQ0FBQyxjQUFBLEdBQWlCLENBQUMsUUFBQSxFQUFVLENBQUMsWUFBQSxHQUFlLENBQUMsbUJBQUEsQ0FBb0IsQ0FBQyxRQUFBLENBQVMsQ0FBQyxTQUFBLFFBQWlCLENBQUMsV0FBQSxTQUFBLENBQUEsSUFBQSwyQkFBQSxDQUFBLENBQUEsSUFBQSxxQ0FBQSxDQUFnRyxDQUFDLDJDQUFBLGNBQUEsQ0FBOEIsV0FBQSxJQUFBLGtCQUFBLENBQWtDLENBQUMsZUFBQSxxQ0FBQSxDQUFBLDJDQUFBLE1BQUEsQ0FBK0MsaUJBQUEsSUFBQSwyQkFBQSxDQUFpRCxDQUFDLDJDQUFBLE9BQUEsQ0FBdUIsaUJBQUEsSUFBQSwwQkFBQSxDQUFnRCxDQUFDLE1BQUEsSUFBQSxvQkFBQSxDQUErQixDQUFDLDJDQUFBLE9BQUEsT0FBQSxDQUE4QixVQUFBLE9BQUEsSUFBQSxDQUFzQixDQUFDLGVBQUEscUNBQUEsQ0FBeUIsaUJBQUEsSUFBQSw2QkFBQSxDQUFtRCxDQUFDLE1BQUEsSUFBQSxtQkFBQSxDQUE4QixDQUFDLGVBQUEsSUFBbUIsQ0FBQyxlQUFBLFNBQUEscUNBQUEsQ0FBa0MsaUJBQUEsSUFBQSwyQkFBQSxDQUFpRCxDQUFDLGVBQUEsU0FBQSxxQ0FBQSxPQUFBLENBQXlDLGlCQUFBLElBQUEscUJBQUEsQ0FBMkMsQ0FBQyxlQUFBLHFDQUFBLE9BQUEsQ0FBZ0MsV0FBQSxJQUFlLENBQUMsUUFBQSxDQUFTLENBQUMsNkJBQUEsQ0FBQSxrQkFBQSxDQUFxQixLQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsSUFBYSxDQUFDLGdCQUFBLElBQW9CLENBQUMsU0FBQSxNQUFlLENBQUMsY0FBQSxRQUFzQixDQUFDLFlBQUEsTUFBa0IsQ0FBQyw2QkFBQSxDQUFBLEFBQUEsR0FBQSxBQUFBLENBQTZCLEtBQUEsWUFBaUIsQ0FBQyxtQkFBQSxJQUF1QixDQUFDLFdBQUEsSUFBZSxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxrQkFBQSxJQUFzQixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkNvbWJvQm94SXRlbS5zdmVsdGUiXX0= */');
}
var get_icon_slot_changes = (dirty) => ({});
var get_icon_slot_context = (ctx) => ({});
function create_fragment(ctx) {
  let li;
  let t;
  let span;
  let li_class_value;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const icon_slot_template = (
    /*#slots*/
    ctx[6].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_icon_slot_context
  );
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let li_levels = [
    { tabindex: "0" },
    {
      class: li_class_value = "combo-box-item " + /*className*/
      ctx[2]
    },
    /*$$restProps*/
    ctx[4]
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if (icon_slot)
        icon_slot.c();
      t = space();
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { tabindex: true, class: true });
      var li_nodes = children(li);
      if (icon_slot)
        icon_slot.l(li_nodes);
      t = claim_space(li_nodes);
      span = claim_element(li_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "svelte-6pu4ku");
      add_location(span, file, 18, 1, 462);
      set_attributes(li, li_data);
      toggle_class(
        li,
        "selected",
        /*selected*/
        ctx[0]
      );
      toggle_class(
        li,
        "disabled",
        /*disabled*/
        ctx[1]
      );
      toggle_class(li, "svelte-6pu4ku", true);
      add_location(li, file, 9, 0, 314);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (icon_slot) {
        icon_slot.m(li, null);
      }
      append_hydration_dev(li, t);
      append_hydration_dev(li, span);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(forwardEvents_action = /*forwardEvents*/
        ctx[3].call(null, li));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_icon_slot_changes
            ),
            get_icon_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        { tabindex: "0" },
        (!current || dirty & /*className*/
        4 && li_class_value !== (li_class_value = "combo-box-item " + /*className*/
        ctx2[2])) && { class: li_class_value },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4]
      ]));
      toggle_class(
        li,
        "selected",
        /*selected*/
        ctx2[0]
      );
      toggle_class(
        li,
        "disabled",
        /*disabled*/
        ctx2[1]
      );
      toggle_class(li, "svelte-6pu4ku", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (icon_slot)
        icon_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["selected", "disabled", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ComboBoxItem", slots, ["icon", "default"]);
  let { selected = false } = $$props;
  let { disabled = false } = $$props;
  let { class: className = "" } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selected" in $$new_props)
      $$invalidate(0, selected = $$new_props.selected);
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventForwarder,
    get_current_component,
    selected,
    disabled,
    className,
    forwardEvents
  });
  $$self.$inject_state = ($$new_props) => {
    if ("selected" in $$props)
      $$invalidate(0, selected = $$new_props.selected);
    if ("disabled" in $$props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [selected, disabled, className, forwardEvents, $$restProps, $$scope, slots];
}
var ComboBoxItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { selected: 0, disabled: 1, class: 2 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ComboBoxItem",
      options,
      id: create_fragment.name
    });
  }
  get selected() {
    throw new Error("<ComboBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<ComboBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ComboBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ComboBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ComboBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ComboBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ComboBoxItem_default = ComboBoxItem;

// node_modules/fluent-svelte/Flyout/FlyoutSurface.svelte
var file2 = "node_modules\\fluent-svelte\\Flyout\\FlyoutSurface.svelte";
function add_css2(target) {
  append_styles(target, "svelte-xjicva", ".flyout.svelte-xjicva{background-clip:padding-box;background-color:var(--fds-solid-background-quarternary);border:1px solid var(--fds-surface-stroke-flyout);border-radius:var(--fds-overlay-corner-radius);box-shadow:var(--fds-flyout-shadow);box-sizing:border-box;color:var(--fds-text-primary);font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;line-height:20px;min-inline-size:320px;padding:16px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRmx5b3V0U3VyZmFjZS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBY1EscUJBQUEsQ0FBUSxnQkFBQSxXQUEyQixDQUFDLGlCQUFBLElBQUEsa0NBQUEsQ0FBd0QsQ0FBQyxPQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSwyQkFBQSxDQUFpRCxDQUFDLGNBQUEsSUFBQSwyQkFBQSxDQUE4QyxDQUFDLFdBQUEsSUFBQSxtQkFBQSxDQUFtQyxDQUFDLFdBQUEsVUFBcUIsQ0FBQyxNQUFBLElBQUEsa0JBQUEsQ0FBNkIsQ0FBQyxZQUFBLElBQUEsc0JBQUEsQ0FBdUMsQ0FBQyxVQUFBLElBQUEsb0JBQUEsQ0FBbUMsQ0FBQyxZQUFBLEdBQWUsQ0FBQyxZQUFBLElBQWdCLENBQUMsZ0JBQUEsS0FBcUIsQ0FBQyxRQUFBLElBQVksQ0FBQyxvQkFBQSxJQUF3QixDQUFDLGlCQUFBLElBQXFCLENBQUMsZ0JBQUEsSUFBb0IsQ0FBQyxZQUFBLElBQWdCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiRmx5b3V0U3VyZmFjZS5zdmVsdGUiXX0= */");
}
function create_fragment2(ctx) {
  let div;
  let div_class_value;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    {
      class: div_class_value = "flyout " + /*className*/
      ctx[1]
    },
    /*$$restProps*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "svelte-xjicva", true);
      add_location(div, file2, 10, 0, 399);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[6](div);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(forwardEvents_action = /*forwardEvents*/
        ctx[2].call(null, div));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*className*/
        2 && div_class_value !== (div_class_value = "flyout " + /*className*/
        ctx2[1])) && { class: div_class_value },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
      toggle_class(div, "svelte-xjicva", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[6](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "element"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FlyoutSurface", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { element: element2 = null } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    get_current_component,
    createEventForwarder,
    className,
    element: element2,
    forwardEvents
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [element2, className, forwardEvents, $$restProps, $$scope, slots, div_binding];
}
var FlyoutSurface = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { class: 1, element: 0 }, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FlyoutSurface",
      options,
      id: create_fragment2.name
    });
  }
  get class() {
    throw new Error("<FlyoutSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FlyoutSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<FlyoutSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<FlyoutSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FlyoutSurface_default = FlyoutSurface;

// node_modules/fluent-svelte/Tooltip/TooltipSurface.svelte
var file3 = "node_modules\\fluent-svelte\\Tooltip\\TooltipSurface.svelte";
function add_css3(target) {
  append_styles(target, "svelte-544vfk", ".tooltip.svelte-544vfk{align-items:center;background-clip:padding-box;background-color:var(--fds-solid-background-quarternary);border:1px solid var(--fds-surface-stroke-flyout);border-radius:var(--fds-control-corner-radius);box-shadow:var(--fds-tooltip-shadow);box-sizing:border-box;display:inline-flex;font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;inline-size:-webkit-max-content;inline-size:-moz-max-content;inline-size:max-content;justify-content:center;line-height:20px;max-inline-size:320px;padding-block:5px 7px;padding-inline:8px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVG9vbHRpcFN1cmZhY2Uuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQW9CUSxzQkFBQSxDQUFTLFlBQUEsTUFBa0IsQ0FBQyxnQkFBQSxXQUEyQixDQUFDLGlCQUFBLElBQUEsa0NBQUEsQ0FBd0QsQ0FBQyxPQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSwyQkFBQSxDQUFpRCxDQUFDLGNBQUEsSUFBQSwyQkFBQSxDQUE4QyxDQUFDLFdBQUEsSUFBQSxvQkFBQSxDQUFvQyxDQUFDLFdBQUEsVUFBcUIsQ0FBQyxRQUFBLFdBQW1CLENBQUMsWUFBQSxJQUFBLHNCQUFBLENBQXVDLENBQUMsVUFBQSxJQUFBLG9CQUFBLENBQW1DLENBQUMsWUFBQSxHQUFlLENBQUMsWUFBQSxtQkFBK0IsQ0FBQyxZQUFBLGdCQUE0QixDQUFDLFlBQUEsV0FBdUIsQ0FBQyxnQkFBQSxNQUFzQixDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxnQkFBQSxLQUFxQixDQUFDLGNBQUEsR0FBQSxDQUFBLEdBQXFCLENBQUMsZUFBQSxHQUFrQixDQUFDLG9CQUFBLElBQXdCLENBQUMsaUJBQUEsSUFBcUIsQ0FBQyxnQkFBQSxJQUFvQixDQUFDLFlBQUEsSUFBZ0IsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJUb29sdGlwU3VyZmFjZS5zdmVsdGUiXX0= */");
}
function create_fragment3(ctx) {
  let div;
  let div_class_value;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    {
      class: div_class_value = "tooltip " + /*className*/
      ctx[1]
    },
    { role: "tooltip" },
    /*$$restProps*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, role: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "svelte-544vfk", true);
      add_location(div, file3, 10, 0, 399);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[6](div);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(forwardEvents_action = /*forwardEvents*/
        ctx[2].call(null, div));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*className*/
        2 && div_class_value !== (div_class_value = "tooltip " + /*className*/
        ctx2[1])) && { class: div_class_value },
        { role: "tooltip" },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
      toggle_class(div, "svelte-544vfk", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[6](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "element"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TooltipSurface", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { element: element2 = null } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventForwarder,
    get_current_component,
    className,
    element: element2,
    forwardEvents
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [element2, className, forwardEvents, $$restProps, $$scope, slots, div_binding];
}
var TooltipSurface = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { class: 1, element: 0 }, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TooltipSurface",
      options,
      id: create_fragment3.name
    });
  }
  get class() {
    throw new Error("<TooltipSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TooltipSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<TooltipSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<TooltipSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TooltipSurface_default = TooltipSurface;

// node_modules/fluent-svelte/MenuFlyout/MenuFlyoutSurface.svelte
var file4 = "node_modules\\fluent-svelte\\MenuFlyout\\MenuFlyoutSurface.svelte";
function add_css4(target) {
  append_styles(target, "svelte-12qaq89", "@-webkit-keyframes svelte-12qaq89-menu-open{0%{transform:translateY(var(--fds-menu-flyout-transition-offset,-50%))}to{transform:none}}@keyframes svelte-12qaq89-menu-open{0%{transform:translateY(var(--fds-menu-flyout-transition-offset,-50%))}to{transform:none}}@-webkit-keyframes svelte-12qaq89-menu-shadow{0%{box-shadow:none}to{box-shadow:var(--fds-flyout-shadow)}}@keyframes svelte-12qaq89-menu-shadow{0%{box-shadow:none}to{box-shadow:var(--fds-flyout-shadow)}}.menu-flyout.svelte-12qaq89{-webkit-animation:svelte-12qaq89-menu-open var(--fds-control-normal-duration) var(--fds-control-fast-out-slow-in-easing),svelte-12qaq89-menu-shadow var(--fds-control-fast-duration) var(--fds-control-fast-out-slow-in-easing) var(--fds-control-normal-duration) forwards;animation:svelte-12qaq89-menu-open var(--fds-control-normal-duration) var(--fds-control-fast-out-slow-in-easing),svelte-12qaq89-menu-shadow var(--fds-control-fast-duration) var(--fds-control-fast-out-slow-in-easing) var(--fds-control-normal-duration) forwards;background-clip:padding-box;background-color:var(--fds-solid-background-quarternary);border:1px solid var(--fds-surface-stroke-flyout);border-radius:var(--fds-overlay-corner-radius);box-sizing:border-box;color:var(--fds-text-primary);display:flex;flex-direction:column;font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;line-height:20px;margin:0;max-block-size:100vh;max-inline-size:100%;min-inline-size:120px;padding:0;padding-block:2px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.menu-flyout-surface-container.svelte-12qaq89{overflow:hidden}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVudUZseW91dFN1cmZhY2Uuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXNCUSxtQkFBQSx3QkFBQSxDQUE2QixFQUFBLENBQUcsVUFBQSxXQUFBLElBQUEsbUNBQUEsQ0FBQSxJQUFBLENBQUEsQ0FBbUUsQ0FBQyxFQUFBLENBQUcsVUFBQSxJQUFjLENBQUMsQ0FBQyxXQUFBLHdCQUFBLENBQXFCLEVBQUEsQ0FBRyxVQUFBLFdBQUEsSUFBQSxtQ0FBQSxDQUFBLElBQUEsQ0FBQSxDQUFtRSxDQUFDLEVBQUEsQ0FBRyxVQUFBLElBQWMsQ0FBQyxDQUFDLG1CQUFBLDBCQUFBLENBQStCLEVBQUEsQ0FBRyxXQUFBLElBQWUsQ0FBQyxFQUFBLENBQUcsV0FBQSxJQUFBLG1CQUFBLENBQW1DLENBQUMsQ0FBQyxXQUFBLDBCQUFBLENBQXVCLEVBQUEsQ0FBRyxXQUFBLElBQWUsQ0FBQyxFQUFBLENBQUcsV0FBQSxJQUFBLG1CQUFBLENBQW1DLENBQUMsQ0FBQywyQkFBQSxDQUFhLGtCQUFBLHdCQUFBLENBQUEsSUFBQSw2QkFBQSxDQUFBLENBQUEsSUFBQSxxQ0FBQSxDQUFBLENBQUEsMEJBQUEsQ0FBQSxJQUFBLDJCQUFBLENBQUEsQ0FBQSxJQUFBLHFDQUFBLENBQUEsQ0FBQSxJQUFBLDZCQUFBLENBQUEsQ0FBQSxRQUE2TyxDQUFDLFVBQUEsd0JBQUEsQ0FBQSxJQUFBLDZCQUFBLENBQUEsQ0FBQSxJQUFBLHFDQUFBLENBQUEsQ0FBQSwwQkFBQSxDQUFBLElBQUEsMkJBQUEsQ0FBQSxDQUFBLElBQUEscUNBQUEsQ0FBQSxDQUFBLElBQUEsNkJBQUEsQ0FBQSxDQUFBLFFBQXFPLENBQUMsZ0JBQUEsV0FBMkIsQ0FBQyxpQkFBQSxJQUFBLGtDQUFBLENBQXdELENBQUMsT0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsMkJBQUEsQ0FBaUQsQ0FBQyxjQUFBLElBQUEsMkJBQUEsQ0FBOEMsQ0FBQyxXQUFBLFVBQXFCLENBQUMsTUFBQSxJQUFBLGtCQUFBLENBQTZCLENBQUMsUUFBQSxJQUFZLENBQUMsZUFBQSxNQUFxQixDQUFDLFlBQUEsSUFBQSxzQkFBQSxDQUF1QyxDQUFDLFVBQUEsSUFBQSxvQkFBQSxDQUFtQyxDQUFDLFlBQUEsR0FBZSxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxPQUFBLENBQVEsQ0FBQyxlQUFBLEtBQW9CLENBQUMsZ0JBQUEsSUFBb0IsQ0FBQyxnQkFBQSxLQUFxQixDQUFDLFFBQUEsQ0FBUyxDQUFDLGNBQUEsR0FBaUIsQ0FBQyxvQkFBQSxJQUF3QixDQUFDLGlCQUFBLElBQXFCLENBQUMsZ0JBQUEsSUFBb0IsQ0FBQyxZQUFBLElBQWdCLENBQUMsNkNBQUEsQ0FBK0IsU0FBQSxNQUFlLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTWVudUZseW91dFN1cmZhY2Uuc3ZlbHRlIl19 */");
}
function create_fragment4(ctx) {
  let div;
  let ul;
  let ul_class_value;
  let div_style_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let ul_levels = [
    {
      class: ul_class_value = "menu-flyout " + /*className*/
      ctx[1]
    },
    /*$$restProps*/
    ctx[3]
  ];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      ul = claim_element(div_nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      if (default_slot)
        default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(ul, ul_data);
      toggle_class(ul, "svelte-12qaq89", true);
      add_location(ul, file4, 12, 1, 359);
      attr_dev(div, "class", "menu-flyout-surface-container svelte-12qaq89");
      attr_dev(div, "style", div_style_value = /*animationComplete*/
      ctx[2] ? "overflow: visible;" : void 0);
      add_location(div, file4, 8, 0, 250);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      ctx[7](ul);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          ul,
          "animationend",
          /*animationend_handler*/
          ctx[6],
          { once: true },
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [
        (!current || dirty & /*className*/
        2 && ul_class_value !== (ul_class_value = "menu-flyout " + /*className*/
        ctx2[1])) && { class: ul_class_value },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
      toggle_class(ul, "svelte-12qaq89", true);
      if (!current || dirty & /*animationComplete*/
      4 && div_style_value !== (div_style_value = /*animationComplete*/
      ctx2[2] ? "overflow: visible;" : void 0)) {
        attr_dev(div, "style", div_style_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "element"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenuFlyoutSurface", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { element: element2 = null } = $$props;
  let animationComplete = false;
  const animationend_handler = () => $$invalidate(2, animationComplete = true);
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ className, element: element2, animationComplete });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("animationComplete" in $$props)
      $$invalidate(2, animationComplete = $$new_props.animationComplete);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    className,
    animationComplete,
    $$restProps,
    $$scope,
    slots,
    animationend_handler,
    ul_binding
  ];
}
var MenuFlyoutSurface = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { class: 1, element: 0 }, add_css4);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenuFlyoutSurface",
      options,
      id: create_fragment4.name
    });
  }
  get class() {
    throw new Error("<MenuFlyoutSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MenuFlyoutSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<MenuFlyoutSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<MenuFlyoutSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenuFlyoutSurface_default = MenuFlyoutSurface;

// node_modules/fluent-svelte/CalendarView/CalendarViewItem.svelte
var file5 = "node_modules\\fluent-svelte\\CalendarView\\CalendarViewItem.svelte";
function add_css5(target) {
  append_styles(target, "svelte-ra5507", '.calendar-view-item.svelte-ra5507.svelte-ra5507{align-items:center;background-color:var(--fds-subtle-fill-transparent);border:1px solid transparent;border-radius:50%;box-sizing:border-box;color:var(--fds-text-primary);display:inline-flex;font-family:var(--fds-font-family-text);font-size:14px;font-weight:400;justify-content:center;line-height:20px;outline:none;padding:0;position:relative;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.calendar-view-item.svelte-ra5507.svelte-ra5507:focus-visible{box-shadow:var(--fds-focus-stroke)}.calendar-view-item.svelte-ra5507.svelte-ra5507:hover{background-color:var(--fds-subtle-fill-secondary)}.calendar-view-item.svelte-ra5507.svelte-ra5507:active{background-color:var(--fds-subtle-fill-tertiary)}.calendar-view-item.out-of-range.svelte-ra5507.svelte-ra5507,.calendar-view-item.svelte-ra5507.svelte-ra5507:active{color:var(--fds-text-secondary)}.calendar-view-item.out-of-range.svelte-ra5507.svelte-ra5507:active{color:var(--fds-text-tertiary)}.calendar-view-item.disabled.svelte-ra5507.svelte-ra5507{background-color:var(--fds-subtle-fill-disabled);color:var(--fds-text-disabled)}.calendar-view-item.disabled.blackout.svelte-ra5507.svelte-ra5507:after{content:none}.calendar-view-item.blackout.svelte-ra5507.svelte-ra5507{pointer-events:none}.calendar-view-item.blackout.svelte-ra5507.svelte-ra5507:after{-webkit-border-before:1px solid var(--fds-control-strong-stroke-default);block-size:1px;border-block-start:1px solid var(--fds-control-strong-stroke-default);content:"";inline-size:26px;position:absolute;transform:matrix(-.71,-.71,-.71,.71,0,0);transform-origin:center}.calendar-view-item.type-day.svelte-ra5507.svelte-ra5507{block-size:40px;inline-size:40px}.calendar-view-item.type-day.svelte-ra5507 small.svelte-ra5507{inset-block-start:2px}.calendar-view-item.type-month-year.svelte-ra5507.svelte-ra5507{block-size:56px;inline-size:56px}.calendar-view-item.type-month-year.svelte-ra5507 small.svelte-ra5507{inset-block-start:9.58px}.calendar-view-item.selected.svelte-ra5507.svelte-ra5507{border:1px solid var(--fds-accent-default);color:var(--fds-accent-text-primary)}.calendar-view-item.selected.svelte-ra5507.svelte-ra5507:hover{background-color:var(--fds-subtle-fill-secondary);border-color:var(--fds-accent-secondary)}.calendar-view-item.selected.svelte-ra5507.svelte-ra5507:active{background-color:var(--fds-subtle-fill-tertiary);border-color:var(--fds-accent-tertiary)}.calendar-view-item.selected.disabled.svelte-ra5507.svelte-ra5507{background-color:var(--fds-subtle-fill-disabled);border-color:var(--fds-accent-disabled);color:var(--fds-accent-text-disabled)}.calendar-view-item.selected.current.svelte-ra5507.svelte-ra5507{box-shadow:inset 0 0 0 1px var(--fds-text-on-accent-primary)}.calendar-view-item.selected.current.svelte-ra5507.svelte-ra5507:focus-visible{box-shadow:inset 0 0 0 1px var(--fds-text-on-accent-primary),var(--fds-focus-stroke)}.calendar-view-item.selected.blackout.svelte-ra5507.svelte-ra5507:after{border-block-start-color:var(--fds-accent-tertiary)}.calendar-view-item.current.svelte-ra5507.svelte-ra5507{background-color:var(--fds-accent-default);color:var(--fds-text-on-accent-primary)}.calendar-view-item.current.svelte-ra5507.svelte-ra5507:hover{background-color:var(--fds-accent-secondary)}.calendar-view-item.current.svelte-ra5507.svelte-ra5507:active{background-color:var(--fds-accent-tertiary);color:var(--fds-text-on-accent-secondary)}.calendar-view-item.current.disabled.svelte-ra5507.svelte-ra5507{background-color:var(--fds-accent-disabled)}.calendar-view-item.current.blackout.svelte-ra5507.svelte-ra5507:after{border-block-start-color:var(--fds-text-on-accent-primary)}.calendar-view-item.svelte-ra5507 small.svelte-ra5507{color:inherit;font-family:var(--fds-font-family-small);font-size:8px;font-weight:400;inline-size:100%;letter-spacing:.04em;line-height:12px;padding-inline:1px;pointer-events:none;position:absolute;text-align:center}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FsZW5kYXJWaWV3SXRlbS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBNkJRLCtDQUFBLENBQW9CLFlBQUEsTUFBa0IsQ0FBQyxpQkFBQSxJQUFBLDZCQUFBLENBQW1ELENBQUMsT0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLFdBQTRCLENBQUMsY0FBQSxHQUFpQixDQUFDLFdBQUEsVUFBcUIsQ0FBQyxNQUFBLElBQUEsa0JBQUEsQ0FBNkIsQ0FBQyxRQUFBLFdBQW1CLENBQUMsWUFBQSxJQUFBLHNCQUFBLENBQXVDLENBQUMsVUFBQSxJQUFjLENBQUMsWUFBQSxHQUFlLENBQUMsZ0JBQUEsTUFBc0IsQ0FBQyxZQUFBLElBQWdCLENBQUMsUUFBQSxJQUFZLENBQUMsUUFBQSxDQUFTLENBQUMsU0FBQSxRQUFpQixDQUFDLFdBQUEsTUFBaUIsQ0FBQyxvQkFBQSxJQUF3QixDQUFDLGlCQUFBLElBQXFCLENBQUMsZ0JBQUEsSUFBb0IsQ0FBQyxZQUFBLElBQWdCLENBQUMsK0NBQUEsY0FBQSxDQUFrQyxXQUFBLElBQUEsa0JBQUEsQ0FBa0MsQ0FBQywrQ0FBQSxNQUFBLENBQTBCLGlCQUFBLElBQUEsMkJBQUEsQ0FBaUQsQ0FBQywrQ0FBQSxPQUFBLENBQTJCLGlCQUFBLElBQUEsMEJBQUEsQ0FBZ0QsQ0FBQyxtQkFBQSx5Q0FBQSxDQUFBLCtDQUFBLE9BQUEsQ0FBNEQsTUFBQSxJQUFBLG9CQUFBLENBQStCLENBQUMsbUJBQUEseUNBQUEsT0FBQSxDQUF3QyxNQUFBLElBQUEsbUJBQUEsQ0FBOEIsQ0FBQyxtQkFBQSxxQ0FBQSxDQUE2QixpQkFBQSxJQUFBLDBCQUFBLENBQWdELENBQUMsTUFBQSxJQUFBLG1CQUFBLENBQThCLENBQUMsbUJBQUEsU0FBQSxxQ0FBQSxNQUFBLENBQTRDLFFBQUEsSUFBWSxDQUFDLG1CQUFBLHFDQUFBLENBQTZCLGVBQUEsSUFBbUIsQ0FBQyxtQkFBQSxxQ0FBQSxNQUFBLENBQW1DLHNCQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxtQ0FBQSxDQUF3RSxDQUFDLFdBQUEsR0FBYyxDQUFDLG1CQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxtQ0FBQSxDQUFxRSxDQUFDLFFBQUEsRUFBVSxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxTQUFBLFFBQWlCLENBQUMsVUFBQSxPQUFBLElBQUEsQ0FBQSxJQUFBLENBQUEsSUFBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUF3QyxDQUFDLGlCQUFBLE1BQXVCLENBQUMsbUJBQUEscUNBQUEsQ0FBNkIsV0FBQSxJQUFlLENBQUMsWUFBQSxJQUFnQixDQUFDLG1CQUFBLHVCQUFBLENBQUEsbUJBQUEsQ0FBbUMsa0JBQUEsR0FBcUIsQ0FBQyxtQkFBQSw0Q0FBQSxDQUFvQyxXQUFBLElBQWUsQ0FBQyxZQUFBLElBQWdCLENBQUMsbUJBQUEsOEJBQUEsQ0FBQSxtQkFBQSxDQUEwQyxrQkFBQSxNQUF3QixDQUFDLG1CQUFBLHFDQUFBLENBQTZCLE9BQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLG9CQUFBLENBQTBDLENBQUMsTUFBQSxJQUFBLHlCQUFBLENBQW9DLENBQUMsbUJBQUEscUNBQUEsTUFBQSxDQUFtQyxpQkFBQSxJQUFBLDJCQUFBLENBQWlELENBQUMsYUFBQSxJQUFBLHNCQUFBLENBQXdDLENBQUMsbUJBQUEscUNBQUEsT0FBQSxDQUFvQyxpQkFBQSxJQUFBLDBCQUFBLENBQWdELENBQUMsYUFBQSxJQUFBLHFCQUFBLENBQXVDLENBQUMsbUJBQUEsU0FBQSxxQ0FBQSxDQUFzQyxpQkFBQSxJQUFBLDBCQUFBLENBQWdELENBQUMsYUFBQSxJQUFBLHFCQUFBLENBQXVDLENBQUMsTUFBQSxJQUFBLDBCQUFBLENBQXFDLENBQUMsbUJBQUEsU0FBQSxvQ0FBQSxDQUFxQyxXQUFBLEtBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsSUFBQSw0QkFBQSxDQUE0RCxDQUFDLG1CQUFBLFNBQUEsb0NBQUEsY0FBQSxDQUFtRCxXQUFBLEtBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsSUFBQSw0QkFBQSxDQUFBLENBQUEsSUFBQSxrQkFBQSxDQUFvRixDQUFDLG1CQUFBLFNBQUEscUNBQUEsTUFBQSxDQUE0Qyx5QkFBQSxJQUFBLHFCQUFBLENBQW1ELENBQUMsbUJBQUEsb0NBQUEsQ0FBNEIsaUJBQUEsSUFBQSxvQkFBQSxDQUEwQyxDQUFDLE1BQUEsSUFBQSw0QkFBQSxDQUF1QyxDQUFDLG1CQUFBLG9DQUFBLE1BQUEsQ0FBa0MsaUJBQUEsSUFBQSxzQkFBQSxDQUE0QyxDQUFDLG1CQUFBLG9DQUFBLE9BQUEsQ0FBbUMsaUJBQUEsSUFBQSxxQkFBQSxDQUEyQyxDQUFDLE1BQUEsSUFBQSw4QkFBQSxDQUF5QyxDQUFDLG1CQUFBLFFBQUEscUNBQUEsQ0FBcUMsaUJBQUEsSUFBQSxxQkFBQSxDQUEyQyxDQUFDLG1CQUFBLFFBQUEscUNBQUEsTUFBQSxDQUEyQyx5QkFBQSxJQUFBLDRCQUFBLENBQTBELENBQUMsaUNBQUEsQ0FBQSxtQkFBQSxDQUEwQixNQUFBLE9BQWEsQ0FBQyxZQUFBLElBQUEsdUJBQUEsQ0FBd0MsQ0FBQyxVQUFBLEdBQWEsQ0FBQyxZQUFBLEdBQWUsQ0FBQyxZQUFBLElBQWdCLENBQUMsZUFBQSxLQUFvQixDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxlQUFBLEdBQWtCLENBQUMsZUFBQSxJQUFtQixDQUFDLFNBQUEsUUFBaUIsQ0FBQyxXQUFBLE1BQWlCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQ2FsZW5kYXJWaWV3SXRlbS5zdmVsdGUiXX0= */');
}
function create_if_block(ctx) {
  let small;
  let t;
  const block = {
    c: function create() {
      small = element("small");
      t = text(
        /*header*/
        ctx[6]
      );
      this.h();
    },
    l: function claim(nodes) {
      small = claim_element(nodes, "SMALL", { class: true });
      var small_nodes = children(small);
      t = claim_text(
        small_nodes,
        /*header*/
        ctx[6]
      );
      small_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(small, "class", "svelte-ra5507");
      add_location(small, file5, 24, 2, 537);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, small, anchor);
      append_hydration_dev(small, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*header*/
      64)
        set_data_dev(
          t,
          /*header*/
          ctx2[6]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(small);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(24:1) {#if header}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let button;
  let t;
  let button_class_value;
  let button_disabled_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*header*/
    ctx[6] && create_if_block(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let button_levels = [
    { type: "button" },
    {
      class: button_class_value = "calendar-view-item type-" + /*variant*/
      (ctx[5] === "day" ? "day" : "month-year")
    },
    {
      disabled: button_disabled_value = /*disabled*/
      ctx[1] || /*blackout*/
      ctx[2]
    },
    { "aria-selected": (
      /*selected*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[7]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        class: true,
        "aria-selected": true
      });
      var button_nodes = children(button);
      if (if_block)
        if_block.l(button_nodes);
      t = claim_space(button_nodes);
      if (default_slot)
        default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      toggle_class(
        button,
        "selected",
        /*selected*/
        ctx[0]
      );
      toggle_class(
        button,
        "current",
        /*current*/
        ctx[3]
      );
      toggle_class(
        button,
        "blackout",
        /*blackout*/
        ctx[2]
      );
      toggle_class(
        button,
        "disabled",
        /*disabled*/
        ctx[1]
      );
      toggle_class(
        button,
        "out-of-range",
        /*outOfRange*/
        ctx[4]
      );
      toggle_class(button, "svelte-ra5507", true);
      add_location(button, file5, 9, 0, 225);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (if_block)
        if_block.m(button, null);
      append_hydration_dev(button, t);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[10],
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keydown",
            /*keydown_handler*/
            ctx[11],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*header*/
        ctx2[6]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(button, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        (!current || dirty & /*variant*/
        32 && button_class_value !== (button_class_value = "calendar-view-item type-" + /*variant*/
        (ctx2[5] === "day" ? "day" : "month-year"))) && { class: button_class_value },
        (!current || dirty & /*disabled, blackout*/
        6 && button_disabled_value !== (button_disabled_value = /*disabled*/
        ctx2[1] || /*blackout*/
        ctx2[2])) && { disabled: button_disabled_value },
        (!current || dirty & /*selected*/
        1) && { "aria-selected": (
          /*selected*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
      toggle_class(
        button,
        "selected",
        /*selected*/
        ctx2[0]
      );
      toggle_class(
        button,
        "current",
        /*current*/
        ctx2[3]
      );
      toggle_class(
        button,
        "blackout",
        /*blackout*/
        ctx2[2]
      );
      toggle_class(
        button,
        "disabled",
        /*disabled*/
        ctx2[1]
      );
      toggle_class(
        button,
        "out-of-range",
        /*outOfRange*/
        ctx2[4]
      );
      toggle_class(button, "svelte-ra5507", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  const omit_props_names = ["selected", "disabled", "blackout", "current", "outOfRange", "variant", "header"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CalendarViewItem", slots, ["default"]);
  let { selected = false } = $$props;
  let { disabled = false } = $$props;
  let { blackout = false } = $$props;
  let { current = false } = $$props;
  let { outOfRange = false } = $$props;
  let { variant = "day" } = $$props;
  let { header = "" } = $$props;
  function click_handler3(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selected" in $$new_props)
      $$invalidate(0, selected = $$new_props.selected);
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("blackout" in $$new_props)
      $$invalidate(2, blackout = $$new_props.blackout);
    if ("current" in $$new_props)
      $$invalidate(3, current = $$new_props.current);
    if ("outOfRange" in $$new_props)
      $$invalidate(4, outOfRange = $$new_props.outOfRange);
    if ("variant" in $$new_props)
      $$invalidate(5, variant = $$new_props.variant);
    if ("header" in $$new_props)
      $$invalidate(6, header = $$new_props.header);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    selected,
    disabled,
    blackout,
    current,
    outOfRange,
    variant,
    header
  });
  $$self.$inject_state = ($$new_props) => {
    if ("selected" in $$props)
      $$invalidate(0, selected = $$new_props.selected);
    if ("disabled" in $$props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("blackout" in $$props)
      $$invalidate(2, blackout = $$new_props.blackout);
    if ("current" in $$props)
      $$invalidate(3, current = $$new_props.current);
    if ("outOfRange" in $$props)
      $$invalidate(4, outOfRange = $$new_props.outOfRange);
    if ("variant" in $$props)
      $$invalidate(5, variant = $$new_props.variant);
    if ("header" in $$props)
      $$invalidate(6, header = $$new_props.header);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    selected,
    disabled,
    blackout,
    current,
    outOfRange,
    variant,
    header,
    $$restProps,
    $$scope,
    slots,
    click_handler3,
    keydown_handler
  ];
}
var CalendarViewItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance5,
      create_fragment5,
      safe_not_equal,
      {
        selected: 0,
        disabled: 1,
        blackout: 2,
        current: 3,
        outOfRange: 4,
        variant: 5,
        header: 6
      },
      add_css5
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CalendarViewItem",
      options,
      id: create_fragment5.name
    });
  }
  get selected() {
    throw new Error("<CalendarViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<CalendarViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<CalendarViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<CalendarViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blackout() {
    throw new Error("<CalendarViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blackout(value) {
    throw new Error("<CalendarViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get current() {
    throw new Error("<CalendarViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set current(value) {
    throw new Error("<CalendarViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outOfRange() {
    throw new Error("<CalendarViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outOfRange(value) {
    throw new Error("<CalendarViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<CalendarViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<CalendarViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<CalendarViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<CalendarViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CalendarViewItem_default = CalendarViewItem;

// node_modules/fluent-svelte/internal.js
function externalMouseEvents(node, options = { type: "click", stopPropagation: false }) {
  const { type, stopPropagation } = options;
  const handleEvent = (event2) => {
    if (stopPropagation)
      event2.stopPropagation();
    if (node && !node.contains(event2.target) && !event2.defaultPrevented) {
      node.dispatchEvent(new CustomEvent(`outer${type}`, {
        detail: event2
      }));
    }
  };
  document.addEventListener(type, handleEvent, true);
  return {
    destroy() {
      document.removeEventListener(type, handleEvent, true);
    }
  };
}
function focusTrap(node, options) {
  const trap = createFocusTrap(node, options = { ...options, fallbackFocus: node });
  trap.activate();
  return {
    destroy() {
      trap.deactivate();
    }
  };
}
function uid(prefix) {
  return prefix + String.fromCharCode(Math.floor(Math.random() * 26) + 97) + Math.random().toString(16).slice(2) + Date.now().toString(16).split(".")[0];
}
function arrowNavigation(node, options = { preventTab: false, stopPropagation: false }) {
  const handleKeyDown2 = (event2) => {
    const { key } = event2;
    const { activeElement } = document;
    let tabOrder = tabbable(node);
    const activeIndex = tabOrder.indexOf(document.activeElement);
    if (tabOrder.length < 0)
      return;
    if (key === "ArrowUp" || key === "ArrowDown" || key === "Home" || key === "End" || key === "Tab" && options.preventTab) {
      event2.preventDefault();
      if (options.stopPropagation)
        event2.stopPropagation();
    }
    if (key === "ArrowUp") {
      if (tabOrder[0] === activeElement) {
        tabOrder[tabOrder.length - 1].focus();
      } else if (tabOrder.includes(activeElement)) {
        tabOrder[activeIndex - 1].focus();
      }
    } else if (key === "ArrowDown") {
      if (tabOrder[tabOrder.length - 1] === activeElement) {
        tabOrder[0].focus();
      } else if (tabOrder.includes(activeElement)) {
        tabOrder[activeIndex + 1].focus();
      }
    } else if (key === "Home") {
      tabOrder[0].focus();
    } else if (key === "End") {
      tabOrder[tabOrder.length - 1].focus();
    }
  };
  node.addEventListener("keydown", handleKeyDown2);
  return {
    destroy: () => node.removeEventListener("keydown", handleKeyDown2)
  };
}
function getCSSDuration(property) {
  const duration = window.getComputedStyle(document.documentElement).getPropertyValue(property);
  return parseFloat(duration) * (/\ds$/.test(duration) ? 1e3 : 1) || 0;
}
function createEventForwarder(component, exclude = []) {
  let $on;
  let events = [];
  component.$on = (eventType, callback) => {
    let destructor = () => {
    };
    if (exclude.includes(eventType)) {
      const callbacks = component.$$.callbacks[eventType] || (component.$$.callbacks[eventType] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    if ($on) {
      destructor = $on(eventType, callback);
    } else {
      events.push([eventType, callback]);
    }
    return () => destructor();
  };
  return (node) => {
    const destructors = [];
    const forwardDestructors = {};
    const forward = (e) => bubble(component, e);
    $on = (eventType, callback) => {
      let handler = callback;
      let options = false;
      const off = listen(node, eventType, handler, options);
      const destructor = () => {
        off();
        const idx = destructors.indexOf(destructor);
        if (idx > -1) {
          destructors.splice(idx, 1);
        }
      };
      destructors.push(destructor);
      if (!(eventType in forwardDestructors)) {
        forwardDestructors[eventType] = listen(node, eventType, forward);
      }
      return destructor;
    };
    for (const event2 of events) {
      $on(event2[0], event2[1]);
    }
    return {
      destroy: () => {
        for (const destructor of destructors) {
          destructor();
        }
        for (let entry of Object.entries(forwardDestructors)) {
          entry[1]();
        }
      }
    };
  };
}

// node_modules/fluent-svelte/Button/Button.svelte
var file6 = "node_modules\\fluent-svelte\\Button\\Button.svelte";
function add_css6(target) {
  append_styles(target, "svelte-8yg8o5", ".button.svelte-8yg8o5{align-items:center;border:none;border-radius:var(--fds-control-corner-radius);box-sizing:border-box;cursor:default;display:inline-flex;font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;justify-content:center;line-height:20px;outline:none;padding-block:4px 6px;padding-inline:11px;position:relative;text-decoration:none;transition:var(--fds-control-faster-duration) ease background;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.button.svelte-8yg8o5:focus-visible{box-shadow:var(--fds-focus-stroke)}.button.style-standard.svelte-8yg8o5{background-clip:padding-box;background-color:var(--fds-control-fill-default);border:1px solid;border-color:var(--fds-control-border-default);color:var(--fds-text-primary)}.button.style-standard.svelte-8yg8o5:hover{background-color:var(--fds-control-fill-secondary)}.button.style-standard.svelte-8yg8o5:active{background-color:var(--fds-control-fill-tertiary);border-color:var(--fds-control-stroke-default);color:var(--fds-text-secondary)}.button.style-standard.disabled.svelte-8yg8o5{background-color:var(--fds-control-fill-disabled);border-color:var(--fds-control-stroke-default);color:var(--fds-text-disabled)}.button.style-accent.svelte-8yg8o5{background-color:var(--fds-accent-default);border:1px solid var(--fds-control-stroke-on-accent-default);border-bottom-color:var(--fds-control-stroke-on-accent-secondary);color:var(--fds-text-on-accent-primary);transition:var(--fds-control-faster-duration) ease border-color}.button.style-accent.svelte-8yg8o5:hover{background-color:var(--fds-accent-secondary)}.button.style-accent.svelte-8yg8o5:active{background-color:var(--fds-accent-tertiary);border-color:transparent;color:var(--fds-text-on-accent-secondary)}.button.style-accent.disabled.svelte-8yg8o5{background-color:var(--fds-accent-disabled);border-color:transparent;color:var(--fds-text-on-accent-disabled)}.button.style-hyperlink.svelte-8yg8o5{background-color:var(--fds-subtle-fill-transparent);color:var(--fds-accent-text-primary);cursor:pointer}.button.style-hyperlink.svelte-8yg8o5:hover{background-color:var(--fds-subtle-fill-secondary)}.button.style-hyperlink.svelte-8yg8o5:active{background-color:var(--fds-subtle-fill-tertiary);color:var(--fds-accent-text-tertiary)}.button.style-hyperlink.disabled.svelte-8yg8o5{color:var(--fds-accent-text-disabled)}.button.disabled.svelte-8yg8o5{pointer-events:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQnV0dG9uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFzQ1EscUJBQUEsQ0FBUSxZQUFBLE1BQWtCLENBQUMsT0FBQSxJQUFXLENBQUMsY0FBQSxJQUFBLDJCQUFBLENBQThDLENBQUMsV0FBQSxVQUFxQixDQUFDLE9BQUEsT0FBYyxDQUFDLFFBQUEsV0FBbUIsQ0FBQyxZQUFBLElBQUEsc0JBQUEsQ0FBdUMsQ0FBQyxVQUFBLElBQUEsb0JBQUEsQ0FBbUMsQ0FBQyxZQUFBLEdBQWUsQ0FBQyxnQkFBQSxNQUFzQixDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxRQUFBLElBQVksQ0FBQyxjQUFBLEdBQUEsQ0FBQSxHQUFxQixDQUFDLGVBQUEsSUFBbUIsQ0FBQyxTQUFBLFFBQWlCLENBQUMsZ0JBQUEsSUFBb0IsQ0FBQyxXQUFBLElBQUEsNkJBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBQSxVQUE2RCxDQUFDLG9CQUFBLElBQXdCLENBQUMsaUJBQUEsSUFBcUIsQ0FBQyxnQkFBQSxJQUFvQixDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxxQkFBQSxjQUFBLENBQXNCLFdBQUEsSUFBQSxrQkFBQSxDQUFrQyxDQUFDLE9BQUEsNkJBQUEsQ0FBdUIsZ0JBQUEsV0FBMkIsQ0FBQyxpQkFBQSxJQUFBLDBCQUFBLENBQWdELENBQUMsT0FBQSxHQUFBLENBQUEsS0FBZ0IsQ0FBQyxhQUFBLElBQUEsNEJBQUEsQ0FBOEMsQ0FBQyxNQUFBLElBQUEsa0JBQUEsQ0FBNkIsQ0FBQyxPQUFBLDZCQUFBLE1BQUEsQ0FBNkIsaUJBQUEsSUFBQSw0QkFBQSxDQUFrRCxDQUFDLE9BQUEsNkJBQUEsT0FBQSxDQUE4QixpQkFBQSxJQUFBLDJCQUFBLENBQWlELENBQUMsYUFBQSxJQUFBLDRCQUFBLENBQThDLENBQUMsTUFBQSxJQUFBLG9CQUFBLENBQStCLENBQUMsT0FBQSxlQUFBLHVCQUFBLENBQWdDLGlCQUFBLElBQUEsMkJBQUEsQ0FBaUQsQ0FBQyxhQUFBLElBQUEsNEJBQUEsQ0FBOEMsQ0FBQyxNQUFBLElBQUEsbUJBQUEsQ0FBOEIsQ0FBQyxPQUFBLDJCQUFBLENBQXFCLGlCQUFBLElBQUEsb0JBQUEsQ0FBMEMsQ0FBQyxPQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxzQ0FBQSxDQUE0RCxDQUFDLG9CQUFBLElBQUEsd0NBQUEsQ0FBaUUsQ0FBQyxNQUFBLElBQUEsNEJBQUEsQ0FBdUMsQ0FBQyxXQUFBLElBQUEsNkJBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBQSxZQUErRCxDQUFDLE9BQUEsMkJBQUEsTUFBQSxDQUEyQixpQkFBQSxJQUFBLHNCQUFBLENBQTRDLENBQUMsT0FBQSwyQkFBQSxPQUFBLENBQTRCLGlCQUFBLElBQUEscUJBQUEsQ0FBMkMsQ0FBQyxhQUFBLFdBQXdCLENBQUMsTUFBQSxJQUFBLDhCQUFBLENBQXlDLENBQUMsT0FBQSxhQUFBLHVCQUFBLENBQThCLGlCQUFBLElBQUEscUJBQUEsQ0FBMkMsQ0FBQyxhQUFBLFdBQXdCLENBQUMsTUFBQSxJQUFBLDZCQUFBLENBQXdDLENBQUMsT0FBQSw4QkFBQSxDQUF3QixpQkFBQSxJQUFBLDZCQUFBLENBQW1ELENBQUMsTUFBQSxJQUFBLHlCQUFBLENBQW9DLENBQUMsT0FBQSxPQUFjLENBQUMsT0FBQSw4QkFBQSxNQUFBLENBQThCLGlCQUFBLElBQUEsMkJBQUEsQ0FBaUQsQ0FBQyxPQUFBLDhCQUFBLE9BQUEsQ0FBK0IsaUJBQUEsSUFBQSwwQkFBQSxDQUFnRCxDQUFDLE1BQUEsSUFBQSwwQkFBQSxDQUFxQyxDQUFDLE9BQUEsZ0JBQUEsdUJBQUEsQ0FBaUMsTUFBQSxJQUFBLDBCQUFBLENBQXFDLENBQUMsT0FBQSx1QkFBQSxDQUFpQixlQUFBLElBQW1CLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQnV0dG9uLnN2ZWx0ZSJdfQ== */");
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let svelte_element_role_value;
  let svelte_element_href_value;
  let svelte_element_class_value;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let svelte_element_levels = [
    {
      role: svelte_element_role_value = /*href*/
      ctx[2] && !/*disabled*/
      ctx[3] ? "button" : void 0
    },
    {
      href: svelte_element_href_value = /*href*/
      ctx[2] && !/*disabled*/
      ctx[3] ? (
        /*href*/
        ctx[2]
      ) : void 0
    },
    {
      class: svelte_element_class_value = "button style-" + /*variant*/
      ctx[1] + " " + /*className*/
      ctx[4]
    },
    /*$$restProps*/
    ctx[6]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*href*/
        ctx[2] && !/*disabled*/
        ctx[3] ? "a" : "button"
      );
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*href*/
        ((ctx[2] && !/*disabled*/
        ctx[3] ? "a" : "button") || "null").toUpperCase(),
        { role: true, href: true, class: true }
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (/-/.test(
        /*href*/
        ctx[2] && !/*disabled*/
        ctx[3] ? "a" : "button"
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      toggle_class(
        svelte_element,
        "disabled",
        /*disabled*/
        ctx[3]
      );
      toggle_class(svelte_element, "svelte-8yg8o5", true);
      add_location(svelte_element, file6, 25, 0, 1065);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      ctx[9](svelte_element);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(forwardEvents_action = /*forwardEvents*/
        ctx[5].call(null, svelte_element));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty & /*href, disabled*/
        12 && svelte_element_role_value !== (svelte_element_role_value = /*href*/
        ctx2[2] && !/*disabled*/
        ctx2[3] ? "button" : void 0)) && { role: svelte_element_role_value },
        (!current || dirty & /*href, disabled*/
        12 && svelte_element_href_value !== (svelte_element_href_value = /*href*/
        ctx2[2] && !/*disabled*/
        ctx2[3] ? (
          /*href*/
          ctx2[2]
        ) : void 0)) && { href: svelte_element_href_value },
        (!current || dirty & /*variant, className*/
        18 && svelte_element_class_value !== (svelte_element_class_value = "button style-" + /*variant*/
        ctx2[1] + " " + /*className*/
        ctx2[4])) && { class: svelte_element_class_value },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6]
      ]);
      if (/-/.test(
        /*href*/
        ctx2[2] && !/*disabled*/
        ctx2[3] ? "a" : "button"
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      toggle_class(
        svelte_element,
        "disabled",
        /*disabled*/
        ctx2[3]
      );
      toggle_class(svelte_element, "svelte-8yg8o5", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if (default_slot)
        default_slot.d(detaching);
      ctx[9](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element.name,
    type: "child_dynamic_element",
    source: '(26:0) <svelte:element  this={href && !disabled ? \\"a\\" : \\"button\\"}  use:forwardEvents  bind:this={element}  role={href && !disabled ? \\"button\\" : undefined}  href={href && !disabled ? href : undefined}  class=\\"button style-{variant} {className}\\"  class:disabled  {...$$restProps} >',
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let previous_tag = (
    /*href*/
    ctx[2] && !/*disabled*/
    ctx[3] ? "a" : "button"
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*href*/
    ctx[2] && !/*disabled*/
    ctx[3] ? "a" : "button"
  );
  validate_void_dynamic_element(
    /*href*/
    ctx[2] && !/*disabled*/
    ctx[3] ? "a" : "button"
  );
  let svelte_element = (
    /*href*/
    (ctx[2] && !/*disabled*/
    ctx[3] ? "a" : "button") && create_dynamic_element(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*href*/
        ctx2[2] && !/*disabled*/
        ctx2[3] ? "a" : "button"
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*href*/
          ctx2[2] && !/*disabled*/
          ctx2[3] ? "a" : "button"
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*href*/
            ctx2[2] && !/*disabled*/
            ctx2[3] ? "a" : "button"
          );
          validate_void_dynamic_element(
            /*href*/
            ctx2[2] && !/*disabled*/
            ctx2[3] ? "a" : "button"
          );
          svelte_element = create_dynamic_element(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = /*href*/
      ctx2[2] && !/*disabled*/
      ctx2[3] ? "a" : "button";
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  const omit_props_names = ["variant", "href", "disabled", "class", "element"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Button", slots, ["default"]);
  let { variant = "standard" } = $$props;
  let { href = "" } = $$props;
  let { disabled = false } = $$props;
  let { class: className = "" } = $$props;
  let { element: element2 = null } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("variant" in $$new_props)
      $$invalidate(1, variant = $$new_props.variant);
    if ("href" in $$new_props)
      $$invalidate(2, href = $$new_props.href);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    get_current_component,
    createEventForwarder,
    variant,
    href,
    disabled,
    className,
    element: element2,
    forwardEvents
  });
  $$self.$inject_state = ($$new_props) => {
    if ("variant" in $$props)
      $$invalidate(1, variant = $$new_props.variant);
    if ("href" in $$props)
      $$invalidate(2, href = $$new_props.href);
    if ("disabled" in $$props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    variant,
    href,
    disabled,
    className,
    forwardEvents,
    $$restProps,
    $$scope,
    slots,
    svelte_element_binding
  ];
}
var Button = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance6,
      create_fragment6,
      safe_not_equal,
      {
        variant: 1,
        href: 2,
        disabled: 3,
        class: 4,
        element: 0
      },
      add_css6
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Button",
      options,
      id: create_fragment6.name
    });
  }
  get variant() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Button_default = Button;

// node_modules/fluent-svelte/Checkbox/Checkbox.svelte
var file7 = "node_modules\\fluent-svelte\\Checkbox\\Checkbox.svelte";
function add_css7(target) {
  append_styles(target, "svelte-1xpu1xr", ".checkbox.svelte-1xpu1xr.svelte-1xpu1xr{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-clip:padding-box;background-color:var(--fds-control-alt-fill-secondary);block-size:20px;border:1px solid var(--fds-control-strong-stroke-default);border-radius:var(--fds-control-corner-radius);font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;inline-size:20px;line-height:20px;margin:0;outline:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.checkbox.svelte-1xpu1xr.svelte-1xpu1xr:focus-visible{box-shadow:var(--fds-focus-stroke)}.checkbox.svelte-1xpu1xr.svelte-1xpu1xr:hover{background-color:var(--fds-control-alt-fill-tertiary)}.checkbox.svelte-1xpu1xr.svelte-1xpu1xr:active{background-color:var(--fds-control-alt-fill-quarternary);border-color:var(--fds-control-strong-stroke-disabled)}.checkbox.svelte-1xpu1xr:active+.checkbox-glyph.svelte-1xpu1xr{color:var(--fds-text-on-accent-secondary)}.checkbox.svelte-1xpu1xr.svelte-1xpu1xr:disabled{background-color:var(--fds-control-alt-fill-disabled);border-color:var(--fds-control-strong-stroke-disabled);pointer-events:none}.checkbox.svelte-1xpu1xr.svelte-1xpu1xr:checked,.checkbox.svelte-1xpu1xr.svelte-1xpu1xr:indeterminate{background-color:var(--fds-accent-default);border:none}.checkbox.svelte-1xpu1xr.svelte-1xpu1xr:checked:hover,.checkbox.svelte-1xpu1xr.svelte-1xpu1xr:indeterminate:hover{background-color:var(--fds-accent-secondary)}.checkbox.svelte-1xpu1xr.svelte-1xpu1xr:checked:active,.checkbox.svelte-1xpu1xr.svelte-1xpu1xr:indeterminate:active{background-color:var(--fds-accent-tertiary)}.checkbox.svelte-1xpu1xr.svelte-1xpu1xr:checked:disabled,.checkbox.svelte-1xpu1xr.svelte-1xpu1xr:indeterminate:disabled{background-color:var(--fds-accent-disabled);border-color:var(--fds-control-strong-stroke-disabled)}.checkbox.svelte-1xpu1xr:checked:disabled+.checkbox-glyph.svelte-1xpu1xr,.checkbox.svelte-1xpu1xr:indeterminate:disabled+.checkbox-glyph.svelte-1xpu1xr{color:var(--fds-text-on-accent-disabled)}.checkbox:checked+.checkbox-glyph.svelte-1xpu1xr .path-checkmark.svelte-1xpu1xr,.checkbox:indeterminate+.checkbox-glyph.svelte-1xpu1xr .path-checkmark.svelte-1xpu1xr{stroke-dashoffset:0;transition:var(--fds-control-normal-duration) cubic-bezier(.55,0,0,1) stroke-dashoffset}.checkbox-container.svelte-1xpu1xr.svelte-1xpu1xr{align-items:center;color:var(--fds-text-primary);display:inline-flex;font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;line-height:20px;min-block-size:32px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.checkbox-container.svelte-1xpu1xr>span.svelte-1xpu1xr{-webkit-padding-start:8px;padding-inline-start:8px}.checkbox-container.disabled.svelte-1xpu1xr>span.svelte-1xpu1xr{color:var(--fds-text-disabled)}.checkbox-inner.svelte-1xpu1xr.svelte-1xpu1xr{align-items:center;display:flex;justify-content:center;position:relative}.checkbox-glyph.svelte-1xpu1xr.svelte-1xpu1xr{block-size:12px;color:inherit;color:var(--fds-text-on-accent-primary);inline-size:12px;position:absolute}.checkbox-glyph.svelte-1xpu1xr path.svelte-1xpu1xr{transform-origin:center}.checkbox-glyph.svelte-1xpu1xr .path-checkmark.svelte-1xpu1xr{stroke:currentColor;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:20.5;stroke-dashoffset:20.5;transform:scale(1.2)}.checkbox-glyph.svelte-1xpu1xr .path-indeterminate.svelte-1xpu1xr{fill:currentColor;transform:scale(.6666666667) translateX(80px) translateY(240px)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hlY2tib3guc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXFFUSx1Q0FBQSxDQUFVLG1CQUFBLElBQXVCLENBQUMsZ0JBQUEsSUFBb0IsQ0FBQyxXQUFBLElBQWUsQ0FBQyxnQkFBQSxXQUEyQixDQUFDLGlCQUFBLElBQUEsZ0NBQUEsQ0FBc0QsQ0FBQyxXQUFBLElBQWUsQ0FBQyxPQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxtQ0FBQSxDQUF5RCxDQUFDLGNBQUEsSUFBQSwyQkFBQSxDQUE4QyxDQUFDLFlBQUEsSUFBQSxzQkFBQSxDQUF1QyxDQUFDLFVBQUEsSUFBQSxvQkFBQSxDQUFtQyxDQUFDLFlBQUEsR0FBZSxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxZQUFBLElBQWdCLENBQUMsT0FBQSxDQUFRLENBQUMsUUFBQSxJQUFZLENBQUMsb0JBQUEsSUFBd0IsQ0FBQyxpQkFBQSxJQUFxQixDQUFDLGdCQUFBLElBQW9CLENBQUMsWUFBQSxJQUFnQixDQUFDLHVDQUFBLGNBQUEsQ0FBd0IsV0FBQSxJQUFBLGtCQUFBLENBQWtDLENBQUMsdUNBQUEsTUFBQSxDQUFnQixpQkFBQSxJQUFBLCtCQUFBLENBQXFELENBQUMsdUNBQUEsT0FBQSxDQUFpQixpQkFBQSxJQUFBLGtDQUFBLENBQXdELENBQUMsYUFBQSxJQUFBLG9DQUFBLENBQXNELENBQUMsd0JBQUEsT0FBQSxDQUFBLDhCQUFBLENBQWlDLE1BQUEsSUFBQSw4QkFBQSxDQUF5QyxDQUFDLHVDQUFBLFNBQUEsQ0FBbUIsaUJBQUEsSUFBQSwrQkFBQSxDQUFxRCxDQUFDLGFBQUEsSUFBQSxvQ0FBQSxDQUFzRCxDQUFDLGVBQUEsSUFBbUIsQ0FBQyx1Q0FBQSxRQUFBLENBQUEsdUNBQUEsY0FBQSxDQUEwQyxpQkFBQSxJQUFBLG9CQUFBLENBQTBDLENBQUMsT0FBQSxJQUFXLENBQUMsdUNBQUEsUUFBQSxNQUFBLENBQUEsdUNBQUEsY0FBQSxNQUFBLENBQXNELGlCQUFBLElBQUEsc0JBQUEsQ0FBNEMsQ0FBQyx1Q0FBQSxRQUFBLE9BQUEsQ0FBQSx1Q0FBQSxjQUFBLE9BQUEsQ0FBd0QsaUJBQUEsSUFBQSxxQkFBQSxDQUEyQyxDQUFDLHVDQUFBLFFBQUEsU0FBQSxDQUFBLHVDQUFBLGNBQUEsU0FBQSxDQUE0RCxpQkFBQSxJQUFBLHFCQUFBLENBQTJDLENBQUMsYUFBQSxJQUFBLG9DQUFBLENBQXNELENBQUMsd0JBQUEsUUFBQSxTQUFBLENBQUEsOEJBQUEsQ0FBQSx3QkFBQSxjQUFBLFNBQUEsQ0FBQSw4QkFBQSxDQUE0RixNQUFBLElBQUEsNkJBQUEsQ0FBd0MsQ0FBQyxTQUFBLFFBQUEsQ0FBQSw4QkFBQSxDQUFBLDhCQUFBLENBQUEsU0FBQSxjQUFBLENBQUEsOEJBQUEsQ0FBQSw4QkFBQSxDQUEwRyxrQkFBQSxDQUFtQixDQUFDLFdBQUEsSUFBQSw2QkFBQSxDQUFBLENBQUEsYUFBQSxHQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxpQkFBdUYsQ0FBQyxpREFBQSxDQUFvQixZQUFBLE1BQWtCLENBQUMsTUFBQSxJQUFBLGtCQUFBLENBQTZCLENBQUMsUUFBQSxXQUFtQixDQUFDLFlBQUEsSUFBQSxzQkFBQSxDQUF1QyxDQUFDLFVBQUEsSUFBQSxvQkFBQSxDQUFtQyxDQUFDLFlBQUEsR0FBZSxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxlQUFBLElBQW1CLENBQUMsb0JBQUEsSUFBd0IsQ0FBQyxpQkFBQSxJQUFxQixDQUFDLGdCQUFBLElBQW9CLENBQUMsWUFBQSxJQUFnQixDQUFDLGtDQUFBLENBQUEsbUJBQUEsQ0FBeUIsc0JBQUEsR0FBeUIsQ0FBQyxxQkFBQSxHQUF3QixDQUFDLG1CQUFBLHdCQUFBLENBQUEsbUJBQUEsQ0FBa0MsTUFBQSxJQUFBLG1CQUFBLENBQThCLENBQUMsNkNBQUEsQ0FBZ0IsWUFBQSxNQUFrQixDQUFDLFFBQUEsSUFBWSxDQUFDLGdCQUFBLE1BQXNCLENBQUMsU0FBQSxRQUFpQixDQUFDLDZDQUFBLENBQWdCLFdBQUEsSUFBZSxDQUFDLE1BQUEsT0FBYSxDQUFDLE1BQUEsSUFBQSw0QkFBQSxDQUF1QyxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxTQUFBLFFBQWlCLENBQUMsOEJBQUEsQ0FBQSxtQkFBQSxDQUFxQixpQkFBQSxNQUF1QixDQUFDLDhCQUFBLENBQUEsOEJBQUEsQ0FBZ0MsT0FBQSxZQUFtQixDQUFDLGFBQUEsQ0FBYyxDQUFDLGVBQUEsS0FBb0IsQ0FBQyxnQkFBQSxLQUFxQixDQUFDLGlCQUFBLElBQXFCLENBQUMsa0JBQUEsSUFBc0IsQ0FBQyxVQUFBLE1BQUEsR0FBQSxDQUFvQixDQUFDLDhCQUFBLENBQUEsa0NBQUEsQ0FBb0MsS0FBQSxZQUFpQixDQUFDLFVBQUEsTUFBQSxXQUFBLENBQUEsQ0FBQSxXQUFBLElBQUEsQ0FBQSxDQUFBLFdBQUEsS0FBQSxDQUErRCxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkNoZWNrYm94LnN2ZWx0ZSJdfQ== */");
}
function create_else_block(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { class: true, d: true, fill: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "class", "path-checkmark svelte-1xpu1xr");
      attr_dev(path, "d", "M 4.5303 12.9697 L 8.5 16.9393 L 18.9697 6.4697");
      attr_dev(path, "fill", "none");
      add_location(path, file7, 54, 4, 2594);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(54:3) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { class: true, d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "class", "path-indeterminate svelte-1xpu1xr");
      attr_dev(path, "d", "M213.5,554.5C207.5,554.5 201.917,553.417 196.75,551.25C191.583,549.083 187.083,546.083 183.25,542.25C179.417,538.417 176.333,533.917 174,528.75C171.667,523.583 170.5,518 170.5,512C170.5,506 171.667,500.417 174,495.25C176.333,490.083 179.417,485.583 183.25,481.75C187.083,477.917 191.583,474.917 196.75,472.75C201.917,470.583 207.5,469.5 213.5,469.5L810.5,469.5C816.5,469.5 822.083,470.583 827.25,472.75C832.417,474.917 836.917,477.917 840.75,481.75C844.583,485.583 847.667,490.083 850,495.25C852.333,500.417 853.5,506 853.5,512C853.5,518 852.333,523.583 850,528.75C847.667,533.917 844.583,538.417 840.75,542.25C836.917,546.083 832.417,549.083 827.25,551.25C822.083,553.417 816.5,554.5 810.5,554.5Z");
      add_location(path, file7, 49, 4, 1827);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(49:3) {#if indeterminate}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let span;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "svelte-1xpu1xr");
      add_location(span, file7, 63, 2, 2760);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(63:1) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let label;
  let div;
  let input;
  let input_class_value;
  let forwardEvents_action;
  let t0;
  let svg;
  let svg_viewBox_value;
  let t1;
  let current;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "checkbox" },
    {
      class: input_class_value = "checkbox " + /*className*/
      ctx[6]
    },
    { __value: (
      /*value*/
      ctx[4]
    ) },
    { disabled: (
      /*disabled*/
      ctx[5]
    ) },
    /*$$restProps*/
    ctx[8]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  function select_block_type(ctx2, dirty) {
    if (
      /*indeterminate*/
      ctx2[1]
    )
      return create_if_block_1;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (
    /*$$slots*/
    ctx[9].default && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      label = element("label");
      div = element("div");
      input = element("input");
      t0 = space();
      svg = svg_element("svg");
      if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { class: true });
      var label_nodes = children(label);
      div = claim_element(label_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      input = claim_element(div_nodes, "INPUT", { type: true, class: true });
      t0 = claim_space(div_nodes);
      svg = claim_svg_element(div_nodes, "svg", {
        "aria-hidden": true,
        class: true,
        viewBox: true
      });
      var svg_nodes = children(svg);
      if_block0.l(svg_nodes);
      svg_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      t1 = claim_space(label_nodes);
      if (if_block1)
        if_block1.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      if (
        /*checked*/
        ctx[0] === void 0 || /*indeterminate*/
        ctx[1] === void 0
      )
        add_render_callback(() => (
          /*input_change_handler*/
          ctx[12].call(input)
        ));
      toggle_class(input, "svelte-1xpu1xr", true);
      add_location(input, file7, 32, 2, 1486);
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "class", "checkbox-glyph svelte-1xpu1xr");
      attr_dev(svg, "viewBox", svg_viewBox_value = /*indeterminate*/
      ctx[1] ? "171 470 683 85" : "0 0 24 24");
      add_location(svg, file7, 43, 2, 1683);
      attr_dev(div, "class", "checkbox-inner svelte-1xpu1xr");
      add_location(div, file7, 31, 1, 1455);
      attr_dev(label, "class", "checkbox-container svelte-1xpu1xr");
      toggle_class(
        label,
        "disabled",
        /*disabled*/
        ctx[5]
      );
      toggle_class(
        label,
        "indeterminate",
        /*indeterminate*/
        ctx[1]
      );
      add_location(label, file7, 30, 0, 1355);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, div);
      append_hydration_dev(div, input);
      if (input.autofocus)
        input.focus();
      input.checked = /*checked*/
      ctx[0];
      input.indeterminate = /*indeterminate*/
      ctx[1];
      ctx[13](input);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, svg);
      if_block0.m(svg, null);
      append_hydration_dev(label, t1);
      if (if_block1)
        if_block1.m(label, null);
      ctx[14](label);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[7].call(null, input)),
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[12]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "checkbox" },
        (!current || dirty & /*className*/
        64 && input_class_value !== (input_class_value = "checkbox " + /*className*/
        ctx2[6])) && { class: input_class_value },
        (!current || dirty & /*value*/
        16) && { __value: (
          /*value*/
          ctx2[4]
        ) },
        (!current || dirty & /*disabled*/
        32) && { disabled: (
          /*disabled*/
          ctx2[5]
        ) },
        dirty & /*$$restProps*/
        256 && /*$$restProps*/
        ctx2[8]
      ]));
      if (dirty & /*checked*/
      1) {
        input.checked = /*checked*/
        ctx2[0];
      }
      if (dirty & /*indeterminate*/
      2) {
        input.indeterminate = /*indeterminate*/
        ctx2[1];
      }
      toggle_class(input, "svelte-1xpu1xr", true);
      if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(svg, null);
        }
      }
      if (!current || dirty & /*indeterminate*/
      2 && svg_viewBox_value !== (svg_viewBox_value = /*indeterminate*/
      ctx2[1] ? "171 470 683 85" : "0 0 24 24")) {
        attr_dev(svg, "viewBox", svg_viewBox_value);
      }
      if (
        /*$$slots*/
        ctx2[9].default
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          512) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(label, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*disabled*/
      32) {
        toggle_class(
          label,
          "disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*indeterminate*/
      2) {
        toggle_class(
          label,
          "indeterminate",
          /*indeterminate*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      ctx[13](null);
      if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[14](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "checked",
    "indeterminate",
    "value",
    "disabled",
    "class",
    "inputElement",
    "containerElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Checkbox", slots, ["default"]);
  const $$slots = compute_slots(slots);
  let { checked = false } = $$props;
  let { indeterminate = false } = $$props;
  let { value = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { class: className = "" } = $$props;
  let { inputElement = null } = $$props;
  let { containerElement = null } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  function input_change_handler() {
    checked = this.checked;
    indeterminate = this.indeterminate;
    $$invalidate(0, checked);
    $$invalidate(1, indeterminate);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(2, inputElement);
    });
  }
  function label_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      containerElement = $$value;
      $$invalidate(3, containerElement);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("indeterminate" in $$new_props)
      $$invalidate(1, indeterminate = $$new_props.indeterminate);
    if ("value" in $$new_props)
      $$invalidate(4, value = $$new_props.value);
    if ("disabled" in $$new_props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("inputElement" in $$new_props)
      $$invalidate(2, inputElement = $$new_props.inputElement);
    if ("containerElement" in $$new_props)
      $$invalidate(3, containerElement = $$new_props.containerElement);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    get_current_component,
    createEventForwarder,
    checked,
    indeterminate,
    value,
    disabled,
    className,
    inputElement,
    containerElement,
    forwardEvents
  });
  $$self.$inject_state = ($$new_props) => {
    if ("checked" in $$props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("indeterminate" in $$props)
      $$invalidate(1, indeterminate = $$new_props.indeterminate);
    if ("value" in $$props)
      $$invalidate(4, value = $$new_props.value);
    if ("disabled" in $$props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("inputElement" in $$props)
      $$invalidate(2, inputElement = $$new_props.inputElement);
    if ("containerElement" in $$props)
      $$invalidate(3, containerElement = $$new_props.containerElement);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    checked,
    indeterminate,
    inputElement,
    containerElement,
    value,
    disabled,
    className,
    forwardEvents,
    $$restProps,
    $$slots,
    $$scope,
    slots,
    input_change_handler,
    input_binding,
    label_binding
  ];
}
var Checkbox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance7,
      create_fragment7,
      safe_not_equal,
      {
        checked: 0,
        indeterminate: 1,
        value: 4,
        disabled: 5,
        class: 6,
        inputElement: 2,
        containerElement: 3
      },
      add_css7
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Checkbox",
      options,
      id: create_fragment7.name
    });
  }
  get checked() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indeterminate() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indeterminate(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerElement() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerElement(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Checkbox_default = Checkbox;

// node_modules/fluent-svelte/ToggleSwitch/ToggleSwitch.svelte
var file8 = "node_modules\\fluent-svelte\\ToggleSwitch\\ToggleSwitch.svelte";
function add_css8(target) {
  append_styles(target, "svelte-1fqnp5l", '.toggle-switch.svelte-1fqnp5l.svelte-1fqnp5l{align-items:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:var(--fds-control-alt-fill-secondary);block-size:20px;border:1px solid var(--fds-control-strong-stroke-default);border-radius:20px;display:inline-flex;font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;inline-size:40px;line-height:20px;margin:0;outline:none;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.toggle-switch.svelte-1fqnp5l.svelte-1fqnp5l:before{background-color:var(--fds-text-secondary);block-size:12px;border-radius:7px;content:"";inline-size:12px;inset-inline-start:3px;position:absolute;transition:var(--fds-control-fast-duration) ease-in-out transform,var(--fds-control-fast-duration) var(--fds-control-fast-out-slow-in-easing) height,var(--fds-control-fast-duration) var(--fds-control-fast-out-slow-in-easing) width,var(--fds-control-fast-duration) var(--fds-control-fast-out-slow-in-easing) margin,var(--fds-control-faster-duration) linear background}.toggle-switch.svelte-1fqnp5l.svelte-1fqnp5l:focus-visible{box-shadow:var(--fds-focus-stroke)}.toggle-switch.svelte-1fqnp5l.svelte-1fqnp5l:hover{background-color:var(--fds-control-alt-fill-tertiary)}.toggle-switch.svelte-1fqnp5l.svelte-1fqnp5l:hover:before{block-size:14px;inline-size:14px}.toggle-switch.svelte-1fqnp5l.svelte-1fqnp5l:active{background-color:var(--fds-control-alt-fill-quarternary)}.toggle-switch.svelte-1fqnp5l.svelte-1fqnp5l:active:before{block-size:14px;inline-size:17px}.toggle-switch.svelte-1fqnp5l.svelte-1fqnp5l:disabled{background-color:var(--fds-control-alt-fill-disabled);border-color:var(--fds-control-strong-stroke-disabled)}.toggle-switch.svelte-1fqnp5l.svelte-1fqnp5l:disabled:before{background-color:var(--fds-text-disabled);block-size:12px;box-shadow:none;inline-size:12px;margin:0!important}.toggle-switch.svelte-1fqnp5l:disabled+span.svelte-1fqnp5l{color:var(--fds-text-disabled)}.toggle-switch.svelte-1fqnp5l.svelte-1fqnp5l:checked{background-color:var(--fds-accent-default);border:none}.toggle-switch.svelte-1fqnp5l.svelte-1fqnp5l:checked:before{background-color:var(--fds-text-on-accent-primary);box-shadow:0 0 0 1px solid var(--fds-control-stroke-default);transform:translateX(20px)}.toggle-switch.svelte-1fqnp5l.svelte-1fqnp5l:checked:hover{background-color:var(--fds-accent-secondary)}.toggle-switch.svelte-1fqnp5l.svelte-1fqnp5l:checked:hover:before{-webkit-margin-start:-1px;margin-inline-start:-1px}.toggle-switch.svelte-1fqnp5l.svelte-1fqnp5l:checked:active{background-color:var(--fds-accent-tertiary)}.toggle-switch.svelte-1fqnp5l.svelte-1fqnp5l:checked:active:before{-webkit-margin-start:-4px;margin-inline-start:-4px}.toggle-switch.svelte-1fqnp5l.svelte-1fqnp5l:checked:disabled{background-color:var(--fds-accent-disabled)}.toggle-switch.svelte-1fqnp5l.svelte-1fqnp5l:checked:disabled:before{background-color:var(--fds-text-on-accent-disabled);box-shadow:none}.toggle-switch-container.svelte-1fqnp5l.svelte-1fqnp5l{align-items:center;color:var(--fds-text-primary);display:inline-flex;font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;line-height:20px;min-block-size:32px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.toggle-switch-container.svelte-1fqnp5l>span.svelte-1fqnp5l{-webkit-padding-start:8px;padding-inline-start:8px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVG9nZ2xlU3dpdGNoLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUE0Q1EsNENBQUEsQ0FBZSxZQUFBLE1BQWtCLENBQUMsbUJBQUEsSUFBdUIsQ0FBQyxnQkFBQSxJQUFvQixDQUFDLFdBQUEsSUFBZSxDQUFDLGlCQUFBLElBQUEsZ0NBQUEsQ0FBc0QsQ0FBQyxXQUFBLElBQWUsQ0FBQyxPQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxtQ0FBQSxDQUF5RCxDQUFDLGNBQUEsSUFBa0IsQ0FBQyxRQUFBLFdBQW1CLENBQUMsWUFBQSxJQUFBLHNCQUFBLENBQXVDLENBQUMsVUFBQSxJQUFBLG9CQUFBLENBQW1DLENBQUMsWUFBQSxHQUFlLENBQUMsWUFBQSxJQUFnQixDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxPQUFBLENBQVEsQ0FBQyxRQUFBLElBQVksQ0FBQyxTQUFBLFFBQWlCLENBQUMsb0JBQUEsSUFBd0IsQ0FBQyxpQkFBQSxJQUFxQixDQUFDLGdCQUFBLElBQW9CLENBQUMsWUFBQSxJQUFnQixDQUFDLDRDQUFBLE9BQUEsQ0FBc0IsaUJBQUEsSUFBQSxvQkFBQSxDQUEwQyxDQUFDLFdBQUEsSUFBZSxDQUFDLGNBQUEsR0FBaUIsQ0FBQyxRQUFBLEVBQVUsQ0FBQyxZQUFBLElBQWdCLENBQUMsbUJBQUEsR0FBc0IsQ0FBQyxTQUFBLFFBQWlCLENBQUMsV0FBQSxJQUFBLDJCQUFBLENBQUEsQ0FBQSxXQUFBLENBQUEsU0FBQSxDQUFBLElBQUEsMkJBQUEsQ0FBQSxDQUFBLElBQUEscUNBQUEsQ0FBQSxDQUFBLE1BQUEsQ0FBQSxJQUFBLDJCQUFBLENBQUEsQ0FBQSxJQUFBLHFDQUFBLENBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSwyQkFBQSxDQUFBLENBQUEsSUFBQSxxQ0FBQSxDQUFBLENBQUEsTUFBQSxDQUFBLElBQUEsNkJBQUEsQ0FBQSxDQUFBLE1BQUEsQ0FBQSxVQUE4VyxDQUFDLDRDQUFBLGNBQUEsQ0FBNkIsV0FBQSxJQUFBLGtCQUFBLENBQWtDLENBQUMsNENBQUEsTUFBQSxDQUFxQixpQkFBQSxJQUFBLCtCQUFBLENBQXFELENBQUMsNENBQUEsTUFBQSxPQUFBLENBQTRCLFdBQUEsSUFBZSxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyw0Q0FBQSxPQUFBLENBQXNCLGlCQUFBLElBQUEsa0NBQUEsQ0FBd0QsQ0FBQyw0Q0FBQSxPQUFBLE9BQUEsQ0FBNkIsV0FBQSxJQUFlLENBQUMsWUFBQSxJQUFnQixDQUFDLDRDQUFBLFNBQUEsQ0FBd0IsaUJBQUEsSUFBQSwrQkFBQSxDQUFxRCxDQUFDLGFBQUEsSUFBQSxvQ0FBQSxDQUFzRCxDQUFDLDRDQUFBLFNBQUEsT0FBQSxDQUErQixpQkFBQSxJQUFBLG1CQUFBLENBQXlDLENBQUMsV0FBQSxJQUFlLENBQUMsV0FBQSxJQUFlLENBQUMsWUFBQSxJQUFnQixDQUFDLE9BQUEsQ0FBQSxVQUFrQixDQUFDLDZCQUFBLFNBQUEsQ0FBQSxtQkFBQSxDQUE2QixNQUFBLElBQUEsbUJBQUEsQ0FBOEIsQ0FBQyw0Q0FBQSxRQUFBLENBQXVCLGlCQUFBLElBQUEsb0JBQUEsQ0FBMEMsQ0FBQyxPQUFBLElBQVcsQ0FBQyw0Q0FBQSxRQUFBLE9BQUEsQ0FBOEIsaUJBQUEsSUFBQSw0QkFBQSxDQUFrRCxDQUFDLFdBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLDRCQUFBLENBQTRELENBQUMsVUFBQSxXQUFBLElBQUEsQ0FBMEIsQ0FBQyw0Q0FBQSxRQUFBLE1BQUEsQ0FBNkIsaUJBQUEsSUFBQSxzQkFBQSxDQUE0QyxDQUFDLDRDQUFBLFFBQUEsTUFBQSxPQUFBLENBQW9DLHFCQUFBLElBQXlCLENBQUMsb0JBQUEsSUFBd0IsQ0FBQyw0Q0FBQSxRQUFBLE9BQUEsQ0FBOEIsaUJBQUEsSUFBQSxxQkFBQSxDQUEyQyxDQUFDLDRDQUFBLFFBQUEsT0FBQSxPQUFBLENBQXFDLHFCQUFBLElBQXlCLENBQUMsb0JBQUEsSUFBd0IsQ0FBQyw0Q0FBQSxRQUFBLFNBQUEsQ0FBZ0MsaUJBQUEsSUFBQSxxQkFBQSxDQUEyQyxDQUFDLDRDQUFBLFFBQUEsU0FBQSxPQUFBLENBQXVDLGlCQUFBLElBQUEsNkJBQUEsQ0FBbUQsQ0FBQyxXQUFBLElBQWUsQ0FBQyxzREFBQSxDQUF5QixZQUFBLE1BQWtCLENBQUMsTUFBQSxJQUFBLGtCQUFBLENBQTZCLENBQUMsUUFBQSxXQUFtQixDQUFDLFlBQUEsSUFBQSxzQkFBQSxDQUF1QyxDQUFDLFVBQUEsSUFBQSxvQkFBQSxDQUFtQyxDQUFDLFlBQUEsR0FBZSxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxlQUFBLElBQW1CLENBQUMsb0JBQUEsSUFBd0IsQ0FBQyxpQkFBQSxJQUFxQixDQUFDLGdCQUFBLElBQW9CLENBQUMsWUFBQSxJQUFnQixDQUFDLHVDQUFBLENBQUEsbUJBQUEsQ0FBOEIsc0JBQUEsR0FBeUIsQ0FBQyxxQkFBQSxHQUF3QixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlRvZ2dsZVN3aXRjaC5zdmVsdGUiXX0= */');
}
function create_if_block3(ctx) {
  let span;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "svelte-1fqnp5l");
      add_location(span, file8, 38, 2, 1528);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(38:1) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let label;
  let input;
  let input_class_value;
  let forwardEvents_action;
  let t;
  let current;
  let mounted;
  let dispose;
  let input_levels = [
    {
      class: input_class_value = "toggle-switch " + /*className*/
      ctx[5]
    },
    { type: "checkbox" },
    { __value: (
      /*value*/
      ctx[3]
    ) },
    { disabled: (
      /*disabled*/
      ctx[4]
    ) },
    /*$$restProps*/
    ctx[7]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block = (
    /*$$slots*/
    ctx[8].default && create_if_block3(ctx)
  );
  const block = {
    c: function create() {
      label = element("label");
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { class: true });
      var label_nodes = children(label);
      input = claim_element(label_nodes, "INPUT", { class: true, type: true });
      t = claim_space(label_nodes);
      if (if_block)
        if_block.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(input, "svelte-1fqnp5l", true);
      add_location(input, file8, 27, 1, 1334);
      attr_dev(label, "class", "toggle-switch-container svelte-1fqnp5l");
      add_location(label, file8, 26, 0, 1264);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, input);
      if (input.autofocus)
        input.focus();
      input.checked = /*checked*/
      ctx[0];
      ctx[12](input);
      append_hydration_dev(label, t);
      if (if_block)
        if_block.m(label, null);
      ctx[13](label);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[6].call(null, input)),
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[11]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        (!current || dirty & /*className*/
        32 && input_class_value !== (input_class_value = "toggle-switch " + /*className*/
        ctx2[5])) && { class: input_class_value },
        { type: "checkbox" },
        (!current || dirty & /*value*/
        8) && { __value: (
          /*value*/
          ctx2[3]
        ) },
        (!current || dirty & /*disabled*/
        16) && { disabled: (
          /*disabled*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
      if (dirty & /*checked*/
      1) {
        input.checked = /*checked*/
        ctx2[0];
      }
      toggle_class(input, "svelte-1fqnp5l", true);
      if (
        /*$$slots*/
        ctx2[8].default
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          256) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(label, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      ctx[12](null);
      if (if_block)
        if_block.d();
      ctx[13](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  const omit_props_names = ["checked", "value", "disabled", "class", "inputElement", "containerElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToggleSwitch", slots, ["default"]);
  const $$slots = compute_slots(slots);
  let { checked = false } = $$props;
  let { value = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { class: className = "" } = $$props;
  let { inputElement = null } = $$props;
  let { containerElement = null } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  function input_change_handler() {
    checked = this.checked;
    $$invalidate(0, checked);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(1, inputElement);
    });
  }
  function label_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      containerElement = $$value;
      $$invalidate(2, containerElement);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("value" in $$new_props)
      $$invalidate(3, value = $$new_props.value);
    if ("disabled" in $$new_props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("inputElement" in $$new_props)
      $$invalidate(1, inputElement = $$new_props.inputElement);
    if ("containerElement" in $$new_props)
      $$invalidate(2, containerElement = $$new_props.containerElement);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    get_current_component,
    createEventForwarder,
    checked,
    value,
    disabled,
    className,
    inputElement,
    containerElement,
    forwardEvents
  });
  $$self.$inject_state = ($$new_props) => {
    if ("checked" in $$props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("value" in $$props)
      $$invalidate(3, value = $$new_props.value);
    if ("disabled" in $$props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("inputElement" in $$props)
      $$invalidate(1, inputElement = $$new_props.inputElement);
    if ("containerElement" in $$props)
      $$invalidate(2, containerElement = $$new_props.containerElement);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    checked,
    inputElement,
    containerElement,
    value,
    disabled,
    className,
    forwardEvents,
    $$restProps,
    $$slots,
    $$scope,
    slots,
    input_change_handler,
    input_binding,
    label_binding
  ];
}
var ToggleSwitch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance8,
      create_fragment8,
      safe_not_equal,
      {
        checked: 0,
        value: 3,
        disabled: 4,
        class: 5,
        inputElement: 1,
        containerElement: 2
      },
      add_css8
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToggleSwitch",
      options,
      id: create_fragment8.name
    });
  }
  get checked() {
    throw new Error("<ToggleSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<ToggleSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<ToggleSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ToggleSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ToggleSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ToggleSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ToggleSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ToggleSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<ToggleSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value) {
    throw new Error("<ToggleSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerElement() {
    throw new Error("<ToggleSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerElement(value) {
    throw new Error("<ToggleSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToggleSwitch_default = ToggleSwitch;

// node_modules/fluent-svelte/RadioButton/RadioButton.svelte
var file9 = "node_modules\\fluent-svelte\\RadioButton\\RadioButton.svelte";
function add_css9(target) {
  append_styles(target, "svelte-5eiibb", '.radio-button.svelte-5eiibb.svelte-5eiibb{align-items:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;background-clip:padding-box;background-color:var(--fds-control-alt-fill-secondary);block-size:20px;border:1px solid var(--fds-control-strong-stroke-default);border-radius:20px;display:inline-flex;font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;inline-size:20px;justify-content:center;line-height:20px;margin:0;outline:none;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.radio-button.svelte-5eiibb.svelte-5eiibb:before{background-color:var(--fds-text-on-accent-primary);block-size:4px;border-radius:12px;content:"";inline-size:4px;position:absolute;visibility:hidden}.radio-button.svelte-5eiibb.svelte-5eiibb:focus-visible{box-shadow:var(--fds-focus-stroke)}.radio-button.svelte-5eiibb.svelte-5eiibb:hover{background-color:var(--fds-control-alt-fill-tertiary)}.radio-button.svelte-5eiibb.svelte-5eiibb:active{background-color:var(--fds-control-alt-fill-quarternary);border-color:var(--fds-control-strong-stroke-disabled)}.radio-button.svelte-5eiibb.svelte-5eiibb:active:before{block-size:10px;inline-size:10px;transition:var(--fds-control-normal-duration) var(--fds-control-fast-out-slow-in-easing);visibility:visible}.radio-button.svelte-5eiibb.svelte-5eiibb:disabled{background-color:var(--fds-control-alt-fill-disabled);border-color:var(--fds-control-strong-stroke-disabled)}.radio-button.svelte-5eiibb.svelte-5eiibb:disabled:before{visibility:hidden}.radio-button.svelte-5eiibb:disabled+span.svelte-5eiibb{color:var(--fds-text-disabled)}.radio-button.svelte-5eiibb.svelte-5eiibb:checked{background-color:var(--fds-accent-default);border:none}.radio-button.svelte-5eiibb.svelte-5eiibb:checked:before{block-size:12px;box-shadow:0 0 0 1px var(--fds-control-stroke-default);inline-size:12px;transition:var(--fds-control-normal-duration) var(--fds-control-fast-out-slow-in-easing);visibility:visible}.radio-button.svelte-5eiibb.svelte-5eiibb:checked:hover{background-color:var(--fds-accent-secondary)}.radio-button.svelte-5eiibb.svelte-5eiibb:checked:hover:before{block-size:14px;inline-size:14px}.radio-button.svelte-5eiibb.svelte-5eiibb:checked:active{background-color:var(--fds-accent-tertiary)}.radio-button.svelte-5eiibb.svelte-5eiibb:checked:active:before{block-size:10px;inline-size:10px}.radio-button.svelte-5eiibb.svelte-5eiibb:checked:disabled{background-color:var(--fds-accent-disabled)}.radio-button.svelte-5eiibb.svelte-5eiibb:checked:disabled:before{block-size:12px;box-shadow:none;inline-size:12px}.radio-button-container.svelte-5eiibb.svelte-5eiibb{align-items:center;color:var(--fds-text-primary);display:inline-flex;font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;line-height:20px;min-block-size:32px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.radio-button-container.svelte-5eiibb>span.svelte-5eiibb{-webkit-padding-start:8px;padding-inline-start:8px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmFkaW9CdXR0b24uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXVEUSx5Q0FBQSxDQUFjLFlBQUEsTUFBa0IsQ0FBQyxtQkFBQSxJQUF1QixDQUFDLGdCQUFBLElBQW9CLENBQUMsV0FBQSxJQUFlLENBQUMsZ0JBQUEsV0FBMkIsQ0FBQyxpQkFBQSxJQUFBLGdDQUFBLENBQXNELENBQUMsV0FBQSxJQUFlLENBQUMsT0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsbUNBQUEsQ0FBeUQsQ0FBQyxjQUFBLElBQWtCLENBQUMsUUFBQSxXQUFtQixDQUFDLFlBQUEsSUFBQSxzQkFBQSxDQUF1QyxDQUFDLFVBQUEsSUFBQSxvQkFBQSxDQUFtQyxDQUFDLFlBQUEsR0FBZSxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxnQkFBQSxNQUFzQixDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxPQUFBLENBQVEsQ0FBQyxRQUFBLElBQVksQ0FBQyxTQUFBLFFBQWlCLENBQUMsb0JBQUEsSUFBd0IsQ0FBQyxpQkFBQSxJQUFxQixDQUFDLGdCQUFBLElBQW9CLENBQUMsWUFBQSxJQUFnQixDQUFDLHlDQUFBLE9BQUEsQ0FBcUIsaUJBQUEsSUFBQSw0QkFBQSxDQUFrRCxDQUFDLFdBQUEsR0FBYyxDQUFDLGNBQUEsSUFBa0IsQ0FBQyxRQUFBLEVBQVUsQ0FBQyxZQUFBLEdBQWUsQ0FBQyxTQUFBLFFBQWlCLENBQUMsV0FBQSxNQUFpQixDQUFDLHlDQUFBLGNBQUEsQ0FBNEIsV0FBQSxJQUFBLGtCQUFBLENBQWtDLENBQUMseUNBQUEsTUFBQSxDQUFvQixpQkFBQSxJQUFBLCtCQUFBLENBQXFELENBQUMseUNBQUEsT0FBQSxDQUFxQixpQkFBQSxJQUFBLGtDQUFBLENBQXdELENBQUMsYUFBQSxJQUFBLG9DQUFBLENBQXNELENBQUMseUNBQUEsT0FBQSxPQUFBLENBQTRCLFdBQUEsSUFBZSxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxXQUFBLElBQUEsNkJBQUEsQ0FBQSxDQUFBLElBQUEscUNBQUEsQ0FBd0YsQ0FBQyxXQUFBLE9BQWtCLENBQUMseUNBQUEsU0FBQSxDQUF1QixpQkFBQSxJQUFBLCtCQUFBLENBQXFELENBQUMsYUFBQSxJQUFBLG9DQUFBLENBQXNELENBQUMseUNBQUEsU0FBQSxPQUFBLENBQThCLFdBQUEsTUFBaUIsQ0FBQywyQkFBQSxTQUFBLENBQUEsa0JBQUEsQ0FBNEIsTUFBQSxJQUFBLG1CQUFBLENBQThCLENBQUMseUNBQUEsUUFBQSxDQUFzQixpQkFBQSxJQUFBLG9CQUFBLENBQTBDLENBQUMsT0FBQSxJQUFXLENBQUMseUNBQUEsUUFBQSxPQUFBLENBQTZCLFdBQUEsSUFBZSxDQUFDLFdBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLElBQUEsNEJBQUEsQ0FBc0QsQ0FBQyxZQUFBLElBQWdCLENBQUMsV0FBQSxJQUFBLDZCQUFBLENBQUEsQ0FBQSxJQUFBLHFDQUFBLENBQXdGLENBQUMsV0FBQSxPQUFrQixDQUFDLHlDQUFBLFFBQUEsTUFBQSxDQUE0QixpQkFBQSxJQUFBLHNCQUFBLENBQTRDLENBQUMseUNBQUEsUUFBQSxNQUFBLE9BQUEsQ0FBbUMsV0FBQSxJQUFlLENBQUMsWUFBQSxJQUFnQixDQUFDLHlDQUFBLFFBQUEsT0FBQSxDQUE2QixpQkFBQSxJQUFBLHFCQUFBLENBQTJDLENBQUMseUNBQUEsUUFBQSxPQUFBLE9BQUEsQ0FBb0MsV0FBQSxJQUFlLENBQUMsWUFBQSxJQUFnQixDQUFDLHlDQUFBLFFBQUEsU0FBQSxDQUErQixpQkFBQSxJQUFBLHFCQUFBLENBQTJDLENBQUMseUNBQUEsUUFBQSxTQUFBLE9BQUEsQ0FBc0MsV0FBQSxJQUFlLENBQUMsV0FBQSxJQUFlLENBQUMsWUFBQSxJQUFnQixDQUFDLG1EQUFBLENBQXdCLFlBQUEsTUFBa0IsQ0FBQyxNQUFBLElBQUEsa0JBQUEsQ0FBNkIsQ0FBQyxRQUFBLFdBQW1CLENBQUMsWUFBQSxJQUFBLHNCQUFBLENBQXVDLENBQUMsVUFBQSxJQUFBLG9CQUFBLENBQW1DLENBQUMsWUFBQSxHQUFlLENBQUMsWUFBQSxJQUFnQixDQUFDLGVBQUEsSUFBbUIsQ0FBQyxvQkFBQSxJQUF3QixDQUFDLGlCQUFBLElBQXFCLENBQUMsZ0JBQUEsSUFBb0IsQ0FBQyxZQUFBLElBQWdCLENBQUMscUNBQUEsQ0FBQSxrQkFBQSxDQUE2QixzQkFBQSxHQUF5QixDQUFDLHFCQUFBLEdBQXdCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiUmFkaW9CdXR0b24uc3ZlbHRlIl19 */');
}
function create_if_block4(ctx) {
  let span;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "svelte-5eiibb");
      add_location(span, file9, 49, 2, 2035);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(49:1) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let label;
  let input;
  let input_class_value;
  let forwardEvents_action;
  let t;
  let current;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "radio" },
    {
      class: input_class_value = "radio-button " + /*className*/
      ctx[6]
    },
    { __value: (
      /*value*/
      ctx[4]
    ) },
    { checked: (
      /*checked*/
      ctx[3]
    ) },
    { disabled: (
      /*disabled*/
      ctx[5]
    ) },
    /*$$restProps*/
    ctx[8]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block = (
    /*$$slots*/
    ctx[9].default && create_if_block4(ctx)
  );
  const block = {
    c: function create() {
      label = element("label");
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { class: true });
      var label_nodes = children(label);
      input = claim_element(label_nodes, "INPUT", { type: true, class: true });
      t = claim_space(label_nodes);
      if (if_block)
        if_block.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      ctx[13][0].push(input);
      toggle_class(input, "svelte-5eiibb", true);
      add_location(input, file9, 37, 1, 1835);
      attr_dev(label, "class", "radio-button-container svelte-5eiibb");
      add_location(label, file9, 36, 0, 1766);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, input);
      if (input.autofocus)
        input.focus();
      input.checked = input.__value === /*group*/
      ctx[0];
      ctx[14](input);
      append_hydration_dev(label, t);
      if (if_block)
        if_block.m(label, null);
      ctx[15](label);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[7].call(null, input)),
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[12]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "radio" },
        (!current || dirty & /*className*/
        64 && input_class_value !== (input_class_value = "radio-button " + /*className*/
        ctx2[6])) && { class: input_class_value },
        (!current || dirty & /*value*/
        16) && { __value: (
          /*value*/
          ctx2[4]
        ) },
        (!current || dirty & /*checked*/
        8) && { checked: (
          /*checked*/
          ctx2[3]
        ) },
        (!current || dirty & /*disabled*/
        32) && { disabled: (
          /*disabled*/
          ctx2[5]
        ) },
        dirty & /*$$restProps*/
        256 && /*$$restProps*/
        ctx2[8]
      ]));
      if (dirty & /*group*/
      1) {
        input.checked = input.__value === /*group*/
        ctx2[0];
      }
      toggle_class(input, "svelte-5eiibb", true);
      if (
        /*$$slots*/
        ctx2[9].default
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          512) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(label, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      ctx[13][0].splice(
        /*$$binding_groups*/
        ctx[13][0].indexOf(input),
        1
      );
      ctx[14](null);
      if (if_block)
        if_block.d();
      ctx[15](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  const omit_props_names = ["group", "checked", "value", "disabled", "class", "inputElement", "containerElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioButton", slots, ["default"]);
  const $$slots = compute_slots(slots);
  let { group = void 0 } = $$props;
  let { checked = false } = $$props;
  let { value = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { class: className = "" } = $$props;
  let { inputElement = null } = $$props;
  let { containerElement = null } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  const $$binding_groups = [[]];
  function input_change_handler() {
    group = this.__value;
    $$invalidate(0, group);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(1, inputElement);
    });
  }
  function label_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      containerElement = $$value;
      $$invalidate(2, containerElement);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("group" in $$new_props)
      $$invalidate(0, group = $$new_props.group);
    if ("checked" in $$new_props)
      $$invalidate(3, checked = $$new_props.checked);
    if ("value" in $$new_props)
      $$invalidate(4, value = $$new_props.value);
    if ("disabled" in $$new_props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("inputElement" in $$new_props)
      $$invalidate(1, inputElement = $$new_props.inputElement);
    if ("containerElement" in $$new_props)
      $$invalidate(2, containerElement = $$new_props.containerElement);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    get_current_component,
    createEventForwarder,
    group,
    checked,
    value,
    disabled,
    className,
    inputElement,
    containerElement,
    forwardEvents
  });
  $$self.$inject_state = ($$new_props) => {
    if ("group" in $$props)
      $$invalidate(0, group = $$new_props.group);
    if ("checked" in $$props)
      $$invalidate(3, checked = $$new_props.checked);
    if ("value" in $$props)
      $$invalidate(4, value = $$new_props.value);
    if ("disabled" in $$props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("inputElement" in $$props)
      $$invalidate(1, inputElement = $$new_props.inputElement);
    if ("containerElement" in $$props)
      $$invalidate(2, containerElement = $$new_props.containerElement);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    group,
    inputElement,
    containerElement,
    checked,
    value,
    disabled,
    className,
    forwardEvents,
    $$restProps,
    $$slots,
    $$scope,
    slots,
    input_change_handler,
    $$binding_groups,
    input_binding,
    label_binding
  ];
}
var RadioButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance9,
      create_fragment9,
      safe_not_equal,
      {
        group: 0,
        checked: 3,
        value: 4,
        disabled: 5,
        class: 6,
        inputElement: 1,
        containerElement: 2
      },
      add_css9
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioButton",
      options,
      id: create_fragment9.name
    });
  }
  get group() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerElement() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerElement(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioButton_default = RadioButton;

// node_modules/fluent-svelte/ProgressRing/ProgressRing.svelte
var file10 = "node_modules\\fluent-svelte\\ProgressRing\\ProgressRing.svelte";
function add_css10(target) {
  append_styles(target, "svelte-19pxlpo", "@-webkit-keyframes svelte-19pxlpo-progress-ring-indeterminate{0%{stroke-dasharray:.01px 43.97px;transform:rotate(0)}50%{stroke-dasharray:21.99px 21.99px;transform:rotate(450deg)}to{stroke-dasharray:.01px 43.97px;transform:rotate(3turn)}}@keyframes svelte-19pxlpo-progress-ring-indeterminate{0%{stroke-dasharray:.01px 43.97px;transform:rotate(0)}50%{stroke-dasharray:21.99px 21.99px;transform:rotate(450deg)}to{stroke-dasharray:.01px 43.97px;transform:rotate(3turn)}}.progress-ring.svelte-19pxlpo.svelte-19pxlpo{min-block-size:16px;min-inline-size:16px;outline:none}.progress-ring.svelte-19pxlpo circle.svelte-19pxlpo{fill:none;stroke:var(--fds-accent-default);stroke-width:1.5;stroke-linecap:round;stroke-dasharray:43.97;transform:rotate(-90deg);transform-origin:50% 50%;transition:all var(--fds-control-normal-duration) linear}.progress-ring.indeterminate.svelte-19pxlpo circle.svelte-19pxlpo{-webkit-animation:svelte-19pxlpo-progress-ring-indeterminate 2s linear infinite;animation:svelte-19pxlpo-progress-ring-indeterminate 2s linear infinite}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJvZ3Jlc3NSaW5nLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUErRFEsbUJBQUEsMENBQUEsQ0FBK0MsRUFBQSxDQUFHLGlCQUFBLEtBQUEsQ0FBQSxPQUE4QixDQUFDLFVBQUEsT0FBQSxDQUFBLENBQW1CLENBQUMsR0FBQSxDQUFJLGlCQUFBLE9BQUEsQ0FBQSxPQUFnQyxDQUFDLFVBQUEsT0FBQSxNQUFBLENBQXdCLENBQUMsRUFBQSxDQUFHLGlCQUFBLEtBQUEsQ0FBQSxPQUE4QixDQUFDLFVBQUEsT0FBQSxLQUFBLENBQXVCLENBQUMsQ0FBQyxXQUFBLDBDQUFBLENBQXVDLEVBQUEsQ0FBRyxpQkFBQSxLQUFBLENBQUEsT0FBOEIsQ0FBQyxVQUFBLE9BQUEsQ0FBQSxDQUFtQixDQUFDLEdBQUEsQ0FBSSxpQkFBQSxPQUFBLENBQUEsT0FBZ0MsQ0FBQyxVQUFBLE9BQUEsTUFBQSxDQUF3QixDQUFDLEVBQUEsQ0FBRyxpQkFBQSxLQUFBLENBQUEsT0FBOEIsQ0FBQyxVQUFBLE9BQUEsS0FBQSxDQUF1QixDQUFDLENBQUMsNENBQUEsQ0FBZSxlQUFBLElBQW1CLENBQUMsZ0JBQUEsSUFBb0IsQ0FBQyxRQUFBLElBQVksQ0FBQyw2QkFBQSxDQUFBLHFCQUFBLENBQXNCLEtBQUEsSUFBUyxDQUFDLE9BQUEsSUFBQSxvQkFBQSxDQUFnQyxDQUFDLGFBQUEsR0FBZ0IsQ0FBQyxlQUFBLEtBQW9CLENBQUMsaUJBQUEsS0FBc0IsQ0FBQyxVQUFBLE9BQUEsTUFBQSxDQUF3QixDQUFDLGlCQUFBLEdBQUEsQ0FBQSxHQUF3QixDQUFDLFdBQUEsR0FBQSxDQUFBLElBQUEsNkJBQUEsQ0FBQSxDQUFBLE1BQXdELENBQUMsY0FBQSw2QkFBQSxDQUFBLHFCQUFBLENBQW9DLGtCQUFBLDBDQUFBLENBQUEsRUFBQSxDQUFBLE1BQUEsQ0FBQSxRQUFnRSxDQUFDLFVBQUEsMENBQUEsQ0FBQSxFQUFBLENBQUEsTUFBQSxDQUFBLFFBQXdELENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiUHJvZ3Jlc3NSaW5nLnN2ZWx0ZSJdfQ== */");
}
function create_fragment10(ctx) {
  let svg;
  let circle;
  let circle_stroke_dashoffset_value;
  let svg_class_value;
  let svg_role_value;
  let svg_aria_valuemin_value;
  let svg_aria_valuemax_value;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let svg_levels = [
    { tabindex: "-1" },
    {
      class: svg_class_value = "progress-ring " + /*className*/
      ctx[4]
    },
    { width: (
      /*size*/
      ctx[3]
    ) },
    { height: (
      /*size*/
      ctx[3]
    ) },
    { viewBox: "0 0 16 16" },
    {
      role: svg_role_value = /*value*/
      ctx[0] ? "progressbar" : "status"
    },
    {
      "aria-valuemin": svg_aria_valuemin_value = !/*indeterminate*/
      ctx[6] ? 0 : void 0
    },
    {
      "aria-valuemax": svg_aria_valuemax_value = !/*indeterminate*/
      ctx[6] ? 100 : void 0
    },
    { "aria-valuenow": (
      /*value*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[8]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        tabindex: true,
        class: true,
        width: true,
        height: true,
        viewBox: true,
        role: true,
        "aria-valuemin": true,
        "aria-valuemax": true,
        "aria-valuenow": true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", {
        cx: true,
        cy: true,
        r: true,
        "stroke-dasharray": true,
        "stroke-dashoffset": true,
        class: true
      });
      children(circle).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "50%");
      attr_dev(circle, "cy", "50%");
      attr_dev(circle, "r", "7");
      attr_dev(circle, "stroke-dasharray", "3");
      attr_dev(circle, "stroke-dashoffset", circle_stroke_dashoffset_value = (100 - /*value*/
      ctx[0]) / 100 * /*circumference*/
      ctx[5]);
      attr_dev(circle, "class", "svelte-19pxlpo");
      add_location(circle, file10, 53, 1, 1939);
      set_svg_attributes(svg, svg_data);
      toggle_class(
        svg,
        "indeterminate",
        /*indeterminate*/
        ctx[6]
      );
      toggle_class(svg, "svelte-19pxlpo", true);
      add_location(svg, file10, 38, 0, 1590);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      ctx[9](circle);
      ctx[10](svg);
      if (!mounted) {
        dispose = action_destroyer(forwardEvents_action = /*forwardEvents*/
        ctx[7].call(null, svg));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*value, circumference*/
      33 && circle_stroke_dashoffset_value !== (circle_stroke_dashoffset_value = (100 - /*value*/
      ctx2[0]) / 100 * /*circumference*/
      ctx2[5])) {
        attr_dev(circle, "stroke-dashoffset", circle_stroke_dashoffset_value);
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { tabindex: "-1" },
        dirty & /*className*/
        16 && svg_class_value !== (svg_class_value = "progress-ring " + /*className*/
        ctx2[4]) && { class: svg_class_value },
        dirty & /*size*/
        8 && { width: (
          /*size*/
          ctx2[3]
        ) },
        dirty & /*size*/
        8 && { height: (
          /*size*/
          ctx2[3]
        ) },
        { viewBox: "0 0 16 16" },
        dirty & /*value*/
        1 && svg_role_value !== (svg_role_value = /*value*/
        ctx2[0] ? "progressbar" : "status") && { role: svg_role_value },
        dirty & /*indeterminate*/
        64 && svg_aria_valuemin_value !== (svg_aria_valuemin_value = !/*indeterminate*/
        ctx2[6] ? 0 : void 0) && { "aria-valuemin": svg_aria_valuemin_value },
        dirty & /*indeterminate*/
        64 && svg_aria_valuemax_value !== (svg_aria_valuemax_value = !/*indeterminate*/
        ctx2[6] ? 100 : void 0) && { "aria-valuemax": svg_aria_valuemax_value },
        dirty & /*value*/
        1 && { "aria-valuenow": (
          /*value*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        256 && /*$$restProps*/
        ctx2[8]
      ]));
      toggle_class(
        svg,
        "indeterminate",
        /*indeterminate*/
        ctx2[6]
      );
      toggle_class(svg, "svelte-19pxlpo", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      ctx[9](null);
      ctx[10](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let indeterminate;
  const omit_props_names = ["value", "size", "class", "element", "circleElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ProgressRing", slots, []);
  let { value = void 0 } = $$props;
  let { size = 32 } = $$props;
  let { class: className = "" } = $$props;
  let { element: element2 = null } = $$props;
  let { circleElement = null } = $$props;
  const forwardEvents = createEventForwarder(get_current_component(), ["change"]);
  const dispatch = createEventDispatcher();
  let circumference;
  function circle_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      circleElement = $$value;
      $$invalidate(1, circleElement);
    });
  }
  function svg_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("size" in $$new_props)
      $$invalidate(3, size = $$new_props.size);
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("element" in $$new_props)
      $$invalidate(2, element2 = $$new_props.element);
    if ("circleElement" in $$new_props)
      $$invalidate(1, circleElement = $$new_props.circleElement);
  };
  $$self.$capture_state = () => ({
    createEventForwarder,
    createEventDispatcher,
    get_current_component,
    value,
    size,
    className,
    element: element2,
    circleElement,
    forwardEvents,
    dispatch,
    circumference,
    indeterminate
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("size" in $$props)
      $$invalidate(3, size = $$new_props.size);
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(2, element2 = $$new_props.element);
    if ("circleElement" in $$props)
      $$invalidate(1, circleElement = $$new_props.circleElement);
    if ("circumference" in $$props)
      $$invalidate(5, circumference = $$new_props.circumference);
    if ("indeterminate" in $$props)
      $$invalidate(6, indeterminate = $$new_props.indeterminate);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    1) {
      $:
        if (value < 0) {
          $$invalidate(0, value = 0);
        } else if (value > 100) {
          $$invalidate(0, value = 100);
        }
    }
    if ($$self.$$.dirty & /*value*/
    1) {
      $:
        $$invalidate(6, indeterminate = typeof value === "undefined" || value === null || Number.isNaN(value));
    }
    if ($$self.$$.dirty & /*value*/
    1) {
      $:
        dispatch("change", value);
    }
    if ($$self.$$.dirty & /*circleElement*/
    2) {
      $:
        if (circleElement)
          $$invalidate(5, circumference = Math.PI * (circleElement.r.baseVal.value * 2));
    }
  };
  return [
    value,
    circleElement,
    element2,
    size,
    className,
    circumference,
    indeterminate,
    forwardEvents,
    $$restProps,
    circle_binding,
    svg_binding
  ];
}
var ProgressRing = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance10,
      create_fragment10,
      safe_not_equal,
      {
        value: 0,
        size: 3,
        class: 4,
        element: 2,
        circleElement: 1
      },
      add_css10
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ProgressRing",
      options,
      id: create_fragment10.name
    });
  }
  get value() {
    throw new Error("<ProgressRing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ProgressRing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<ProgressRing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ProgressRing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ProgressRing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ProgressRing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<ProgressRing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<ProgressRing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get circleElement() {
    throw new Error("<ProgressRing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set circleElement(value) {
    throw new Error("<ProgressRing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ProgressRing_default = ProgressRing;

// node_modules/fluent-svelte/ProgressBar/ProgressBar.svelte
var file11 = "node_modules\\fluent-svelte\\ProgressBar\\ProgressBar.svelte";
function add_css11(target) {
  append_styles(target, "svelte-1p2i94k", "@-webkit-keyframes svelte-1p2i94k-indeterminate-1{0%{opacity:1;transform:translateX(-100%)}75%{opacity:1;transform:translateX(300%)}75.01%{opacity:0}to{opacity:0;transform:translateX(300%)}}@keyframes svelte-1p2i94k-indeterminate-1{0%{opacity:1;transform:translateX(-100%)}75%{opacity:1;transform:translateX(300%)}75.01%{opacity:0}to{opacity:0;transform:translateX(300%)}}@-webkit-keyframes svelte-1p2i94k-indeterminate-2{0%{opacity:0;transform:translateX(-150%)}37.49%{opacity:0}37.5%{opacity:1;transform:translateX(-150%)}to{opacity:1;transform:translateX(166.66%)}}@keyframes svelte-1p2i94k-indeterminate-2{0%{opacity:0;transform:translateX(-150%)}37.49%{opacity:0}37.5%{opacity:1;transform:translateX(-150%)}to{opacity:1;transform:translateX(166.66%)}}.progress-bar.svelte-1p2i94k.svelte-1p2i94k{align-items:center;display:flex;min-block-size:3px;width:100%}.progress-bar-track.svelte-1p2i94k.svelte-1p2i94k{fill:var(--fds-accent-default);height:3px;max-width:50%;transition:var(--fds-control-fast-duration) linear fill}.progress-bar-rail.svelte-1p2i94k.svelte-1p2i94k{fill:var(--fds-control-strong-stroke-default);height:1px;width:100%}.progress-bar.indeterminate.svelte-1p2i94k .progress-bar-rail.svelte-1p2i94k{display:none}.progress-bar.indeterminate.svelte-1p2i94k .progress-bar-track.svelte-1p2i94k{-webkit-animation-timing-function:cubic-bezier(.4,0,.6,1);animation-timing-function:cubic-bezier(.4,0,.6,1)}.progress-bar.indeterminate.svelte-1p2i94k .progress-bar-track.svelte-1p2i94k:first-of-type{-webkit-animation:svelte-1p2i94k-indeterminate-1 2s infinite;animation:svelte-1p2i94k-indeterminate-1 2s infinite;width:40%}.progress-bar.indeterminate.svelte-1p2i94k .progress-bar-track.svelte-1p2i94k:nth-of-type(2){-webkit-animation:svelte-1p2i94k-indeterminate-2 2s infinite;animation:svelte-1p2i94k-indeterminate-2 2s infinite;width:60%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJvZ3Jlc3NCYXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWtEUSxtQkFBQSw4QkFBQSxDQUFtQyxFQUFBLENBQUcsUUFBQSxDQUFTLENBQUMsVUFBQSxXQUFBLEtBQUEsQ0FBMkIsQ0FBQyxHQUFBLENBQUksUUFBQSxDQUFTLENBQUMsVUFBQSxXQUFBLElBQUEsQ0FBMEIsQ0FBQyxNQUFBLENBQU8sUUFBQSxDQUFTLENBQUMsRUFBQSxDQUFHLFFBQUEsQ0FBUyxDQUFDLFVBQUEsV0FBQSxJQUFBLENBQTBCLENBQUMsQ0FBQyxXQUFBLDhCQUFBLENBQTJCLEVBQUEsQ0FBRyxRQUFBLENBQVMsQ0FBQyxVQUFBLFdBQUEsS0FBQSxDQUEyQixDQUFDLEdBQUEsQ0FBSSxRQUFBLENBQVMsQ0FBQyxVQUFBLFdBQUEsSUFBQSxDQUEwQixDQUFDLE1BQUEsQ0FBTyxRQUFBLENBQVMsQ0FBQyxFQUFBLENBQUcsUUFBQSxDQUFTLENBQUMsVUFBQSxXQUFBLElBQUEsQ0FBMEIsQ0FBQyxDQUFDLG1CQUFBLDhCQUFBLENBQW1DLEVBQUEsQ0FBRyxRQUFBLENBQVMsQ0FBQyxVQUFBLFdBQUEsS0FBQSxDQUEyQixDQUFDLE1BQUEsQ0FBTyxRQUFBLENBQVMsQ0FBQyxLQUFBLENBQU0sUUFBQSxDQUFTLENBQUMsVUFBQSxXQUFBLEtBQUEsQ0FBMkIsQ0FBQyxFQUFBLENBQUcsUUFBQSxDQUFTLENBQUMsVUFBQSxXQUFBLE9BQUEsQ0FBNkIsQ0FBQyxDQUFDLFdBQUEsOEJBQUEsQ0FBMkIsRUFBQSxDQUFHLFFBQUEsQ0FBUyxDQUFDLFVBQUEsV0FBQSxLQUFBLENBQTJCLENBQUMsTUFBQSxDQUFPLFFBQUEsQ0FBUyxDQUFDLEtBQUEsQ0FBTSxRQUFBLENBQVMsQ0FBQyxVQUFBLFdBQUEsS0FBQSxDQUEyQixDQUFDLEVBQUEsQ0FBRyxRQUFBLENBQVMsQ0FBQyxVQUFBLFdBQUEsT0FBQSxDQUE2QixDQUFDLENBQUMsMkNBQUEsQ0FBYyxZQUFBLE1BQWtCLENBQUMsUUFBQSxJQUFZLENBQUMsZUFBQSxHQUFrQixDQUFDLE1BQUEsSUFBVSxDQUFDLGlEQUFBLENBQW9CLEtBQUEsSUFBQSxvQkFBQSxDQUE4QixDQUFDLE9BQUEsR0FBVSxDQUFDLFVBQUEsR0FBYSxDQUFDLFdBQUEsSUFBQSwyQkFBQSxDQUFBLENBQUEsTUFBQSxDQUFBLElBQXVELENBQUMsZ0RBQUEsQ0FBbUIsS0FBQSxJQUFBLG1DQUFBLENBQTZDLENBQUMsT0FBQSxHQUFVLENBQUMsTUFBQSxJQUFVLENBQUMsYUFBQSw2QkFBQSxDQUFBLGlDQUFBLENBQStDLFFBQUEsSUFBWSxDQUFDLGFBQUEsNkJBQUEsQ0FBQSxrQ0FBQSxDQUFnRCxrQ0FBQSxhQUFBLEVBQUEsQ0FBQSxDQUFBLENBQUEsRUFBQSxDQUFBLENBQUEsQ0FBeUQsQ0FBQywwQkFBQSxhQUFBLEVBQUEsQ0FBQSxDQUFBLENBQUEsRUFBQSxDQUFBLENBQUEsQ0FBaUQsQ0FBQyxhQUFBLDZCQUFBLENBQUEsa0NBQUEsY0FBQSxDQUE4RCxrQkFBQSw4QkFBQSxDQUFBLEVBQUEsQ0FBQSxRQUE2QyxDQUFDLFVBQUEsOEJBQUEsQ0FBQSxFQUFBLENBQUEsUUFBcUMsQ0FBQyxNQUFBLEdBQVMsQ0FBQyxhQUFBLDZCQUFBLENBQUEsa0NBQUEsYUFBQSxDQUFBLENBQUEsQ0FBK0Qsa0JBQUEsOEJBQUEsQ0FBQSxFQUFBLENBQUEsUUFBNkMsQ0FBQyxVQUFBLDhCQUFBLENBQUEsRUFBQSxDQUFBLFFBQXFDLENBQUMsTUFBQSxHQUFTLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiUHJvZ3Jlc3NCYXIuc3ZlbHRlIl19 */");
}
function create_else_block2(ctx) {
  let rect;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", { height: true, ry: true, class: true });
      children(rect).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "height", "3");
      attr_dev(rect, "ry", "3");
      attr_dev(rect, "class", "progress-bar-track svelte-1p2i94k");
      add_location(rect, file11, 39, 2, 1327);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      ctx[8](rect);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(rect);
      ctx[8](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(39:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let rect;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        height: true,
        rx: true,
        y: true,
        width: true,
        class: true
      });
      children(rect).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "height", "1");
      attr_dev(rect, "rx", "0.5");
      attr_dev(rect, "y", "1");
      attr_dev(rect, "width", "100%");
      attr_dev(rect, "class", "progress-bar-rail svelte-1p2i94k");
      add_location(rect, file11, 30, 2, 1198);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      ctx[7](rect);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(rect);
      ctx[7](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(30:1) {#if value}",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let svg;
  let rect;
  let rect_width_value;
  let svg_class_value;
  let svg_aria_valuemin_value;
  let svg_aria_valuemax_value;
  function select_block_type(ctx2, dirty) {
    if (
      /*value*/
      ctx2[4]
    )
      return create_if_block5;
    return create_else_block2;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  let svg_levels = [
    {
      class: svg_class_value = "progress-bar " + /*className*/
      ctx[5]
    },
    { role: "progressbar" },
    { width: "100%" },
    { height: "3" },
    {
      "aria-valuemin": svg_aria_valuemin_value = /*value*/
      ctx[4] ? 0 : void 0
    },
    {
      "aria-valuemax": svg_aria_valuemax_value = /*value*/
      ctx[4] ? 100 : void 0
    },
    { "aria-valuenow": (
      /*value*/
      ctx[4]
    ) },
    /*$$restProps*/
    ctx[6]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if_block.c();
      rect = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        class: true,
        role: true,
        width: true,
        height: true,
        "aria-valuemin": true,
        "aria-valuemax": true,
        "aria-valuenow": true
      });
      var svg_nodes = children(svg);
      if_block.l(svg_nodes);
      rect = claim_svg_element(svg_nodes, "rect", {
        width: true,
        height: true,
        rx: true,
        class: true
      });
      children(rect).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "width", rect_width_value = /*value*/
      ctx[4] ? `${/*value*/
      ctx[4]}%` : void 0);
      attr_dev(rect, "height", "3");
      attr_dev(rect, "rx", "1.5");
      attr_dev(rect, "class", "progress-bar-track svelte-1p2i94k");
      add_location(rect, file11, 41, 1, 1423);
      set_svg_attributes(svg, svg_data);
      toggle_class(svg, "indeterminate", !/*value*/
      ctx[4]);
      toggle_class(svg, "svelte-1p2i94k", true);
      add_location(svg, file11, 17, 0, 924);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if_block.m(svg, null);
      append_hydration_dev(svg, rect);
      ctx[9](rect);
      ctx[10](svg);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(svg, rect);
        }
      }
      if (dirty & /*value*/
      16 && rect_width_value !== (rect_width_value = /*value*/
      ctx2[4] ? `${/*value*/
      ctx2[4]}%` : void 0)) {
        attr_dev(rect, "width", rect_width_value);
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        dirty & /*className*/
        32 && svg_class_value !== (svg_class_value = "progress-bar " + /*className*/
        ctx2[5]) && { class: svg_class_value },
        { role: "progressbar" },
        { width: "100%" },
        { height: "3" },
        dirty & /*value*/
        16 && svg_aria_valuemin_value !== (svg_aria_valuemin_value = /*value*/
        ctx2[4] ? 0 : void 0) && { "aria-valuemin": svg_aria_valuemin_value },
        dirty & /*value*/
        16 && svg_aria_valuemax_value !== (svg_aria_valuemax_value = /*value*/
        ctx2[4] ? 100 : void 0) && { "aria-valuemax": svg_aria_valuemax_value },
        dirty & /*value*/
        16 && { "aria-valuenow": (
          /*value*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6]
      ]));
      toggle_class(svg, "indeterminate", !/*value*/
      ctx2[4]);
      toggle_class(svg, "svelte-1p2i94k", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if_block.d();
      ctx[9](null);
      ctx[10](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  const omit_props_names = ["value", "class", "element", "railElement", "trackElement", "secondaryTrackElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ProgressBar", slots, []);
  let { value = void 0 } = $$props;
  let { class: className = "" } = $$props;
  let { element: element2 = null } = $$props;
  let { railElement = null } = $$props;
  let { trackElement = null } = $$props;
  let { secondaryTrackElement = null } = $$props;
  function rect_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      railElement = $$value;
      $$invalidate(1, railElement);
    });
  }
  function rect_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      secondaryTrackElement = $$value;
      $$invalidate(3, secondaryTrackElement);
    });
  }
  function rect_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      trackElement = $$value;
      $$invalidate(2, trackElement);
    });
  }
  function svg_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(4, value = $$new_props.value);
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("railElement" in $$new_props)
      $$invalidate(1, railElement = $$new_props.railElement);
    if ("trackElement" in $$new_props)
      $$invalidate(2, trackElement = $$new_props.trackElement);
    if ("secondaryTrackElement" in $$new_props)
      $$invalidate(3, secondaryTrackElement = $$new_props.secondaryTrackElement);
  };
  $$self.$capture_state = () => ({
    value,
    className,
    element: element2,
    railElement,
    trackElement,
    secondaryTrackElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(4, value = $$new_props.value);
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("railElement" in $$props)
      $$invalidate(1, railElement = $$new_props.railElement);
    if ("trackElement" in $$props)
      $$invalidate(2, trackElement = $$new_props.trackElement);
    if ("secondaryTrackElement" in $$props)
      $$invalidate(3, secondaryTrackElement = $$new_props.secondaryTrackElement);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    railElement,
    trackElement,
    secondaryTrackElement,
    value,
    className,
    $$restProps,
    rect_binding,
    rect_binding_1,
    rect_binding_2,
    svg_binding
  ];
}
var ProgressBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance11,
      create_fragment11,
      safe_not_equal,
      {
        value: 4,
        class: 5,
        element: 0,
        railElement: 1,
        trackElement: 2,
        secondaryTrackElement: 3
      },
      add_css11
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ProgressBar",
      options,
      id: create_fragment11.name
    });
  }
  get value() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get railElement() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set railElement(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get trackElement() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set trackElement(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get secondaryTrackElement() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set secondaryTrackElement(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ProgressBar_default = ProgressBar;

// node_modules/fluent-svelte/TextBox/TextBoxButton.svelte
var file12 = "node_modules\\fluent-svelte\\TextBox\\TextBoxButton.svelte";
function add_css12(target) {
  append_styles(target, "svelte-gkqu0l", ".text-box-button.svelte-gkqu0l{align-items:center;background-color:var(--fds-subtle-fill-transparent);border:none;border-radius:var(--fds-control-corner-radius);box-sizing:border-box;color:var(--fds-text-secondary);display:flex;justify-content:center;min-block-size:22px;min-inline-size:26px;outline:none;padding:3px 5px}.text-box-button.svelte-gkqu0l:focus-visible{box-shadow:var(--fds-focus-stroke)}.text-box-button.svelte-gkqu0l:hover{background-color:var(--fds-subtle-fill-secondary)}.text-box-button.svelte-gkqu0l:active{background-color:var(--fds-subtle-fill-tertiary);color:var(--fds-text-tertiary)}.text-box-button.svelte-gkqu0l:disabled{background-color:var(--fds-subtle-fill-tertiary);color:var(--fds-text-disabled)}.text-box-button.svelte-gkqu0l svg{fill:currentColor;min-block-size:12px;min-inline-size:12px;pointer-events:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGV4dEJveEJ1dHRvbi5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBbUJRLDhCQUFBLENBQWlCLFlBQUEsTUFBa0IsQ0FBQyxpQkFBQSxJQUFBLDZCQUFBLENBQW1ELENBQUMsT0FBQSxJQUFXLENBQUMsY0FBQSxJQUFBLDJCQUFBLENBQThDLENBQUMsV0FBQSxVQUFxQixDQUFDLE1BQUEsSUFBQSxvQkFBQSxDQUErQixDQUFDLFFBQUEsSUFBWSxDQUFDLGdCQUFBLE1BQXNCLENBQUMsZUFBQSxJQUFtQixDQUFDLGdCQUFBLElBQW9CLENBQUMsUUFBQSxJQUFZLENBQUMsUUFBQSxHQUFBLENBQUEsR0FBZSxDQUFDLDhCQUFBLGNBQUEsQ0FBK0IsV0FBQSxJQUFBLGtCQUFBLENBQWtDLENBQUMsOEJBQUEsTUFBQSxDQUF1QixpQkFBQSxJQUFBLDJCQUFBLENBQWlELENBQUMsOEJBQUEsT0FBQSxDQUF3QixpQkFBQSxJQUFBLDBCQUFBLENBQWdELENBQUMsTUFBQSxJQUFBLG1CQUFBLENBQThCLENBQUMsOEJBQUEsU0FBQSxDQUEwQixpQkFBQSxJQUFBLDBCQUFBLENBQWdELENBQUMsTUFBQSxJQUFBLG1CQUFBLENBQThCLENBQUMsOEJBQUEsQ0FBQSxBQUFBLEdBQUEsQUFBQSxDQUE4QixLQUFBLFlBQWlCLENBQUMsZUFBQSxJQUFtQixDQUFDLGdCQUFBLElBQW9CLENBQUMsZUFBQSxJQUFtQixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlRleHRCb3hCdXR0b24uc3ZlbHRlIl19 */");
}
function create_fragment12(ctx) {
  let button;
  let button_class_value;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let button_levels = [
    {
      class: button_class_value = "text-box-button " + /*className*/
      ctx[2]
    },
    { type: (
      /*type*/
      ctx[1]
    ) },
    /*$$restProps*/
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true, type: true });
      var button_nodes = children(button);
      if (default_slot)
        default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      toggle_class(button, "svelte-gkqu0l", true);
      add_location(button, file12, 9, 0, 311);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      ctx[7](button);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(forwardEvents_action = /*forwardEvents*/
        ctx[3].call(null, button));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        (!current || dirty & /*className*/
        4 && button_class_value !== (button_class_value = "text-box-button " + /*className*/
        ctx2[2])) && { class: button_class_value },
        (!current || dirty & /*type*/
        2) && { type: (
          /*type*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4]
      ]));
      toggle_class(button, "svelte-gkqu0l", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  const omit_props_names = ["type", "class", "element"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TextBoxButton", slots, ["default"]);
  let { type = "button" } = $$props;
  let { class: className = "" } = $$props;
  let { element: element2 = null } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("type" in $$new_props)
      $$invalidate(1, type = $$new_props.type);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventForwarder,
    get_current_component,
    type,
    className,
    element: element2,
    forwardEvents
  });
  $$self.$inject_state = ($$new_props) => {
    if ("type" in $$props)
      $$invalidate(1, type = $$new_props.type);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    type,
    className,
    forwardEvents,
    $$restProps,
    $$scope,
    slots,
    button_binding
  ];
}
var TextBoxButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { type: 1, class: 2, element: 0 }, add_css12);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TextBoxButton",
      options,
      id: create_fragment12.name
    });
  }
  get type() {
    throw new Error("<TextBoxButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<TextBoxButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TextBoxButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TextBoxButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<TextBoxButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<TextBoxButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TextBoxButton_default = TextBoxButton;

// node_modules/fluent-svelte/TextBox/TextBox.svelte
var file13 = "node_modules\\fluent-svelte\\TextBox\\TextBox.svelte";
function add_css13(target) {
  append_styles(target, "svelte-1yv8oe6", '.text-box.svelte-1yv8oe6.svelte-1yv8oe6{background-color:transparent;border:none;border-radius:var(--fds-control-corner-radius);box-sizing:border-box;color:var(--fds-text-primary);cursor:unset;flex:1 1 auto;font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;inline-size:100%;line-height:20px;margin:0;min-block-size:30px;outline:none;padding-inline:10px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.text-box.svelte-1yv8oe6.svelte-1yv8oe6::-moz-placeholder{color:var(--fds-text-secondary);-moz-user-select:none;user-select:none}.text-box.svelte-1yv8oe6.svelte-1yv8oe6:-ms-input-placeholder{color:var(--fds-text-secondary);-ms-user-select:none;user-select:none}.text-box.svelte-1yv8oe6.svelte-1yv8oe6::placeholder{color:var(--fds-text-secondary);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.text-box.svelte-1yv8oe6.svelte-1yv8oe6::-webkit-search-cancel-button,.text-box.svelte-1yv8oe6.svelte-1yv8oe6::-webkit-search-decoration,.text-box.svelte-1yv8oe6.svelte-1yv8oe6::-webkit-search-results-button,.text-box.svelte-1yv8oe6.svelte-1yv8oe6::-webkit-search-results-decoration{-webkit-appearance:none}.text-box.svelte-1yv8oe6.svelte-1yv8oe6::-ms-reveal{display:none}.text-box.svelte-1yv8oe6.svelte-1yv8oe6:disabled{color:var(--fds-text-disabled)}.text-box.svelte-1yv8oe6.svelte-1yv8oe6:disabled::-moz-placeholder{color:var(--fds-text-disabled)}.text-box.svelte-1yv8oe6.svelte-1yv8oe6:disabled:-ms-input-placeholder{color:var(--fds-text-disabled)}.text-box.svelte-1yv8oe6.svelte-1yv8oe6:disabled::placeholder{color:var(--fds-text-disabled)}.text-box-container.svelte-1yv8oe6.svelte-1yv8oe6{align-items:center;background-clip:padding-box;background-color:var(--fds-control-fill-default);border:1px solid var(--fds-control-stroke-default);border-radius:var(--fds-control-corner-radius);cursor:text;display:flex;inline-size:100%;position:relative}.text-box-container.svelte-1yv8oe6.svelte-1yv8oe6:hover{background-color:var(--fds-control-fill-secondary)}.text-box-container.disabled.svelte-1yv8oe6.svelte-1yv8oe6{background-color:var(--fds-control-fill-disabled);cursor:default}.text-box-container.disabled.svelte-1yv8oe6 .text-box-underline.svelte-1yv8oe6{display:none}.text-box-container.svelte-1yv8oe6.svelte-1yv8oe6:focus-within{background-color:var(--fds-control-fill-input-active)}.text-box-container.svelte-1yv8oe6:focus-within .text-box.svelte-1yv8oe6::-moz-placeholder{color:var(--fds-text-tertiary)}.text-box-container.svelte-1yv8oe6:focus-within .text-box.svelte-1yv8oe6:-ms-input-placeholder{color:var(--fds-text-tertiary)}.text-box-container.svelte-1yv8oe6:focus-within .text-box.svelte-1yv8oe6::placeholder{color:var(--fds-text-tertiary)}.text-box-container.svelte-1yv8oe6:focus-within .text-box-underline.svelte-1yv8oe6:after{border-bottom:2px solid var(--fds-accent-default)}.text-box-container.svelte-1yv8oe6:focus-within .text-box-clear-button{display:flex}.text-box-underline.svelte-1yv8oe6.svelte-1yv8oe6{block-size:calc(100% + 2px);border-radius:var(--fds-control-corner-radius);inline-size:calc(100% + 2px);inset-block-start:-1px;inset-inline-start:-1px;overflow:hidden;pointer-events:none;position:absolute}.text-box-underline.svelte-1yv8oe6.svelte-1yv8oe6:after{block-size:100%;border-bottom:1px solid var(--fds-control-strong-stroke-default);box-sizing:border-box;content:"";inline-size:100%;inset-block-end:0;inset-inline-start:0;position:absolute}.text-box-buttons.svelte-1yv8oe6.svelte-1yv8oe6{align-items:center;cursor:default;display:flex;flex:0 0 auto}.text-box-buttons.svelte-1yv8oe6>.text-box-button{-webkit-margin-start:6px;margin-inline-start:6px}.text-box-buttons.svelte-1yv8oe6>.text-box-button:first-of-type{-webkit-margin-start:0;margin-inline-start:0}.text-box-buttons.svelte-1yv8oe6>.text-box-button:last-of-type{-webkit-margin-end:4px;margin-inline-end:4px}.text-box-buttons.svelte-1yv8oe6 .text-box-clear-button{display:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGV4dEJveC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBMkxRLHVDQUFBLENBQVUsaUJBQUEsV0FBNEIsQ0FBQyxPQUFBLElBQVcsQ0FBQyxjQUFBLElBQUEsMkJBQUEsQ0FBOEMsQ0FBQyxXQUFBLFVBQXFCLENBQUMsTUFBQSxJQUFBLGtCQUFBLENBQTZCLENBQUMsT0FBQSxLQUFZLENBQUMsS0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLElBQWEsQ0FBQyxZQUFBLElBQUEsc0JBQUEsQ0FBdUMsQ0FBQyxVQUFBLElBQUEsb0JBQUEsQ0FBbUMsQ0FBQyxZQUFBLEdBQWUsQ0FBQyxZQUFBLElBQWdCLENBQUMsWUFBQSxJQUFnQixDQUFDLE9BQUEsQ0FBUSxDQUFDLGVBQUEsSUFBbUIsQ0FBQyxRQUFBLElBQVksQ0FBQyxlQUFBLElBQW1CLENBQUMsb0JBQUEsSUFBd0IsQ0FBQyxpQkFBQSxJQUFxQixDQUFDLGdCQUFBLElBQW9CLENBQUMsWUFBQSxJQUFnQixDQUFDLHVDQUFBLGtCQUFBLENBQTRCLE1BQUEsSUFBQSxvQkFBQSxDQUErQixDQUFDLGlCQUFBLElBQXFCLENBQUMsWUFBQSxJQUFnQixDQUFDLHVDQUFBLHNCQUFBLENBQWdDLE1BQUEsSUFBQSxvQkFBQSxDQUErQixDQUFDLGdCQUFBLElBQW9CLENBQUMsWUFBQSxJQUFnQixDQUFDLHVDQUFBLGFBQUEsQ0FBdUIsTUFBQSxJQUFBLG9CQUFBLENBQStCLENBQUMsb0JBQUEsSUFBd0IsQ0FBQyxpQkFBQSxJQUFxQixDQUFDLGdCQUFBLElBQW9CLENBQUMsWUFBQSxJQUFnQixDQUFDLHVDQUFBLDhCQUFBLENBQUEsdUNBQUEsMkJBQUEsQ0FBQSx1Q0FBQSwrQkFBQSxDQUFBLHVDQUFBLG1DQUFBLENBQW1LLG1CQUFBLElBQXVCLENBQUMsdUNBQUEsWUFBQSxDQUFzQixRQUFBLElBQVksQ0FBQyx1Q0FBQSxTQUFBLENBQW1CLE1BQUEsSUFBQSxtQkFBQSxDQUE4QixDQUFDLHVDQUFBLFNBQUEsa0JBQUEsQ0FBcUMsTUFBQSxJQUFBLG1CQUFBLENBQThCLENBQUMsdUNBQUEsU0FBQSxzQkFBQSxDQUF5QyxNQUFBLElBQUEsbUJBQUEsQ0FBOEIsQ0FBQyx1Q0FBQSxTQUFBLGFBQUEsQ0FBZ0MsTUFBQSxJQUFBLG1CQUFBLENBQThCLENBQUMsaURBQUEsQ0FBb0IsWUFBQSxNQUFrQixDQUFDLGdCQUFBLFdBQTJCLENBQUMsaUJBQUEsSUFBQSwwQkFBQSxDQUFnRCxDQUFDLE9BQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLDRCQUFBLENBQWtELENBQUMsY0FBQSxJQUFBLDJCQUFBLENBQThDLENBQUMsT0FBQSxJQUFXLENBQUMsUUFBQSxJQUFZLENBQUMsWUFBQSxJQUFnQixDQUFDLFNBQUEsUUFBaUIsQ0FBQyxpREFBQSxNQUFBLENBQTBCLGlCQUFBLElBQUEsNEJBQUEsQ0FBa0QsQ0FBQyxtQkFBQSx1Q0FBQSxDQUE2QixpQkFBQSxJQUFBLDJCQUFBLENBQWlELENBQUMsT0FBQSxPQUFjLENBQUMsbUJBQUEsd0JBQUEsQ0FBQSxrQ0FBQSxDQUFpRCxRQUFBLElBQVksQ0FBQyxpREFBQSxhQUFBLENBQWlDLGlCQUFBLElBQUEsK0JBQUEsQ0FBcUQsQ0FBQyxrQ0FBQSxhQUFBLENBQUEsd0JBQUEsa0JBQUEsQ0FBNkQsTUFBQSxJQUFBLG1CQUFBLENBQThCLENBQUMsa0NBQUEsYUFBQSxDQUFBLHdCQUFBLHNCQUFBLENBQWlFLE1BQUEsSUFBQSxtQkFBQSxDQUE4QixDQUFDLGtDQUFBLGFBQUEsQ0FBQSx3QkFBQSxhQUFBLENBQXdELE1BQUEsSUFBQSxtQkFBQSxDQUE4QixDQUFDLGtDQUFBLGFBQUEsQ0FBQSxrQ0FBQSxNQUFBLENBQTJELGNBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLG9CQUFBLENBQWlELENBQUMsa0NBQUEsYUFBQSxDQUFBLEFBQUEsc0JBQUEsQUFBQSxDQUFpRSxRQUFBLElBQVksQ0FBQyxpREFBQSxDQUFvQixXQUFBLEtBQUEsSUFBQSxDQUFBLENBQUEsQ0FBQSxHQUFBLENBQTJCLENBQUMsY0FBQSxJQUFBLDJCQUFBLENBQThDLENBQUMsWUFBQSxLQUFBLElBQUEsQ0FBQSxDQUFBLENBQUEsR0FBQSxDQUE0QixDQUFDLGtCQUFBLElBQXNCLENBQUMsbUJBQUEsSUFBdUIsQ0FBQyxTQUFBLE1BQWUsQ0FBQyxlQUFBLElBQW1CLENBQUMsU0FBQSxRQUFpQixDQUFDLGlEQUFBLE1BQUEsQ0FBMEIsV0FBQSxJQUFlLENBQUMsY0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsbUNBQUEsQ0FBZ0UsQ0FBQyxXQUFBLFVBQXFCLENBQUMsUUFBQSxFQUFVLENBQUMsWUFBQSxJQUFnQixDQUFDLGdCQUFBLENBQWlCLENBQUMsbUJBQUEsQ0FBb0IsQ0FBQyxTQUFBLFFBQWlCLENBQUMsK0NBQUEsQ0FBa0IsWUFBQSxNQUFrQixDQUFDLE9BQUEsT0FBYyxDQUFDLFFBQUEsSUFBWSxDQUFDLEtBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxJQUFhLENBQUMsZ0NBQUEsQ0FBQSxnQkFBQSxBQUFBLENBQTZDLHFCQUFBLEdBQXdCLENBQUMsb0JBQUEsR0FBdUIsQ0FBQyxnQ0FBQSxDQUFBLDhCQUFBLEFBQUEsQ0FBMkQscUJBQUEsQ0FBc0IsQ0FBQyxvQkFBQSxDQUFxQixDQUFDLGdDQUFBLENBQUEsNkJBQUEsQUFBQSxDQUEwRCxtQkFBQSxHQUFzQixDQUFDLGtCQUFBLEdBQXFCLENBQUMsZ0NBQUEsQ0FBQSxBQUFBLHNCQUFBLEFBQUEsQ0FBa0QsUUFBQSxJQUFZLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVGV4dEJveC5zdmVsdGUiXX0= */');
}
var get_buttons_slot_changes = (dirty) => ({ value: dirty[0] & /*value*/
1 });
var get_buttons_slot_context = (ctx) => ({ value: (
  /*value*/
  ctx[0]
) });
function create_if_block_15(ctx) {
  let input;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "week" },
    /*inputProps*/
    ctx[18]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(input, "svelte-1yv8oe6", true);
      add_location(input, file13, 115, 2, 5353);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      ctx[45](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler_11*/
            ctx[44]
          ),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[14].call(null, input))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "week" },
        /*inputProps*/
        ctx2[18]
      ]));
      if (dirty[0] & /*value*/
      1) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      toggle_class(input, "svelte-1yv8oe6", true);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[45](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(115:28) ",
    ctx
  });
  return block;
}
function create_if_block_14(ctx) {
  let input;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "time" },
    /*inputProps*/
    ctx[18]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(input, "svelte-1yv8oe6", true);
      add_location(input, file13, 113, 2, 5230);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      ctx[43](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler_10*/
            ctx[42]
          ),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[14].call(null, input))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "time" },
        /*inputProps*/
        ctx2[18]
      ]));
      if (dirty[0] & /*value*/
      1) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      toggle_class(input, "svelte-1yv8oe6", true);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[43](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(113:28) ",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let input;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "month" },
    /*inputProps*/
    ctx[18]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(input, "svelte-1yv8oe6", true);
      add_location(input, file13, 111, 2, 5106);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      ctx[41](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler_9*/
            ctx[40]
          ),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[14].call(null, input))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "month" },
        /*inputProps*/
        ctx2[18]
      ]));
      if (dirty[0] & /*value*/
      1) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      toggle_class(input, "svelte-1yv8oe6", true);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[41](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(111:29) ",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let input;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "datetime-local" },
    /*inputProps*/
    ctx[18]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(input, "svelte-1yv8oe6", true);
      add_location(input, file13, 109, 2, 4972);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      ctx[39](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler_8*/
            ctx[38]
          ),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[14].call(null, input))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "datetime-local" },
        /*inputProps*/
        ctx2[18]
      ]));
      if (dirty[0] & /*value*/
      1) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      toggle_class(input, "svelte-1yv8oe6", true);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[39](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(109:38) ",
    ctx
  });
  return block;
}
function create_if_block_11(ctx) {
  let input;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "date" },
    /*inputProps*/
    ctx[18]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(input, "svelte-1yv8oe6", true);
      add_location(input, file13, 107, 2, 4839);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      ctx[37](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler_7*/
            ctx[36]
          ),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[14].call(null, input))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "date" },
        /*inputProps*/
        ctx2[18]
      ]));
      if (dirty[0] & /*value*/
      1) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      toggle_class(input, "svelte-1yv8oe6", true);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[37](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_11.name,
    type: "if",
    source: "(107:28) ",
    ctx
  });
  return block;
}
function create_if_block_10(ctx) {
  let input;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "url" },
    /*inputProps*/
    ctx[18]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(input, "svelte-1yv8oe6", true);
      add_location(input, file13, 105, 2, 4717);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      ctx[35](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler_6*/
            ctx[34]
          ),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[14].call(null, input))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "url" },
        /*inputProps*/
        ctx2[18]
      ]));
      if (dirty[0] & /*value*/
      1) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      toggle_class(input, "svelte-1yv8oe6", true);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[35](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(105:27) ",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let input;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "tel" },
    /*inputProps*/
    ctx[18]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(input, "svelte-1yv8oe6", true);
      add_location(input, file13, 103, 2, 4596);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      ctx[33](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler_5*/
            ctx[32]
          ),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[14].call(null, input))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "tel" },
        /*inputProps*/
        ctx2[18]
      ]));
      if (dirty[0] & /*value*/
      1) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      toggle_class(input, "svelte-1yv8oe6", true);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[33](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(103:27) ",
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let input;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "email" },
    /*inputProps*/
    ctx[18]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(input, "svelte-1yv8oe6", true);
      add_location(input, file13, 101, 2, 4473);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      ctx[31](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler_4*/
            ctx[30]
          ),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[14].call(null, input))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "email" },
        /*inputProps*/
        ctx2[18]
      ]));
      if (dirty[0] & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      toggle_class(input, "svelte-1yv8oe6", true);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[31](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(101:29) ",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let input;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "password" },
    /*inputProps*/
    ctx[18]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(input, "svelte-1yv8oe6", true);
      add_location(input, file13, 99, 2, 4345);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      ctx[29](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler_3*/
            ctx[28]
          ),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[14].call(null, input))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "password" },
        /*inputProps*/
        ctx2[18]
      ]));
      if (dirty[0] & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      toggle_class(input, "svelte-1yv8oe6", true);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[29](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(99:32) ",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let input;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "search" },
    /*inputProps*/
    ctx[18]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(input, "svelte-1yv8oe6", true);
      add_location(input, file13, 97, 2, 4216);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      ctx[27](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler_2*/
            ctx[26]
          ),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[14].call(null, input))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "search" },
        /*inputProps*/
        ctx2[18]
      ]));
      if (dirty[0] & /*value*/
      1) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      toggle_class(input, "svelte-1yv8oe6", true);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[27](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(97:30) ",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let input;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "number" },
    /*inputProps*/
    ctx[18]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(input, "svelte-1yv8oe6", true);
      add_location(input, file13, 95, 2, 4089);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      ctx[25](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler_1*/
            ctx[24]
          ),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[14].call(null, input))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "number" },
        /*inputProps*/
        ctx2[18]
      ]));
      if (dirty[0] & /*value*/
      1 && to_number(input.value) !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      toggle_class(input, "svelte-1yv8oe6", true);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[25](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(95:30) ",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let input;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "text" },
    /*inputProps*/
    ctx[18]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(input, "svelte-1yv8oe6", true);
      add_location(input, file13, 93, 2, 3964);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      ctx[23](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[22]
          ),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[14].call(null, input))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "text" },
        /*inputProps*/
        ctx2[18]
      ]));
      if (dirty[0] & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      toggle_class(input, "svelte-1yv8oe6", true);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[23](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: '(93:1) {#if type === \\"text\\"}',
    ctx
  });
  return block;
}
function create_if_block6(ctx) {
  let t0;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = (
    /*clearButton*/
    ctx[8] && /*value*/
    ctx[0] && !/*readonly*/
    ctx[11] && create_if_block_3(ctx)
  );
  let if_block1 = (
    /*type*/
    ctx[7] === "search" && /*searchButton*/
    ctx[9] && create_if_block_2(ctx)
  );
  let if_block2 = (
    /*type*/
    ctx[7] === "password" && /*value*/
    ctx[0] && /*revealButton*/
    ctx[10] && create_if_block_16(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*clearButton*/
        ctx2[8] && /*value*/
        ctx2[0] && !/*readonly*/
        ctx2[11]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*clearButton, value, readonly*/
          2305) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*type*/
        ctx2[7] === "search" && /*searchButton*/
        ctx2[9]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*type, searchButton*/
          640) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*type*/
        ctx2[7] === "password" && /*value*/
        ctx2[0] && /*revealButton*/
        ctx2[10]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*type, value, revealButton*/
          1153) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_16(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(120:2) {#if !disabled}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let textboxbutton;
  let updating_element;
  let current;
  function textboxbutton_element_binding(value) {
    ctx[46](value);
  }
  let textboxbutton_props = {
    class: "text-box-clear-button",
    "aria-label": "Clear value",
    $$slots: { default: [create_default_slot_2] },
    $$scope: { ctx }
  };
  if (
    /*clearButtonElement*/
    ctx[4] !== void 0
  ) {
    textboxbutton_props.element = /*clearButtonElement*/
    ctx[4];
  }
  textboxbutton = new TextBoxButton_default({
    props: textboxbutton_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(textboxbutton, "element", textboxbutton_element_binding));
  textboxbutton.$on(
    "click",
    /*handleClear*/
    ctx[15]
  );
  const block = {
    c: function create() {
      create_component(textboxbutton.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(textboxbutton.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(textboxbutton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const textboxbutton_changes = {};
      if (dirty[1] & /*$$scope*/
      1048576) {
        textboxbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_element && dirty[0] & /*clearButtonElement*/
      16) {
        updating_element = true;
        textboxbutton_changes.element = /*clearButtonElement*/
        ctx2[4];
        add_flush_callback(() => updating_element = false);
      }
      textboxbutton.$set(textboxbutton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(textboxbutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(textboxbutton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(textboxbutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(121:3) {#if clearButton && value && !readonly}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        "aria-hidden": true,
        xmlns: true,
        width: true,
        height: true,
        viewBox: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M2.08859 2.21569L2.14645 2.14645C2.32001 1.97288 2.58944 1.9536 2.78431 2.08859L2.85355 2.14645L6 5.293L9.14645 2.14645C9.34171 1.95118 9.65829 1.95118 9.85355 2.14645C10.0488 2.34171 10.0488 2.65829 9.85355 2.85355L6.707 6L9.85355 9.14645C10.0271 9.32001 10.0464 9.58944 9.91141 9.78431L9.85355 9.85355C9.67999 10.0271 9.41056 10.0464 9.21569 9.91141L9.14645 9.85355L6 6.707L2.85355 9.85355C2.65829 10.0488 2.34171 10.0488 2.14645 9.85355C1.95118 9.65829 1.95118 9.34171 2.14645 9.14645L5.293 6L2.14645 2.85355C1.97288 2.67999 1.9536 2.41056 2.08859 2.21569L2.14645 2.14645L2.08859 2.21569Z");
      add_location(path, file13, 134, 6, 5924);
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "12");
      attr_dev(svg, "height", "12");
      attr_dev(svg, "viewBox", "0 0 12 12");
      add_location(svg, file13, 127, 5, 5779);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: '(122:4) <TextBoxButton      class=\\"text-box-clear-button\\"      aria-label=\\"Clear value\\"      on:click={handleClear}      bind:element={clearButtonElement}     >',
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let textboxbutton;
  let updating_element;
  let current;
  function textboxbutton_element_binding_1(value) {
    ctx[47](value);
  }
  let textboxbutton_props = {
    "aria-label": "Search",
    $$slots: { default: [create_default_slot_1] },
    $$scope: { ctx }
  };
  if (
    /*searchButtonElement*/
    ctx[5] !== void 0
  ) {
    textboxbutton_props.element = /*searchButtonElement*/
    ctx[5];
  }
  textboxbutton = new TextBoxButton_default({
    props: textboxbutton_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(textboxbutton, "element", textboxbutton_element_binding_1));
  textboxbutton.$on(
    "click",
    /*handleSearch*/
    ctx[16]
  );
  const block = {
    c: function create() {
      create_component(textboxbutton.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(textboxbutton.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(textboxbutton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const textboxbutton_changes = {};
      if (dirty[1] & /*$$scope*/
      1048576) {
        textboxbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_element && dirty[0] & /*searchButtonElement*/
      32) {
        updating_element = true;
        textboxbutton_changes.element = /*searchButtonElement*/
        ctx2[5];
        add_flush_callback(() => updating_element = false);
      }
      textboxbutton.$set(textboxbutton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(textboxbutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(textboxbutton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(textboxbutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: '(142:3) {#if type === \\"search\\" && searchButton}',
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        "aria-hidden": true,
        xmlns: true,
        width: true,
        height: true,
        viewBox: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true, fill: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5.00038 1C2.79103 1 1 2.7909 1 5.00008C1 7.20927 2.79103 9.00017 5.00038 9.00017C5.92463 9.00017 6.77568 8.68675 7.45302 8.1604L10.1464 10.8536C10.3416 11.0488 10.6583 11.0488 10.8535 10.8536C11.0488 10.6583 11.0488 10.3417 10.8535 10.1464L8.16028 7.45337C8.68705 6.77595 9.00075 5.92465 9.00075 5.00008C9.00075 2.7909 7.20972 1 5.00038 1ZM2.00009 5.00008C2.00009 3.34319 3.34337 2.00002 5.00038 2.00002C6.65739 2.00002 8.00066 3.34319 8.00066 5.00008C8.00066 6.65697 6.65739 8.00015 5.00038 8.00015C3.34337 8.00015 2.00009 6.65697 2.00009 5.00008Z");
      attr_dev(path, "fill", "currentColor");
      add_location(path, file13, 154, 6, 6923);
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "12");
      attr_dev(svg, "height", "12");
      attr_dev(svg, "viewBox", "0 0 12 12");
      add_location(svg, file13, 147, 5, 6778);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: '(143:4) <TextBoxButton      aria-label=\\"Search\\"      on:click={handleSearch}      bind:element={searchButtonElement}     >',
    ctx
  });
  return block;
}
function create_if_block_16(ctx) {
  let textboxbutton;
  let updating_element;
  let current;
  function textboxbutton_element_binding_2(value) {
    ctx[48](value);
  }
  let textboxbutton_props = {
    "aria-label": "Reveal password",
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  if (
    /*revealButtonElement*/
    ctx[6] !== void 0
  ) {
    textboxbutton_props.element = /*revealButtonElement*/
    ctx[6];
  }
  textboxbutton = new TextBoxButton_default({
    props: textboxbutton_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(textboxbutton, "element", textboxbutton_element_binding_2));
  textboxbutton.$on(
    "mousedown",
    /*handleReveal*/
    ctx[17]
  );
  const block = {
    c: function create() {
      create_component(textboxbutton.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(textboxbutton.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(textboxbutton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const textboxbutton_changes = {};
      if (dirty[1] & /*$$scope*/
      1048576) {
        textboxbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_element && dirty[0] & /*revealButtonElement*/
      64) {
        updating_element = true;
        textboxbutton_changes.element = /*revealButtonElement*/
        ctx2[6];
        add_flush_callback(() => updating_element = false);
      }
      textboxbutton.$set(textboxbutton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(textboxbutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(textboxbutton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(textboxbutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_16.name,
    type: "if",
    source: '(162:3) {#if type === \\"password\\" && value && revealButton}',
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        "aria-hidden": true,
        xmlns: true,
        width: true,
        height: true,
        viewBox: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true, fill: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M0,554.5C0,550.833 0.5,547.167 1.5,543.5C11.5,505.833 25.75,470.417 44.25,437.25C62.75,404.083 84.5833,373.667 109.75,346C134.917,318.333 162.75,293.667 193.25,272C223.75,250.333 256.25,231.917 290.75,216.75C325.25,201.583 361.167,190.083 398.5,182.25C435.833,174.417 473.667,170.5 512,170.5C550,170.5 587.583,174.417 624.75,182.25C661.917,190.083 697.75,201.5 732.25,216.5C766.75,231.5 799.417,249.917 830.25,271.75C861.083,293.583 889.083,318.25 914.25,345.75C939.417,373.25 961.25,403.5 979.75,436.5C998.25,469.5 1012.5,504.833 1022.5,542.5C1023.5,546.167 1024,550 1024,554C1024,566 1019.92,576.083 1011.75,584.25C1003.58,592.417 993.5,596.5 981.5,596.5C971.5,596.5 962.917,593.667 955.75,588C948.583,582.333 943.333,574.833 940,565.5C937,556.167 934.083,547.5 931.25,539.5C928.417,531.5 925.5,523.583 922.5,515.75C919.5,507.917 916.167,500.167 912.5,492.5C908.833,484.833 904.333,476.667 899,468C879.333,435 855.583,405.417 827.75,379.25C799.917,353.083 769.333,330.917 736,312.75C702.667,294.583 667.417,280.583 630.25,270.75C593.083,260.917 555.5,256 517.5,256L506.5,256C468.5,256 430.917,260.917 393.75,270.75C356.583,280.583 321.333,294.667 288,313C254.667,331.333 224,353.583 196,379.75C168,405.917 144.333,435.5 125,468.5C119.667,477.167 115.167,485.417 111.5,493.25C107.833,501.083 104.5,508.833 101.5,516.5C98.5,524.167 95.5833,532 92.75,540C89.9167,548 87,556.667 84,566C80.6667,575.333 75.5,582.917 68.5,588.75C61.5,594.583 52.8333,597.5 42.5,597.5C36.8333,597.5 31.4167,596.333 26.25,594C21.0833,591.667 16.5833,588.583 12.75,584.75C8.91667,580.917 5.83333,576.417 3.5,571.25C1.16667,566.083 0,560.5 0,554.5ZM256,597.5L256,592.5C256,557.833 262.917,525.25 276.75,494.75C290.583,464.25 309.25,437.667 332.75,415C356.25,392.333 383.417,374.417 414.25,361.25C445.083,348.083 477.667,341.5 512,341.5C547.333,341.5 580.583,348.167 611.75,361.5C642.917,374.833 670.083,393.083 693.25,416.25C716.417,439.417 734.667,466.583 748,497.75C761.333,528.917 768,562.167 768,597.5C768,632.833 761.333,666.083 748,697.25C734.667,728.417 716.417,755.583 693.25,778.75C670.083,801.917 642.917,820.167 611.75,833.5C580.583,846.833 547.333,853.5 512,853.5C476.667,853.5 443.417,846.833 412.25,833.5C381.083,820.167 353.917,801.917 330.75,778.75C307.583,755.583 289.333,728.417 276,697.25C262.667,666.083 256,632.833 256,597.5ZM682.5,597.5L682.5,594C682.5,571 677.917,549.333 668.75,529C659.583,508.667 647.167,490.917 631.5,475.75C615.833,460.583 597.667,448.583 577,439.75C556.333,430.917 534.667,426.5 512,426.5C488.333,426.5 466.167,431 445.5,440C424.833,449 406.833,461.25 391.5,476.75C376.167,492.25 364,510.417 355,531.25C346,552.083 341.5,574.167 341.5,597.5C341.5,621.167 346,643.333 355,664C364,684.667 376.167,702.667 391.5,718C406.833,733.333 424.833,745.5 445.5,754.5C466.167,763.5 488.333,768 512,768C535.333,768 557.417,763.5 578.25,754.5C599.083,745.5 617.167,733.333 632.5,718C647.833,702.667 660,684.667 669,664C678,643.333 682.5,621.167 682.5,597.5Z");
      attr_dev(path, "fill", "currentColor");
      add_location(path, file13, 174, 6, 7909);
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "10");
      attr_dev(svg, "height", "10");
      attr_dev(svg, "viewBox", "0 171 1024 683");
      add_location(svg, file13, 167, 5, 7759);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: '(163:4) <TextBoxButton      aria-label=\\"Reveal password\\"      on:mousedown={handleReveal}      bind:element={revealButtonElement}     >',
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let div2;
  let t0;
  let div0;
  let t1;
  let div1;
  let t2;
  let t3;
  let div2_class_value;
  let externalMouseEvents_action;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*type*/
      ctx2[7] === "text"
    )
      return create_if_block_4;
    if (
      /*type*/
      ctx2[7] === "number"
    )
      return create_if_block_5;
    if (
      /*type*/
      ctx2[7] === "search"
    )
      return create_if_block_6;
    if (
      /*type*/
      ctx2[7] === "password"
    )
      return create_if_block_7;
    if (
      /*type*/
      ctx2[7] === "email"
    )
      return create_if_block_8;
    if (
      /*type*/
      ctx2[7] === "tel"
    )
      return create_if_block_9;
    if (
      /*type*/
      ctx2[7] === "url"
    )
      return create_if_block_10;
    if (
      /*type*/
      ctx2[7] === "date"
    )
      return create_if_block_11;
    if (
      /*type*/
      ctx2[7] === "datetime-local"
    )
      return create_if_block_12;
    if (
      /*type*/
      ctx2[7] === "month"
    )
      return create_if_block_13;
    if (
      /*type*/
      ctx2[7] === "time"
    )
      return create_if_block_14;
    if (
      /*type*/
      ctx2[7] === "week"
    )
      return create_if_block_15;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block0 = current_block_type && current_block_type(ctx);
  let if_block1 = !/*disabled*/
  ctx[12] && create_if_block6(ctx);
  const buttons_slot_template = (
    /*#slots*/
    ctx[20].buttons
  );
  const buttons_slot = create_slot(
    buttons_slot_template,
    ctx,
    /*$$scope*/
    ctx[51],
    get_buttons_slot_context
  );
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[51],
    null
  );
  const block = {
    c: function create() {
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      t1 = space();
      div1 = element("div");
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (buttons_slot)
        buttons_slot.c();
      t3 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (if_block0)
        if_block0.l(div2_nodes);
      t0 = claim_space(div2_nodes);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block1)
        if_block1.l(div1_nodes);
      t2 = claim_space(div1_nodes);
      if (buttons_slot)
        buttons_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t3 = claim_space(div2_nodes);
      if (default_slot)
        default_slot.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "text-box-underline svelte-1yv8oe6");
      add_location(div0, file13, 117, 1, 5453);
      attr_dev(div1, "class", "text-box-buttons svelte-1yv8oe6");
      add_location(div1, file13, 118, 1, 5489);
      attr_dev(div2, "class", div2_class_value = "text-box-container " + /*className*/
      ctx[13] + " svelte-1yv8oe6");
      toggle_class(
        div2,
        "disabled",
        /*disabled*/
        ctx[12]
      );
      add_location(div2, file13, 83, 0, 3639);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      if (if_block1)
        if_block1.m(div1, null);
      append_hydration_dev(div1, t2);
      if (buttons_slot) {
        buttons_slot.m(div1, null);
      }
      ctx[49](div1);
      append_hydration_dev(div2, t3);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      ctx[50](div2);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(externalMouseEvents_action = externalMouseEvents.call(null, div2, { type: "mousedown" })),
          listen_dev(
            div2,
            "outermousedown",
            /*outermousedown_handler*/
            ctx[21],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if (if_block0)
          if_block0.d(1);
        if_block0 = current_block_type && current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div2, t0);
        }
      }
      if (!/*disabled*/
      ctx2[12]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*disabled*/
          4096) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block6(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (buttons_slot) {
        if (buttons_slot.p && (!current || dirty[0] & /*value*/
        1 | dirty[1] & /*$$scope*/
        1048576)) {
          update_slot_base(
            buttons_slot,
            buttons_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[51],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[51]
            ) : get_slot_changes(
              buttons_slot_template,
              /*$$scope*/
              ctx2[51],
              dirty,
              get_buttons_slot_changes
            ),
            get_buttons_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[51],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[51]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[51],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*className*/
      8192 && div2_class_value !== (div2_class_value = "text-box-container " + /*className*/
      ctx2[13] + " svelte-1yv8oe6")) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*className, disabled*/
      12288) {
        toggle_class(
          div2,
          "disabled",
          /*disabled*/
          ctx2[12]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block1);
      transition_in(buttons_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      transition_out(buttons_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block0) {
        if_block0.d();
      }
      if (if_block1)
        if_block1.d();
      if (buttons_slot)
        buttons_slot.d(detaching);
      ctx[49](null);
      if (default_slot)
        default_slot.d(detaching);
      ctx[50](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "value",
    "type",
    "placeholder",
    "clearButton",
    "searchButton",
    "revealButton",
    "readonly",
    "disabled",
    "class",
    "inputElement",
    "containerElement",
    "buttonsContainerElement",
    "clearButtonElement",
    "searchButtonElement",
    "revealButtonElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TextBox", slots, ["buttons", "default"]);
  let { value = "" } = $$props;
  let { type = "text" } = $$props;
  let { placeholder = void 0 } = $$props;
  let { clearButton = true } = $$props;
  let { searchButton = true } = $$props;
  let { revealButton = true } = $$props;
  let { readonly = false } = $$props;
  let { disabled = false } = $$props;
  let { class: className = "" } = $$props;
  let { inputElement = null } = $$props;
  let { containerElement = null } = $$props;
  let { buttonsContainerElement = null } = $$props;
  let { clearButtonElement = null } = $$props;
  let { searchButtonElement = null } = $$props;
  let { revealButtonElement = null } = $$props;
  const dispatch = createEventDispatcher();
  const forwardEvents = createEventForwarder(get_current_component(), ["clear", "search", "reveal", "outermousedown"]);
  function handleClear(event2) {
    dispatch("clear", event2);
    inputElement.focus();
    $$invalidate(0, value = "");
  }
  function handleSearch(event2) {
    dispatch("search", event2);
    inputElement.focus();
  }
  function handleReveal(event2) {
    inputElement.focus();
    inputElement.setAttribute("type", "text");
    dispatch("reveal", event2);
    let revealButtonMouseDown = true;
    const hidePassword = () => {
      if (!revealButtonMouseDown)
        return;
      inputElement.focus();
      revealButtonMouseDown = false;
      inputElement.setAttribute("type", "password");
      window.removeEventListener("mouseup", hidePassword);
    };
    window.addEventListener("mouseup", hidePassword);
  }
  const inputProps = {
    class: "text-box",
    disabled: disabled || void 0,
    readonly: readonly || void 0,
    placeholder: placeholder || void 0,
    ...$$restProps
  };
  function outermousedown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(1, inputElement);
    });
  }
  function input_input_handler_1() {
    value = to_number(this.value);
    $$invalidate(0, value);
  }
  function input_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(1, inputElement);
    });
  }
  function input_input_handler_2() {
    value = this.value;
    $$invalidate(0, value);
  }
  function input_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(1, inputElement);
    });
  }
  function input_input_handler_3() {
    value = this.value;
    $$invalidate(0, value);
  }
  function input_binding_3($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(1, inputElement);
    });
  }
  function input_input_handler_4() {
    value = this.value;
    $$invalidate(0, value);
  }
  function input_binding_4($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(1, inputElement);
    });
  }
  function input_input_handler_5() {
    value = this.value;
    $$invalidate(0, value);
  }
  function input_binding_5($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(1, inputElement);
    });
  }
  function input_input_handler_6() {
    value = this.value;
    $$invalidate(0, value);
  }
  function input_binding_6($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(1, inputElement);
    });
  }
  function input_input_handler_7() {
    value = this.value;
    $$invalidate(0, value);
  }
  function input_binding_7($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(1, inputElement);
    });
  }
  function input_input_handler_8() {
    value = this.value;
    $$invalidate(0, value);
  }
  function input_binding_8($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(1, inputElement);
    });
  }
  function input_input_handler_9() {
    value = this.value;
    $$invalidate(0, value);
  }
  function input_binding_9($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(1, inputElement);
    });
  }
  function input_input_handler_10() {
    value = this.value;
    $$invalidate(0, value);
  }
  function input_binding_10($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(1, inputElement);
    });
  }
  function input_input_handler_11() {
    value = this.value;
    $$invalidate(0, value);
  }
  function input_binding_11($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(1, inputElement);
    });
  }
  function textboxbutton_element_binding(value2) {
    clearButtonElement = value2;
    $$invalidate(4, clearButtonElement);
  }
  function textboxbutton_element_binding_1(value2) {
    searchButtonElement = value2;
    $$invalidate(5, searchButtonElement);
  }
  function textboxbutton_element_binding_2(value2) {
    revealButtonElement = value2;
    $$invalidate(6, revealButtonElement);
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttonsContainerElement = $$value;
      $$invalidate(3, buttonsContainerElement);
    });
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      containerElement = $$value;
      $$invalidate(2, containerElement);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(53, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("type" in $$new_props)
      $$invalidate(7, type = $$new_props.type);
    if ("placeholder" in $$new_props)
      $$invalidate(19, placeholder = $$new_props.placeholder);
    if ("clearButton" in $$new_props)
      $$invalidate(8, clearButton = $$new_props.clearButton);
    if ("searchButton" in $$new_props)
      $$invalidate(9, searchButton = $$new_props.searchButton);
    if ("revealButton" in $$new_props)
      $$invalidate(10, revealButton = $$new_props.revealButton);
    if ("readonly" in $$new_props)
      $$invalidate(11, readonly = $$new_props.readonly);
    if ("disabled" in $$new_props)
      $$invalidate(12, disabled = $$new_props.disabled);
    if ("class" in $$new_props)
      $$invalidate(13, className = $$new_props.class);
    if ("inputElement" in $$new_props)
      $$invalidate(1, inputElement = $$new_props.inputElement);
    if ("containerElement" in $$new_props)
      $$invalidate(2, containerElement = $$new_props.containerElement);
    if ("buttonsContainerElement" in $$new_props)
      $$invalidate(3, buttonsContainerElement = $$new_props.buttonsContainerElement);
    if ("clearButtonElement" in $$new_props)
      $$invalidate(4, clearButtonElement = $$new_props.clearButtonElement);
    if ("searchButtonElement" in $$new_props)
      $$invalidate(5, searchButtonElement = $$new_props.searchButtonElement);
    if ("revealButtonElement" in $$new_props)
      $$invalidate(6, revealButtonElement = $$new_props.revealButtonElement);
    if ("$$scope" in $$new_props)
      $$invalidate(51, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    get_current_component,
    externalMouseEvents,
    createEventForwarder,
    TextBoxButton: TextBoxButton_default,
    value,
    type,
    placeholder,
    clearButton,
    searchButton,
    revealButton,
    readonly,
    disabled,
    className,
    inputElement,
    containerElement,
    buttonsContainerElement,
    clearButtonElement,
    searchButtonElement,
    revealButtonElement,
    dispatch,
    forwardEvents,
    handleClear,
    handleSearch,
    handleReveal,
    inputProps
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("type" in $$props)
      $$invalidate(7, type = $$new_props.type);
    if ("placeholder" in $$props)
      $$invalidate(19, placeholder = $$new_props.placeholder);
    if ("clearButton" in $$props)
      $$invalidate(8, clearButton = $$new_props.clearButton);
    if ("searchButton" in $$props)
      $$invalidate(9, searchButton = $$new_props.searchButton);
    if ("revealButton" in $$props)
      $$invalidate(10, revealButton = $$new_props.revealButton);
    if ("readonly" in $$props)
      $$invalidate(11, readonly = $$new_props.readonly);
    if ("disabled" in $$props)
      $$invalidate(12, disabled = $$new_props.disabled);
    if ("className" in $$props)
      $$invalidate(13, className = $$new_props.className);
    if ("inputElement" in $$props)
      $$invalidate(1, inputElement = $$new_props.inputElement);
    if ("containerElement" in $$props)
      $$invalidate(2, containerElement = $$new_props.containerElement);
    if ("buttonsContainerElement" in $$props)
      $$invalidate(3, buttonsContainerElement = $$new_props.buttonsContainerElement);
    if ("clearButtonElement" in $$props)
      $$invalidate(4, clearButtonElement = $$new_props.clearButtonElement);
    if ("searchButtonElement" in $$props)
      $$invalidate(5, searchButtonElement = $$new_props.searchButtonElement);
    if ("revealButtonElement" in $$props)
      $$invalidate(6, revealButtonElement = $$new_props.revealButtonElement);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    value,
    inputElement,
    containerElement,
    buttonsContainerElement,
    clearButtonElement,
    searchButtonElement,
    revealButtonElement,
    type,
    clearButton,
    searchButton,
    revealButton,
    readonly,
    disabled,
    className,
    forwardEvents,
    handleClear,
    handleSearch,
    handleReveal,
    inputProps,
    placeholder,
    slots,
    outermousedown_handler,
    input_input_handler,
    input_binding,
    input_input_handler_1,
    input_binding_1,
    input_input_handler_2,
    input_binding_2,
    input_input_handler_3,
    input_binding_3,
    input_input_handler_4,
    input_binding_4,
    input_input_handler_5,
    input_binding_5,
    input_input_handler_6,
    input_binding_6,
    input_input_handler_7,
    input_binding_7,
    input_input_handler_8,
    input_binding_8,
    input_input_handler_9,
    input_binding_9,
    input_input_handler_10,
    input_binding_10,
    input_input_handler_11,
    input_binding_11,
    textboxbutton_element_binding,
    textboxbutton_element_binding_1,
    textboxbutton_element_binding_2,
    div1_binding,
    div2_binding,
    $$scope
  ];
}
var TextBox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance13,
      create_fragment13,
      safe_not_equal,
      {
        value: 0,
        type: 7,
        placeholder: 19,
        clearButton: 8,
        searchButton: 9,
        revealButton: 10,
        readonly: 11,
        disabled: 12,
        class: 13,
        inputElement: 1,
        containerElement: 2,
        buttonsContainerElement: 3,
        clearButtonElement: 4,
        searchButtonElement: 5,
        revealButtonElement: 6
      },
      add_css13,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TextBox",
      options,
      id: create_fragment13.name
    });
  }
  get value() {
    throw new Error("<TextBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<TextBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<TextBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<TextBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<TextBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<TextBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearButton() {
    throw new Error("<TextBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clearButton(value) {
    throw new Error("<TextBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searchButton() {
    throw new Error("<TextBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searchButton(value) {
    throw new Error("<TextBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get revealButton() {
    throw new Error("<TextBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set revealButton(value) {
    throw new Error("<TextBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<TextBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<TextBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TextBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TextBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TextBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TextBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<TextBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value) {
    throw new Error("<TextBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerElement() {
    throw new Error("<TextBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerElement(value) {
    throw new Error("<TextBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonsContainerElement() {
    throw new Error("<TextBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonsContainerElement(value) {
    throw new Error("<TextBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearButtonElement() {
    throw new Error("<TextBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clearButtonElement(value) {
    throw new Error("<TextBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searchButtonElement() {
    throw new Error("<TextBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searchButtonElement(value) {
    throw new Error("<TextBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get revealButtonElement() {
    throw new Error("<TextBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set revealButtonElement(value) {
    throw new Error("<TextBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TextBox_default = TextBox;

// node_modules/fluent-svelte/ComboBox/ComboBox.svelte
var file14 = "node_modules\\fluent-svelte\\ComboBox\\ComboBox.svelte";
function add_css14(target) {
  append_styles(target, "svelte-12fytfi", '@-webkit-keyframes svelte-12fytfi-menu-in{0%{-webkit-clip-path:var(--fds-grow-clip-path);clip-path:var(--fds-grow-clip-path)}to{-webkit-clip-path:polygon(0 0,100% 0,100% 100%,0 100%);clip-path:polygon(0 0,100% 0,100% 100%,0 100%)}}@keyframes svelte-12fytfi-menu-in{0%{-webkit-clip-path:var(--fds-grow-clip-path);clip-path:var(--fds-grow-clip-path)}to{-webkit-clip-path:polygon(0 0,100% 0,100% 100%,0 100%);clip-path:polygon(0 0,100% 0,100% 100%,0 100%)}}@-webkit-keyframes svelte-12fytfi-shadow-in{0%{box-shadow:none}to{box-shadow:var(--fds-flyout-shadow)}}@keyframes svelte-12fytfi-shadow-in{0%{box-shadow:none}to{box-shadow:var(--fds-flyout-shadow)}}.combo-box.svelte-12fytfi.svelte-12fytfi{display:inline-flex;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.combo-box.svelte-12fytfi .button,.combo-box.svelte-12fytfi .text-box{flex:1 1 auto}.combo-box.svelte-12fytfi .text-box{border-color:var(--fds-control-border-default)}.combo-box.svelte-12fytfi .text-box-underline:after{border-color:transparent}.combo-box.svelte-12fytfi .text-box-container{cursor:default}.combo-box.svelte-12fytfi .text-box-container:focus-visible{cursor:text}.combo-box.editable.svelte-12fytfi .combo-box-textbox:not(:focus-within){border-color:var(--fds-control-border-default);cursor:default}.combo-box.editable.svelte-12fytfi .combo-box-textbox:not(:focus-within) .text-box-underline:after{content:none}.combo-box.editable.svelte-12fytfi .combo-box-textbox.disabled{border-color:var(--fds-control-stroke-default)}.combo-box.editable.open.svelte-12fytfi .combo-box-textbox{background-color:var(--fds-control-fill-input-active);cursor:text}.combo-box.editable.open.svelte-12fytfi .combo-box-textbox .text-box-underline:after{border-bottom:2px solid var(--fds-accent-default);content:""}.combo-box.editable.open.svelte-12fytfi .combo-box-textbox input::-moz-placeholder{color:var(--fds-text-tertiary)}.combo-box.editable.open.svelte-12fytfi .combo-box-textbox input:-ms-input-placeholder{color:var(--fds-text-tertiary)}.combo-box.editable.open.svelte-12fytfi .combo-box-textbox input::placeholder{color:var(--fds-text-tertiary)}.combo-box.editable.open.svelte-12fytfi .text-box-underline{border-end-end-radius:0;border-end-start-radius:0}.combo-box.editable.svelte-12fytfi .combo-box-dropdown.svelte-12fytfi{border-radius:var(--fds-overlay-corner-radius);border-start-end-radius:0;border-start-start-radius:0;inline-size:100%;inset-block-start:100%;inset-inline-start:0;margin:0}.combo-box.editable.svelte-12fytfi .combo-box-icon.svelte-12fytfi{margin:0}.combo-box-label.svelte-12fytfi.svelte-12fytfi{flex:1 1 auto;min-block-size:20px;text-align:start}.combo-box-label.placeholder.svelte-12fytfi.svelte-12fytfi{color:var(--fds-text-secondary)}.combo-box.disabled.svelte-12fytfi .placeholder.svelte-12fytfi{color:var(--fds-text-disabled)}.combo-box-icon.svelte-12fytfi.svelte-12fytfi{-webkit-margin-start:8px;block-size:12px;inline-size:12px;margin-inline-start:8px}.combo-box-dropdown.svelte-12fytfi.svelte-12fytfi{-webkit-margin-before:-6px;-webkit-margin-start:-5px;-webkit-animation:svelte-12fytfi-menu-in var(--fds-control-normal-duration) var(--fds-control-fast-out-slow-in-easing),svelte-12fytfi-shadow-in var(--fds-control-normal-duration) var(--fds-control-fast-out-slow-in-easing) var(--fds-control-normal-duration);animation:svelte-12fytfi-menu-in var(--fds-control-normal-duration) var(--fds-control-fast-out-slow-in-easing),svelte-12fytfi-shadow-in var(--fds-control-normal-duration) var(--fds-control-fast-out-slow-in-easing) var(--fds-control-normal-duration);background-clip:padding-box;background-color:var(--fds-solid-background-quarternary);border:1px solid var(--fds-surface-stroke-flyout);border-radius:var(--fds-overlay-corner-radius);box-shadow:var(--fds-flyout-shadow);box-sizing:border-box;inline-size:calc(100% + 8px);inset-block-start:var(--fds-menu-offset,0);inset-inline-start:0;margin:0;margin-block-start:-6px;margin-inline-start:-5px;max-block-size:504px;overflow:auto;padding:1px;position:absolute;z-index:100}@supports (overflow:overlay){.combo-box-dropdown.svelte-12fytfi.svelte-12fytfi{overflow:overlay}}.combo-box-dropdown.direction-top.svelte-12fytfi.svelte-12fytfi{--fds-grow-clip-path:polygon(0 0,100% 0,100% 25%,0 25%)}.combo-box-dropdown.direction-center.svelte-12fytfi.svelte-12fytfi{--fds-grow-clip-path:polygon(0 25%,100% 24%,100% 75%,0 75%)}.combo-box-dropdown.direction-bottom.svelte-12fytfi.svelte-12fytfi{--fds-grow-clip-path:polygon(0 75%,100% 75%,100% 100%,0 100%)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29tYm9Cb3guc3ZlbHRlIiwibWFwcGluZ3MiOiJBQW9VUSxtQkFBQSxzQkFBQSxDQUEyQixFQUFBLENBQUcsa0JBQUEsSUFBQSxvQkFBQSxDQUEyQyxDQUFDLFVBQUEsSUFBQSxvQkFBQSxDQUFtQyxDQUFDLEVBQUEsQ0FBRyxrQkFBQSxRQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQUEsSUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQXNELENBQUMsVUFBQSxRQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQUEsSUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQThDLENBQUMsQ0FBQyxXQUFBLHNCQUFBLENBQW1CLEVBQUEsQ0FBRyxrQkFBQSxJQUFBLG9CQUFBLENBQTJDLENBQUMsVUFBQSxJQUFBLG9CQUFBLENBQW1DLENBQUMsRUFBQSxDQUFHLGtCQUFBLFFBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBQSxJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBc0QsQ0FBQyxVQUFBLFFBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBQSxJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBOEMsQ0FBQyxDQUFDLG1CQUFBLHdCQUFBLENBQTZCLEVBQUEsQ0FBRyxXQUFBLElBQWUsQ0FBQyxFQUFBLENBQUcsV0FBQSxJQUFBLG1CQUFBLENBQW1DLENBQUMsQ0FBQyxXQUFBLHdCQUFBLENBQXFCLEVBQUEsQ0FBRyxXQUFBLElBQWUsQ0FBQyxFQUFBLENBQUcsV0FBQSxJQUFBLG1CQUFBLENBQW1DLENBQUMsQ0FBQyx3Q0FBQSxDQUFXLFFBQUEsV0FBbUIsQ0FBQyxTQUFBLFFBQWlCLENBQUMsb0JBQUEsSUFBd0IsQ0FBQyxpQkFBQSxJQUFxQixDQUFDLGdCQUFBLElBQW9CLENBQUMsWUFBQSxJQUFnQixDQUFDLHlCQUFBLENBQUEsQUFBQSxPQUFBLEFBQUEsQ0FBQSx5QkFBQSxDQUFBLEFBQUEsU0FBQSxBQUFBLENBQTBELEtBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxJQUFhLENBQUMseUJBQUEsQ0FBQSxBQUFBLFNBQUEsQUFBQSxDQUE4QixhQUFBLElBQUEsNEJBQUEsQ0FBOEMsQ0FBQyx5QkFBQSxDQUFBLEFBQUEseUJBQUEsQUFBQSxDQUE4QyxhQUFBLFdBQXdCLENBQUMseUJBQUEsQ0FBQSxBQUFBLG1CQUFBLEFBQUEsQ0FBd0MsT0FBQSxPQUFjLENBQUMseUJBQUEsQ0FBQSxBQUFBLGlDQUFBLEFBQUEsQ0FBc0QsT0FBQSxJQUFXLENBQUMsVUFBQSx3QkFBQSxDQUFBLEFBQUEscUNBQUEsQUFBQSxDQUFtRSxhQUFBLElBQUEsNEJBQUEsQ0FBOEMsQ0FBQyxPQUFBLE9BQWMsQ0FBQyxVQUFBLHdCQUFBLENBQUEsQUFBQSxxQ0FBQSxBQUFBLENBQUEsQUFBQSx5QkFBQSxBQUFBLENBQXNHLFFBQUEsSUFBWSxDQUFDLFVBQUEsd0JBQUEsQ0FBQSxBQUFBLDJCQUFBLEFBQUEsQ0FBeUQsYUFBQSxJQUFBLDRCQUFBLENBQThDLENBQUMsVUFBQSxTQUFBLG9CQUFBLENBQUEsQUFBQSxrQkFBQSxBQUFBLENBQXFELGlCQUFBLElBQUEsK0JBQUEsQ0FBcUQsQ0FBQyxPQUFBLElBQVcsQ0FBQyxVQUFBLFNBQUEsb0JBQUEsQ0FBQSxBQUFBLGtCQUFBLEFBQUEsQ0FBQSxBQUFBLHlCQUFBLEFBQUEsQ0FBd0YsY0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsb0JBQUEsQ0FBaUQsQ0FBQyxRQUFBLEVBQVUsQ0FBQyxVQUFBLFNBQUEsb0JBQUEsQ0FBQSxBQUFBLGtCQUFBLEFBQUEsQ0FBQSxBQUFBLHVCQUFBLEFBQUEsQ0FBc0YsTUFBQSxJQUFBLG1CQUFBLENBQThCLENBQUMsVUFBQSxTQUFBLG9CQUFBLENBQUEsQUFBQSxrQkFBQSxBQUFBLENBQUEsQUFBQSwyQkFBQSxBQUFBLENBQTBGLE1BQUEsSUFBQSxtQkFBQSxDQUE4QixDQUFDLFVBQUEsU0FBQSxvQkFBQSxDQUFBLEFBQUEsa0JBQUEsQUFBQSxDQUFBLEFBQUEsa0JBQUEsQUFBQSxDQUFpRixNQUFBLElBQUEsbUJBQUEsQ0FBOEIsQ0FBQyxVQUFBLFNBQUEsb0JBQUEsQ0FBQSxBQUFBLG1CQUFBLEFBQUEsQ0FBc0Qsc0JBQUEsQ0FBdUIsQ0FBQyx3QkFBQSxDQUF5QixDQUFDLFVBQUEsd0JBQUEsQ0FBQSxrQ0FBQSxDQUF3QyxjQUFBLElBQUEsMkJBQUEsQ0FBOEMsQ0FBQyx3QkFBQSxDQUF5QixDQUFDLDBCQUFBLENBQTJCLENBQUMsWUFBQSxJQUFnQixDQUFDLGtCQUFBLElBQXNCLENBQUMsbUJBQUEsQ0FBb0IsQ0FBQyxPQUFBLENBQVEsQ0FBQyxVQUFBLHdCQUFBLENBQUEsOEJBQUEsQ0FBb0MsT0FBQSxDQUFRLENBQUMsOENBQUEsQ0FBaUIsS0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLElBQWEsQ0FBQyxlQUFBLElBQW1CLENBQUMsV0FBQSxLQUFnQixDQUFDLGdCQUFBLDBDQUFBLENBQTZCLE1BQUEsSUFBQSxvQkFBQSxDQUErQixDQUFDLFVBQUEsd0JBQUEsQ0FBQSwyQkFBQSxDQUFpQyxNQUFBLElBQUEsbUJBQUEsQ0FBOEIsQ0FBQyw2Q0FBQSxDQUFnQixxQkFBQSxHQUF3QixDQUFDLFdBQUEsSUFBZSxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxvQkFBQSxHQUF1QixDQUFDLGlEQUFBLENBQW9CLHNCQUFBLElBQTBCLENBQUMscUJBQUEsSUFBeUIsQ0FBQyxrQkFBQSxzQkFBQSxDQUFBLElBQUEsNkJBQUEsQ0FBQSxDQUFBLElBQUEscUNBQUEsQ0FBQSxDQUFBLHdCQUFBLENBQUEsSUFBQSw2QkFBQSxDQUFBLENBQUEsSUFBQSxxQ0FBQSxDQUFBLENBQUEsSUFBQSw2QkFBQSxDQUFrTyxDQUFDLFVBQUEsc0JBQUEsQ0FBQSxJQUFBLDZCQUFBLENBQUEsQ0FBQSxJQUFBLHFDQUFBLENBQUEsQ0FBQSx3QkFBQSxDQUFBLElBQUEsNkJBQUEsQ0FBQSxDQUFBLElBQUEscUNBQUEsQ0FBQSxDQUFBLElBQUEsNkJBQUEsQ0FBME4sQ0FBQyxnQkFBQSxXQUEyQixDQUFDLGlCQUFBLElBQUEsa0NBQUEsQ0FBd0QsQ0FBQyxPQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSwyQkFBQSxDQUFpRCxDQUFDLGNBQUEsSUFBQSwyQkFBQSxDQUE4QyxDQUFDLFdBQUEsSUFBQSxtQkFBQSxDQUFtQyxDQUFDLFdBQUEsVUFBcUIsQ0FBQyxZQUFBLEtBQUEsSUFBQSxDQUFBLENBQUEsQ0FBQSxHQUFBLENBQTRCLENBQUMsa0JBQUEsSUFBQSxpQkFBQSxDQUFBLENBQUEsQ0FBMEMsQ0FBQyxtQkFBQSxDQUFvQixDQUFDLE9BQUEsQ0FBUSxDQUFDLG1CQUFBLElBQXVCLENBQUMsb0JBQUEsSUFBd0IsQ0FBQyxlQUFBLEtBQW9CLENBQUMsU0FBQSxJQUFhLENBQUMsUUFBQSxHQUFXLENBQUMsU0FBQSxRQUFpQixDQUFDLFFBQUEsR0FBVyxDQUFDLFVBQUEsQ0FBQSxTQUFBLE9BQUEsQ0FBQSxDQUE2QixpREFBQSxDQUFvQixTQUFBLE9BQWdCLENBQUMsQ0FBQyxtQkFBQSw0Q0FBQSxDQUFrQyxxQkFBQSxrQ0FBdUQsQ0FBQyxtQkFBQSwrQ0FBQSxDQUFxQyxxQkFBQSxzQ0FBMkQsQ0FBQyxtQkFBQSwrQ0FBQSxDQUFxQyxxQkFBQSx3Q0FBNkQsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDb21ib0JveC5zdmVsdGUiXX0= */');
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[52] = list[i];
  child_ctx[54] = i;
  return child_ctx;
}
function create_else_block3(ctx) {
  let button;
  let updating_element;
  let current;
  function button_element_binding(value) {
    ctx[38](value);
  }
  let button_props = {
    type: "button",
    class: "combo-box-button",
    id: (
      /*buttonId*/
      ctx[18]
    ),
    "aria-labelledby": (
      /*buttonId*/
      ctx[18]
    ),
    "aria-haspopup": (
      /*open*/
      ctx[1] ? "listbox" : void 0
    ),
    "aria-controls": (
      /*dropdownId*/
      ctx[19]
    ),
    disabled: (
      /*disabled*/
      ctx[11]
    ),
    $$slots: { default: [create_default_slot_22] },
    $$scope: { ctx }
  };
  if (
    /*buttonElement*/
    ctx[7] !== void 0
  ) {
    button_props.element = /*buttonElement*/
    ctx[7];
  }
  button = new Button_default({ props: button_props, $$inline: true });
  binding_callbacks.push(() => bind(button, "element", button_element_binding));
  button.$on(
    "keydown",
    /*handleKeyboardNavigation*/
    ctx[22]
  );
  button.$on(
    "keydown",
    /*keydown_handler_1*/
    ctx[39]
  );
  button.$on(
    "click",
    /*openMenu*/
    ctx[21]
  );
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const button_changes = {};
      if (dirty[0] & /*open*/
      2)
        button_changes["aria-haspopup"] = /*open*/
        ctx2[1] ? "listbox" : void 0;
      if (dirty[0] & /*disabled*/
      2048)
        button_changes.disabled = /*disabled*/
        ctx2[11];
      if (dirty[0] & /*selection, placeholder*/
      8448 | dirty[1] & /*$$scope*/
      65536) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_element && dirty[0] & /*buttonElement*/
      128) {
        updating_element = true;
        button_changes.element = /*buttonElement*/
        ctx2[7];
        add_flush_callback(() => updating_element = false);
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(249:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let textbox;
  let updating_value;
  let updating_inputElement;
  let current;
  function textbox_value_binding(value) {
    ctx[32](value);
  }
  function textbox_inputElement_binding(value) {
    ctx[33](value);
  }
  let textbox_props = {
    clearButton: false,
    class: "combo-box-text-box",
    role: "combobox",
    "aria-activedescendant": (
      /*inputFocused*/
      ctx[14]
    ),
    "aria-autocomplete": "both",
    "aria-controls": (
      /*dropdownId*/
      ctx[19]
    ),
    "aria-expanded": (
      /*open*/
      ctx[1]
    ),
    "aria-haspopup": (
      /*open*/
      ctx[1] ? "listbox" : void 0
    ),
    placeholder: (
      /*placeholder*/
      ctx[8]
    ),
    disabled: (
      /*disabled*/
      ctx[11]
    ),
    $$slots: { buttons: [create_buttons_slot] },
    $$scope: { ctx }
  };
  if (
    /*searchValue*/
    ctx[3] !== void 0
  ) {
    textbox_props.value = /*searchValue*/
    ctx[3];
  }
  if (
    /*searchInputElement*/
    ctx[5] !== void 0
  ) {
    textbox_props.inputElement = /*searchInputElement*/
    ctx[5];
  }
  textbox = new TextBox_default({ props: textbox_props, $$inline: true });
  binding_callbacks.push(() => bind(textbox, "value", textbox_value_binding));
  binding_callbacks.push(() => bind(textbox, "inputElement", textbox_inputElement_binding));
  textbox.$on(
    "keydown",
    /*handleKeyboardNavigation*/
    ctx[22]
  );
  textbox.$on(
    "input",
    /*handleInput*/
    ctx[25]
  );
  textbox.$on(
    "focus",
    /*handleInputFocus*/
    ctx[23]
  );
  textbox.$on(
    "blur",
    /*handleInputBlur*/
    ctx[24]
  );
  textbox.$on(
    "change",
    /*change_handler*/
    ctx[34]
  );
  textbox.$on(
    "input",
    /*input_handler*/
    ctx[35]
  );
  textbox.$on(
    "beforeinput",
    /*beforeinput_handler*/
    ctx[36]
  );
  textbox.$on(
    "keydown",
    /*keydown_handler*/
    ctx[37]
  );
  const block = {
    c: function create() {
      create_component(textbox.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(textbox.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(textbox, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const textbox_changes = {};
      if (dirty[0] & /*inputFocused*/
      16384)
        textbox_changes["aria-activedescendant"] = /*inputFocused*/
        ctx2[14];
      if (dirty[0] & /*open*/
      2)
        textbox_changes["aria-expanded"] = /*open*/
        ctx2[1];
      if (dirty[0] & /*open*/
      2)
        textbox_changes["aria-haspopup"] = /*open*/
        ctx2[1] ? "listbox" : void 0;
      if (dirty[0] & /*placeholder*/
      256)
        textbox_changes.placeholder = /*placeholder*/
        ctx2[8];
      if (dirty[0] & /*disabled*/
      2048)
        textbox_changes.disabled = /*disabled*/
        ctx2[11];
      if (dirty[0] & /*open, buttonElement*/
      130 | dirty[1] & /*$$scope*/
      65536) {
        textbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_value && dirty[0] & /*searchValue*/
      8) {
        updating_value = true;
        textbox_changes.value = /*searchValue*/
        ctx2[3];
        add_flush_callback(() => updating_value = false);
      }
      if (!updating_inputElement && dirty[0] & /*searchInputElement*/
      32) {
        updating_inputElement = true;
        textbox_changes.inputElement = /*searchInputElement*/
        ctx2[5];
        add_flush_callback(() => updating_inputElement = false);
      }
      textbox.$set(textbox_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(textbox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(textbox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(textbox, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(202:1) {#if editable}",
    ctx
  });
  return block;
}
function create_default_slot_22(ctx) {
  var _a;
  let span;
  let t0_value = (
    /*selection*/
    (((_a = ctx[13]) == null ? void 0 : _a.name) || /*placeholder*/
    ctx[8]) + ""
  );
  let t0;
  let t1;
  let svg;
  let path;
  const block = {
    c: function create() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, t0_value);
      span_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      svg = claim_svg_element(nodes, "svg", {
        "aria-hidden": true,
        class: true,
        xmlns: true,
        width: true,
        height: true,
        viewBox: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "combo-box-label svelte-12fytfi");
      toggle_class(span, "placeholder", !/*selection*/
      ctx[13]);
      add_location(span, file14, 262, 3, 9699);
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M8.36612 16.1161C7.87796 16.6043 7.87796 17.3957 8.36612 17.8839L23.1161 32.6339C23.6043 33.122 24.3957 33.122 24.8839 32.6339L39.6339 17.8839C40.122 17.3957 40.122 16.6043 39.6339 16.1161C39.1457 15.628 38.3543 15.628 37.8661 16.1161L24 29.9822L10.1339 16.1161C9.64573 15.628 8.85427 15.628 8.36612 16.1161Z");
      add_location(path, file14, 273, 4, 9970);
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "class", "combo-box-icon svelte-12fytfi");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "48");
      attr_dev(svg, "height", "48");
      attr_dev(svg, "viewBox", "0 0 48 48");
      add_location(svg, file14, 265, 3, 9812);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, dirty) {
      var _a2;
      if (dirty[0] & /*selection, placeholder*/
      8448 && t0_value !== (t0_value = /*selection*/
      (((_a2 = ctx2[13]) == null ? void 0 : _a2.name) || /*placeholder*/
      ctx2[8]) + ""))
        set_data_dev(t0, t0_value);
      if (dirty[0] & /*selection*/
      8192) {
        toggle_class(span, "placeholder", !/*selection*/
        ctx2[13]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_22.name,
    type: "slot",
    source: '(250:2) <Button    type=\\"button\\"    class=\\"combo-box-button\\"    id={buttonId}    aria-labelledby={buttonId}    aria-haspopup={open ? \\"listbox\\" : undefined}    aria-controls={dropdownId}    on:keydown={handleKeyboardNavigation}    on:keydown    on:click={openMenu}    bind:element={buttonElement}    {disabled}   >',
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        "aria-hidden": true,
        class: true,
        xmlns: true,
        width: true,
        height: true,
        viewBox: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M8.36612 16.1161C7.87796 16.6043 7.87796 17.3957 8.36612 17.8839L23.1161 32.6339C23.6043 33.122 24.3957 33.122 24.8839 32.6339L39.6339 17.8839C40.122 17.3957 40.122 16.6043 39.6339 16.1161C39.1457 15.628 38.3543 15.628 37.8661 16.1161L24 29.9822L10.1339 16.1161C9.64573 15.628 8.85427 15.628 8.36612 16.1161Z");
      add_location(path, file14, 241, 5, 8976);
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "class", "combo-box-icon svelte-12fytfi");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "48");
      attr_dev(svg, "height", "48");
      attr_dev(svg, "viewBox", "0 0 48 48");
      add_location(svg, file14, 233, 4, 8810);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: '(225:3) <TextBoxButton     aria-expanded={open}     aria-label=\\"Open dropdown\\"     aria-controls={dropdownId}     class=\\"combo-box-dropdown-button\\"     on:click={openMenu}     bind:element={buttonElement}     slot=\\"buttons\\"    >',
    ctx
  });
  return block;
}
function create_buttons_slot(ctx) {
  let textboxbutton;
  let updating_element;
  let current;
  function textboxbutton_element_binding(value) {
    ctx[31](value);
  }
  let textboxbutton_props = {
    "aria-expanded": (
      /*open*/
      ctx[1]
    ),
    "aria-label": "Open dropdown",
    "aria-controls": (
      /*dropdownId*/
      ctx[19]
    ),
    class: "combo-box-dropdown-button",
    slot: "buttons",
    $$slots: { default: [create_default_slot_12] },
    $$scope: { ctx }
  };
  if (
    /*buttonElement*/
    ctx[7] !== void 0
  ) {
    textboxbutton_props.element = /*buttonElement*/
    ctx[7];
  }
  textboxbutton = new TextBoxButton_default({
    props: textboxbutton_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(textboxbutton, "element", textboxbutton_element_binding));
  textboxbutton.$on(
    "click",
    /*openMenu*/
    ctx[21]
  );
  const block = {
    c: function create() {
      create_component(textboxbutton.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(textboxbutton.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(textboxbutton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const textboxbutton_changes = {};
      if (dirty[0] & /*open*/
      2)
        textboxbutton_changes["aria-expanded"] = /*open*/
        ctx2[1];
      if (dirty[1] & /*$$scope*/
      65536) {
        textboxbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_element && dirty[0] & /*buttonElement*/
      128) {
        updating_element = true;
        textboxbutton_changes.element = /*buttonElement*/
        ctx2[7];
        add_flush_callback(() => updating_element = false);
      }
      textboxbutton.$set(textboxbutton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(textboxbutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(textboxbutton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(textboxbutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_buttons_slot.name,
    type: "slot",
    source: "(225:3) ",
    ctx
  });
  return block;
}
function create_if_block7(ctx) {
  let t0;
  let input;
  let t1;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*open*/
    ctx[1] && create_if_block_17(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[27].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[47],
    null
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t0 = space();
      input = element("input");
      t1 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t0 = claim_space(nodes);
      input = claim_element(nodes, "INPUT", { type: true, "aria-hidden": true });
      t1 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "hidden");
      attr_dev(input, "aria-hidden", "true");
      add_location(input, file14, 311, 2, 11142);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, input, anchor);
      ctx[43](input);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      insert_hydration_dev(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[44]
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_1*/
            ctx[28],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_1*/
            ctx[29],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "beforeinput",
            /*beforeinput_handler_1*/
            ctx[30],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*open*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*open*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_17(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty[0] & /*value*/
      1) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[47],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[47]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[47],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(input);
      ctx[43](null);
      if (detaching)
        detach_dev(t1);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(281:1) {#if !disabled && items.length > 0}",
    ctx
  });
  return block;
}
function create_if_block_17(ctx) {
  let ul;
  let ul_aria_activedescendant_value;
  let ul_class_value;
  let current;
  let mounted;
  let dispose;
  let each_value = (
    /*items*/
    ctx[9]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", {
        id: true,
        "aria-labelledby": true,
        "aria-activedescendant": true,
        role: true,
        class: true,
        style: true
      });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        ul,
        "id",
        /*dropdownId*/
        ctx[19]
      );
      attr_dev(
        ul,
        "aria-labelledby",
        /*buttonId*/
        ctx[18]
      );
      attr_dev(ul, "aria-activedescendant", ul_aria_activedescendant_value = /*editable*/
      ctx[10] ? void 0 : `${/*dropdownId*/
      ctx[19]}-item-${/*items*/
      ctx[9].indexOf(
        /*selection*/
        ctx[13]
      )}`);
      attr_dev(ul, "role", "listbox");
      attr_dev(ul, "class", ul_class_value = "combo-box-dropdown direction-" + (!/*editable*/
      ctx[10] ? (
        /*menuGrowDirection*/
        ctx[16] ?? "center"
      ) : "top") + " svelte-12fytfi");
      set_style(
        ul,
        "--fds-menu-offset",
        /*menuOffset*/
        ctx[15] + "px"
      );
      add_location(ul, file14, 282, 3, 10408);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
      ctx[41](ul);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          ul,
          "blur",
          /*blur_handler*/
          ctx[42],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*items, value, dropdownId, handleKeyboardNavigation, selectItem*/
      5767681) {
        each_value = /*items*/
        ctx2[9];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(ul, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty[0] & /*editable, items, selection*/
      9728 && ul_aria_activedescendant_value !== (ul_aria_activedescendant_value = /*editable*/
      ctx2[10] ? void 0 : `${/*dropdownId*/
      ctx2[19]}-item-${/*items*/
      ctx2[9].indexOf(
        /*selection*/
        ctx2[13]
      )}`)) {
        attr_dev(ul, "aria-activedescendant", ul_aria_activedescendant_value);
      }
      if (!current || dirty[0] & /*editable, menuGrowDirection*/
      66560 && ul_class_value !== (ul_class_value = "combo-box-dropdown direction-" + (!/*editable*/
      ctx2[10] ? (
        /*menuGrowDirection*/
        ctx2[16] ?? "center"
      ) : "top") + " svelte-12fytfi")) {
        attr_dev(ul, "class", ul_class_value);
      }
      if (!current || dirty[0] & /*menuOffset*/
      32768) {
        set_style(
          ul,
          "--fds-menu-offset",
          /*menuOffset*/
          ctx2[15] + "px"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      destroy_each(each_blocks, detaching);
      ctx[41](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_17.name,
    type: "if",
    source: "(282:2) {#if open}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let t0_value = (
    /*item*/
    ctx[52].name + ""
  );
  let t0;
  let t1;
  const block = {
    c: function create() {
      t0 = text(t0_value);
      t1 = space();
    },
    l: function claim(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*items*/
      512 && t0_value !== (t0_value = /*item*/
      ctx2[52].name + ""))
        set_data_dev(t0, t0_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: '(298:5) <ComboBoxItem       role=\\"option\\"       selected={item.value === value}       disabled={item.disabled}       id=\\"{dropdownId}-item-{i}\\"       on:keydown={handleKeyboardNavigation}       on:click={() => selectItem(item)}      >',
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let comboboxitem;
  let current;
  function click_handler3() {
    return (
      /*click_handler*/
      ctx[40](
        /*item*/
        ctx[52]
      )
    );
  }
  comboboxitem = new ComboBoxItem_default({
    props: {
      role: "option",
      selected: (
        /*item*/
        ctx[52].value === /*value*/
        ctx[0]
      ),
      disabled: (
        /*item*/
        ctx[52].disabled
      ),
      id: (
        /*dropdownId*/
        ctx[19] + "-item-" + /*i*/
        ctx[54]
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  comboboxitem.$on(
    "keydown",
    /*handleKeyboardNavigation*/
    ctx[22]
  );
  comboboxitem.$on("click", click_handler3);
  const block = {
    c: function create() {
      create_component(comboboxitem.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(comboboxitem.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(comboboxitem, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const comboboxitem_changes = {};
      if (dirty[0] & /*items, value*/
      513)
        comboboxitem_changes.selected = /*item*/
        ctx[52].value === /*value*/
        ctx[0];
      if (dirty[0] & /*items*/
      512)
        comboboxitem_changes.disabled = /*item*/
        ctx[52].disabled;
      if (dirty[0] & /*items*/
      512 | dirty[1] & /*$$scope*/
      65536) {
        comboboxitem_changes.$$scope = { dirty, ctx };
      }
      comboboxitem.$set(comboboxitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(comboboxitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(comboboxitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(comboboxitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(297:4) {#each items as item, i}",
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t;
  let div_class_value;
  let forwardEvents_action;
  let externalMouseEvents_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_22, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*editable*/
      ctx2[10]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = !/*disabled*/
  ctx[11] && /*items*/
  ctx[9].length > 0 && create_if_block7(ctx);
  let div_levels = [
    {
      class: div_class_value = "combo-box " + /*className*/
      ctx[12]
    },
    /*$$restProps*/
    ctx[26]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if_block0.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(
        div,
        "disabled",
        /*disabled*/
        ctx[11]
      );
      toggle_class(
        div,
        "editable",
        /*editable*/
        ctx[10]
      );
      toggle_class(
        div,
        "open",
        /*open*/
        ctx[1]
      );
      toggle_class(div, "svelte-12fytfi", true);
      add_location(div, file14, 188, 0, 7768);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append_hydration_dev(div, t);
      if (if_block1)
        if_block1.m(div, null);
      ctx[46](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[17].call(null, div)),
          action_destroyer(externalMouseEvents_action = externalMouseEvents.call(null, div, { type: "mousedown" })),
          listen_dev(
            div,
            "outermousedown",
            /*outermousedown_handler*/
            ctx[45],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t);
      }
      if (!/*disabled*/
      ctx2[11] && /*items*/
      ctx2[9].length > 0) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*disabled, items*/
          2560) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block7(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*className*/
        4096 && div_class_value !== (div_class_value = "combo-box " + /*className*/
        ctx2[12])) && { class: div_class_value },
        dirty[0] & /*$$restProps*/
        67108864 && /*$$restProps*/
        ctx2[26]
      ]));
      toggle_class(
        div,
        "disabled",
        /*disabled*/
        ctx2[11]
      );
      toggle_class(
        div,
        "editable",
        /*editable*/
        ctx2[10]
      );
      toggle_class(
        div,
        "open",
        /*open*/
        ctx2[1]
      );
      toggle_class(div, "svelte-12fytfi", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      ctx[46](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var maxItems = 14;
function instance14($$self, $$props, $$invalidate) {
  let selectableItems;
  let selection;
  let menuGrowDirection;
  const omit_props_names = [
    "value",
    "searchValue",
    "placeholder",
    "items",
    "editable",
    "disabled",
    "open",
    "class",
    "inputElement",
    "searchInputElement",
    "containerElement",
    "menuElement",
    "buttonElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ComboBox", slots, ["default"]);
  let { value = void 0 } = $$props;
  let { searchValue = void 0 } = $$props;
  let { placeholder = "" } = $$props;
  let { items = [] } = $$props;
  let { editable = false } = $$props;
  let { disabled = false } = $$props;
  let { open = false } = $$props;
  let { class: className = "" } = $$props;
  let { inputElement = null } = $$props;
  let { searchInputElement = null } = $$props;
  let { containerElement = null } = $$props;
  let { menuElement = null } = $$props;
  let { buttonElement = null } = $$props;
  const forwardEvents = createEventForwarder(get_current_component(), ["open", "close", "select", "change", "input", "beforeinput", "keydown"]);
  const dispatch = createEventDispatcher();
  const buttonId = uid("fds-combo-box-button-");
  const dropdownId = uid("fds-combo-box-dropdown-");
  let inputFocused = false;
  let itemHeight = 36;
  let menuOffset = itemHeight * -(selection ? items.indexOf(selection) : Math.floor(items.length > maxItems ? maxItems / 2 : items.length / 2));
  onMount(() => {
    if (!searchValue)
      $$invalidate(3, searchValue = value);
  });
  function updateOffset(target) {
    const { top: containerTop } = containerElement.getBoundingClientRect();
    const { top: targetTop } = target.getBoundingClientRect();
    $$invalidate(15, menuOffset += containerTop - targetTop);
  }
  function selectItem(item) {
    if (item.disabled)
      return;
    $$invalidate(0, value = item.value);
    $$invalidate(3, searchValue = item.name);
    $$invalidate(1, open = false);
    if (containerElement && !editable)
      containerElement.children[0].focus();
  }
  async function openMenu() {
    $$invalidate(1, open = !open);
    await tick();
    if (editable && searchInputElement)
      searchInputElement.focus();
    if (menuElement && selection)
      updateOffset(menuElement.children[items.indexOf(selection)]);
  }
  async function handleKeyboardNavigation(event2) {
    const { key } = event2;
    event2.stopPropagation();
    const editableClosed = editable && !open;
    if (key === "Tab" || key === "Esc" || key === "Escape")
      $$invalidate(1, open = false);
    if (key === "ArrowDown" && !editableClosed && !(items.indexOf(selection) >= items.length - 1)) {
      $$invalidate(0, value = selectableItems[selectableItems.indexOf(selection) + 1].value);
      $$invalidate(3, searchValue = selectableItems[selectableItems.indexOf(selection) + 1].name);
    } else if (key === "ArrowUp" && !editableClosed && !(items.indexOf(selection) <= 0)) {
      $$invalidate(0, value = selectableItems[selectableItems.indexOf(selection) - 1].value);
      $$invalidate(3, searchValue = selectableItems[selectableItems.indexOf(selection) - 1].name);
    } else if (key === "Home") {
      $$invalidate(0, value = selectableItems[0].value);
      $$invalidate(3, searchValue = selectableItems[0].name);
    } else if (key === "End") {
      $$invalidate(0, value = selectableItems[selectableItems.length - 1].value);
      $$invalidate(3, searchValue = selectableItems[selectableItems.length - 1].name);
    } else if (open && (key === "Enter" || key === " ")) {
      event2.preventDefault();
      selectItem(selection);
    } else if (searchInputElement && document.activeElement !== searchInputElement) {
      searchInputElement.focus();
    }
    if (key === "ArrowDown" || key === "ArrowUp" || key === "Home" || key === "End")
      event2.preventDefault();
    if (key === "ArrowDown" || key === "ArrowUp" && editable) {
      if (open) {
        await tick();
        searchInputElement === null || searchInputElement === void 0 ? void 0 : searchInputElement.select();
      } else {
        $$invalidate(1, open = true);
      }
    }
  }
  function handleInputFocus() {
    searchInputElement.select();
    $$invalidate(14, inputFocused = true);
  }
  function handleInputBlur() {
    $$invalidate(14, inputFocused = false);
  }
  function handleInput(event2) {
    const match = selectableItems.find((i) => i.name.toLowerCase().startsWith(searchValue.toLowerCase()));
    if (!match)
      $$invalidate(0, value = null);
    if (match && event2.inputType === "insertText" && searchValue.trim() !== "") {
      $$invalidate(5, searchInputElement.value = match.name, searchInputElement);
      searchInputElement.setSelectionRange(searchValue.length, match.name.length);
    }
    if (match && !match.disabled)
      $$invalidate(0, value = match.value);
    $$invalidate(3, searchValue = searchInputElement.value);
  }
  function change_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function beforeinput_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function textboxbutton_element_binding(value2) {
    buttonElement = value2;
    $$invalidate(7, buttonElement);
  }
  function textbox_value_binding(value2) {
    searchValue = value2;
    $$invalidate(3, searchValue);
  }
  function textbox_inputElement_binding(value2) {
    searchInputElement = value2;
    $$invalidate(5, searchInputElement);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function beforeinput_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function button_element_binding(value2) {
    buttonElement = value2;
    $$invalidate(7, buttonElement);
  }
  function keydown_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler3 = (item) => selectItem(item);
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      menuElement = $$value;
      $$invalidate(2, menuElement);
    });
  }
  const blur_handler = () => $$invalidate(1, open = false);
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(4, inputElement);
    });
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  const outermousedown_handler = () => {
    if (open)
      $$invalidate(1, open = false);
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      containerElement = $$value;
      $$invalidate(6, containerElement);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(26, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("searchValue" in $$new_props)
      $$invalidate(3, searchValue = $$new_props.searchValue);
    if ("placeholder" in $$new_props)
      $$invalidate(8, placeholder = $$new_props.placeholder);
    if ("items" in $$new_props)
      $$invalidate(9, items = $$new_props.items);
    if ("editable" in $$new_props)
      $$invalidate(10, editable = $$new_props.editable);
    if ("disabled" in $$new_props)
      $$invalidate(11, disabled = $$new_props.disabled);
    if ("open" in $$new_props)
      $$invalidate(1, open = $$new_props.open);
    if ("class" in $$new_props)
      $$invalidate(12, className = $$new_props.class);
    if ("inputElement" in $$new_props)
      $$invalidate(4, inputElement = $$new_props.inputElement);
    if ("searchInputElement" in $$new_props)
      $$invalidate(5, searchInputElement = $$new_props.searchInputElement);
    if ("containerElement" in $$new_props)
      $$invalidate(6, containerElement = $$new_props.containerElement);
    if ("menuElement" in $$new_props)
      $$invalidate(2, menuElement = $$new_props.menuElement);
    if ("buttonElement" in $$new_props)
      $$invalidate(7, buttonElement = $$new_props.buttonElement);
    if ("$$scope" in $$new_props)
      $$invalidate(47, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    tick,
    get_current_component,
    onMount,
    createEventForwarder,
    externalMouseEvents,
    uid,
    ComboBoxItem: ComboBoxItem_default,
    Button: Button_default,
    TextBox: TextBox_default,
    TextBoxButton: TextBoxButton_default,
    value,
    searchValue,
    placeholder,
    items,
    editable,
    disabled,
    open,
    className,
    inputElement,
    searchInputElement,
    containerElement,
    menuElement,
    buttonElement,
    forwardEvents,
    dispatch,
    buttonId,
    dropdownId,
    inputFocused,
    itemHeight,
    maxItems,
    menuOffset,
    updateOffset,
    selectItem,
    openMenu,
    handleKeyboardNavigation,
    handleInputFocus,
    handleInputBlur,
    handleInput,
    selectableItems,
    selection,
    menuGrowDirection
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("searchValue" in $$props)
      $$invalidate(3, searchValue = $$new_props.searchValue);
    if ("placeholder" in $$props)
      $$invalidate(8, placeholder = $$new_props.placeholder);
    if ("items" in $$props)
      $$invalidate(9, items = $$new_props.items);
    if ("editable" in $$props)
      $$invalidate(10, editable = $$new_props.editable);
    if ("disabled" in $$props)
      $$invalidate(11, disabled = $$new_props.disabled);
    if ("open" in $$props)
      $$invalidate(1, open = $$new_props.open);
    if ("className" in $$props)
      $$invalidate(12, className = $$new_props.className);
    if ("inputElement" in $$props)
      $$invalidate(4, inputElement = $$new_props.inputElement);
    if ("searchInputElement" in $$props)
      $$invalidate(5, searchInputElement = $$new_props.searchInputElement);
    if ("containerElement" in $$props)
      $$invalidate(6, containerElement = $$new_props.containerElement);
    if ("menuElement" in $$props)
      $$invalidate(2, menuElement = $$new_props.menuElement);
    if ("buttonElement" in $$props)
      $$invalidate(7, buttonElement = $$new_props.buttonElement);
    if ("inputFocused" in $$props)
      $$invalidate(14, inputFocused = $$new_props.inputFocused);
    if ("itemHeight" in $$props)
      itemHeight = $$new_props.itemHeight;
    if ("menuOffset" in $$props)
      $$invalidate(15, menuOffset = $$new_props.menuOffset);
    if ("selectableItems" in $$props)
      selectableItems = $$new_props.selectableItems;
    if ("selection" in $$props)
      $$invalidate(13, selection = $$new_props.selection);
    if ("menuGrowDirection" in $$props)
      $$invalidate(16, menuGrowDirection = $$new_props.menuGrowDirection);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*items*/
    512) {
      $:
        selectableItems = items.filter((item) => !item.disabled);
    }
    if ($$self.$$.dirty[0] & /*items, value*/
    513) {
      $:
        $$invalidate(13, selection = items.find((i) => i.value === value));
    }
    if ($$self.$$.dirty[0] & /*menuElement, editable, selection, items*/
    9732) {
      $:
        if (menuElement && menuElement.children.length > 0 && !editable) {
          if (selection) {
            menuElement.children[items.indexOf(selection)].focus();
          } else {
            menuElement.children[0].focus();
          }
        }
    }
    if ($$self.$$.dirty[0] & /*items, open*/
    514) {
      $:
        if (items.length > 0) {
          if (open) {
            dispatch("open");
          } else {
            dispatch("close");
          }
        }
    }
    if ($$self.$$.dirty[0] & /*selection*/
    8192) {
      $:
        dispatch("select", selection);
    }
    if ($$self.$$.dirty[0] & /*selection, items*/
    8704) {
      $:
        $$invalidate(16, menuGrowDirection = !selection || items[items.indexOf(selection)] === items[Math.floor(items.length / 2)] ? "center" : items.indexOf(selection) < items.indexOf(items[Math.floor(items.length / 2)]) ? "top" : "bottom");
    }
  };
  return [
    value,
    open,
    menuElement,
    searchValue,
    inputElement,
    searchInputElement,
    containerElement,
    buttonElement,
    placeholder,
    items,
    editable,
    disabled,
    className,
    selection,
    inputFocused,
    menuOffset,
    menuGrowDirection,
    forwardEvents,
    buttonId,
    dropdownId,
    selectItem,
    openMenu,
    handleKeyboardNavigation,
    handleInputFocus,
    handleInputBlur,
    handleInput,
    $$restProps,
    slots,
    change_handler_1,
    input_handler_1,
    beforeinput_handler_1,
    textboxbutton_element_binding,
    textbox_value_binding,
    textbox_inputElement_binding,
    change_handler,
    input_handler,
    beforeinput_handler,
    keydown_handler,
    button_element_binding,
    keydown_handler_1,
    click_handler3,
    ul_binding,
    blur_handler,
    input_binding,
    input_input_handler,
    outermousedown_handler,
    div_binding,
    $$scope
  ];
}
var ComboBox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance14,
      create_fragment14,
      safe_not_equal,
      {
        value: 0,
        searchValue: 3,
        placeholder: 8,
        items: 9,
        editable: 10,
        disabled: 11,
        open: 1,
        class: 12,
        inputElement: 4,
        searchInputElement: 5,
        containerElement: 6,
        menuElement: 2,
        buttonElement: 7
      },
      add_css14,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ComboBox",
      options,
      id: create_fragment14.name
    });
  }
  get value() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searchValue() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searchValue(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get editable() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set editable(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searchInputElement() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searchInputElement(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerElement() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerElement(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get menuElement() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set menuElement(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonElement() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonElement(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ComboBox_default = ComboBox;

// node_modules/fluent-svelte/InfoBadge/InfoBadge.svelte
var file15 = "node_modules\\fluent-svelte\\InfoBadge\\InfoBadge.svelte";
function add_css15(target) {
  append_styles(target, "svelte-1kvqfof", ".info-badge.svelte-1kvqfof{align-items:center;border-radius:16px;box-sizing:border-box;color:var(--fds-text-on-accent-primary);display:inline-flex;font-family:var(--fds-font-family-small);font-size:var(--fds-caption-font-size);justify-content:center;line-height:var(--fds-caption-font-size);min-block-size:16px;min-inline-size:16px;padding:2px 4px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.info-badge.severity-attention.svelte-1kvqfof{background-color:var(--fds-system-attention)}.info-badge.severity-success.svelte-1kvqfof{background-color:var(--fds-system-success)}.info-badge.severity-caution.svelte-1kvqfof{background-color:var(--fds-system-caution)}.info-badge.severity-critical.svelte-1kvqfof{background-color:var(--fds-system-critical)}.info-badge.severity-information.svelte-1kvqfof{background-color:var(--fds-system-solid-neutral)}.info-badge.svelte-1kvqfof svg{fill:currentColor;block-size:8px;inline-size:8px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5mb0JhZGdlLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUF3RVEsMEJBQUEsQ0FBWSxZQUFBLE1BQWtCLENBQUMsY0FBQSxJQUFrQixDQUFDLFdBQUEsVUFBcUIsQ0FBQyxNQUFBLElBQUEsNEJBQUEsQ0FBdUMsQ0FBQyxRQUFBLFdBQW1CLENBQUMsWUFBQSxJQUFBLHVCQUFBLENBQXdDLENBQUMsVUFBQSxJQUFBLHVCQUFBLENBQXNDLENBQUMsZ0JBQUEsTUFBc0IsQ0FBQyxZQUFBLElBQUEsdUJBQUEsQ0FBd0MsQ0FBQyxlQUFBLElBQW1CLENBQUMsZ0JBQUEsSUFBb0IsQ0FBQyxRQUFBLEdBQUEsQ0FBQSxHQUFlLENBQUMsb0JBQUEsSUFBd0IsQ0FBQyxpQkFBQSxJQUFxQixDQUFDLGdCQUFBLElBQW9CLENBQUMsWUFBQSxJQUFnQixDQUFDLFdBQUEsa0NBQUEsQ0FBK0IsaUJBQUEsSUFBQSxzQkFBQSxDQUE0QyxDQUFDLFdBQUEsZ0NBQUEsQ0FBNkIsaUJBQUEsSUFBQSxvQkFBQSxDQUEwQyxDQUFDLFdBQUEsZ0NBQUEsQ0FBNkIsaUJBQUEsSUFBQSxvQkFBQSxDQUEwQyxDQUFDLFdBQUEsaUNBQUEsQ0FBOEIsaUJBQUEsSUFBQSxxQkFBQSxDQUEyQyxDQUFDLFdBQUEsb0NBQUEsQ0FBaUMsaUJBQUEsSUFBQSwwQkFBQSxDQUFnRCxDQUFDLDBCQUFBLENBQUEsQUFBQSxHQUFBLEFBQUEsQ0FBeUIsS0FBQSxZQUFpQixDQUFDLFdBQUEsR0FBYyxDQUFDLFlBQUEsR0FBZSxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkluZm9CYWRnZS5zdmVsdGUiXX0= */");
}
function create_if_block_42(ctx) {
  let svg;
  let path;
  let svg_levels = [
    /*svgProps*/
    ctx[4],
    { viewBox: "406 64 213 875" }
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M405.5,170.5C405.5,156.167 408.333,142.5 414,129.5C419.667,116.5 427.333,105.167 437,95.5C446.667,85.8334 457.917,78.1667 470.75,72.5C483.583,66.8334 497.333,64.0001 512,64C526.333,64.0001 540,66.8334 553,72.5C566,78.1667 577.333,85.8334 587,95.5C596.667,105.167 604.333,116.5 610,129.5C615.667,142.5 618.5,156.167 618.5,170.5C618.5,185.167 615.667,199 610,212C604.333,225 596.667,236.333 587,246C577.333,255.667 566.083,263.333 553.25,269C540.417,274.667 526.667,277.5 512,277.5C497.333,277.5 483.583,274.667 470.75,269C457.917,263.333 446.667,255.667 437,246C427.333,236.333 419.667,225 414,212C408.333,199 405.5,185.167 405.5,170.5ZM426.5,853.5L426.5,512C426.5,500.333 428.75,489.333 433.25,479C437.75,468.667 443.917,459.583 451.75,451.75C459.583,443.917 468.667,437.75 479,433.25C489.333,428.75 500.333,426.5 512,426.5C523.667,426.5 534.667,428.75 545,433.25C555.333,437.75 564.417,443.917 572.25,451.75C580.083,459.583 586.25,468.667 590.75,479C595.25,489.333 597.5,500.333 597.5,512L597.5,853.5C597.5,865.167 595.25,876.167 590.75,886.5C586.25,896.833 580.083,905.833 572.25,913.5C564.417,921.167 555.333,927.25 545,931.75C534.667,936.25 523.667,938.5 512,938.5C500.333,938.5 489.333,936.25 479,931.75C468.667,927.25 459.583,921.167 451.75,913.5C443.917,905.833 437.75,896.833 433.25,886.5C428.75,876.167 426.5,865.167 426.5,853.5Z");
      add_location(path, file15, 63, 4, 6710);
      set_svg_attributes(svg, svg_data);
      toggle_class(svg, "svelte-1kvqfof", true);
      add_location(svg, file15, 62, 3, 6661);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, dirty) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        /*svgProps*/
        ctx2[4],
        { viewBox: "406 64 213 875" }
      ]));
      toggle_class(svg, "svelte-1kvqfof", true);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_42.name,
    type: "if",
    source: "(62:39) ",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let svg;
  let path;
  let svg_levels = [
    /*svgProps*/
    ctx[4],
    { viewBox: "172 171 683 683" }
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M512.5,587.5L262.5,838C252.167,848.333 239.5,853.5 224.5,853.5C209.5,853.5 196.917,848.417 186.75,838.25C176.583,828.083 171.5,815.5 171.5,800.5C171.5,785.5 176.667,772.833 187,762.5L437,512L187,262C176.667,251.667 171.5,239.167 171.5,224.5C171.5,217.167 172.833,210.167 175.5,203.5C178.167,196.833 181.917,191.167 186.75,186.5C191.583,181.833 197.167,178.083 203.5,175.25C209.833,172.417 216.833,171 224.5,171C239.167,171 251.667,176.167 262,186.5L512.5,437L762.5,186.5C773.167,175.833 785.833,170.5 800.5,170.5C807.833,170.5 814.75,171.917 821.25,174.75C827.75,177.583 833.417,181.417 838.25,186.25C843.083,191.083 846.833,196.75 849.5,203.25C852.167,209.75 853.5,216.667 853.5,224C853.5,238.667 848.333,251.167 838,261.5L587.5,512L838,762.5C848.667,773.167 854,785.833 854,800.5C854,807.833 852.583,814.667 849.75,821C846.917,827.333 843.083,832.917 838.25,837.75C833.417,842.583 827.75,846.417 821.25,849.25C814.75,852.083 807.833,853.5 800.5,853.5C785.5,853.5 772.833,848.333 762.5,838Z");
      add_location(path, file15, 56, 4, 5569);
      set_svg_attributes(svg, svg_data);
      toggle_class(svg, "svelte-1kvqfof", true);
      add_location(svg, file15, 55, 3, 5519);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, dirty) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        /*svgProps*/
        ctx2[4],
        { viewBox: "172 171 683 683" }
      ]));
      toggle_class(svg, "svelte-1kvqfof", true);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(55:36) ",
    ctx
  });
  return block;
}
function create_if_block_23(ctx) {
  let svg;
  let path;
  let svg_levels = [
    /*svgProps*/
    ctx[4],
    { viewBox: "406 86 213 875" }
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M426.5,512L426.5,170.5C426.5,158.833 428.75,147.833 433.25,137.5C437.75,127.167 443.917,118.167 451.75,110.5C459.583,102.833 468.667,96.75 479,92.25C489.333,87.75 500.333,85.5 512,85.5C523.667,85.5 534.667,87.75 545,92.25C555.333,96.75 564.417,102.833 572.25,110.5C580.083,118.167 586.25,127.167 590.75,137.5C595.25,147.833 597.5,158.833 597.5,170.5L597.5,512C597.5,523.667 595.25,534.667 590.75,545C586.25,555.333 580.083,564.417 572.25,572.25C564.417,580.083 555.333,586.25 545,590.75C534.667,595.25 523.667,597.5 512,597.5C500.333,597.5 489.333,595.25 479,590.75C468.667,586.25 459.583,580.083 451.75,572.25C443.917,564.417 437.75,555.333 433.25,545C428.75,534.667 426.5,523.667 426.5,512ZM405.5,853.5C405.5,838.833 408.333,825 414,812C419.667,799 427.333,787.667 437,778C446.667,768.333 457.917,760.667 470.75,755C483.583,749.333 497.333,746.5 512,746.5C526.667,746.5 540.417,749.333 553.25,755C566.083,760.667 577.333,768.333 587,778C596.667,787.667 604.333,799 610,812C615.667,825 618.5,838.833 618.5,853.5C618.5,868.167 615.667,881.917 610,894.75C604.333,907.583 596.667,918.833 587,928.5C577.333,938.167 566,945.833 553,951.5C540,957.167 526.333,960 512,960C497.333,960 483.583,957.167 470.75,951.5C457.917,945.833 446.667,938.167 437,928.5C427.333,918.833 419.667,907.583 414,894.75C408.333,881.917 405.5,868.167 405.5,853.5Z");
      add_location(path, file15, 49, 4, 4087);
      set_svg_attributes(svg, svg_data);
      toggle_class(svg, "svelte-1kvqfof", true);
      add_location(svg, file15, 48, 3, 4038);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, dirty) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        /*svgProps*/
        ctx2[4],
        { viewBox: "406 86 213 875" }
      ]));
      toggle_class(svg, "svelte-1kvqfof", true);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_23.name,
    type: "if",
    source: "(48:35) ",
    ctx
  });
  return block;
}
function create_if_block_18(ctx) {
  let svg;
  let path;
  let svg_levels = [
    /*svgProps*/
    ctx[4],
    { viewBox: "118 245 790 577" }
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M117.5,554.5C117.5,547.167 118.917,540.25 121.75,533.75C124.583,527.25 128.417,521.583 133.25,516.75C138.083,511.917 143.75,508.083 150.25,505.25C156.75,502.417 163.667,501 171,501C185.333,501 197.833,506.333 208.5,517L384,692.5L815.5,261C826.167,250.333 838.833,245 853.5,245C860.833,245 867.75,246.417 874.25,249.25C880.75,252.083 886.417,256 891.25,261C896.083,266 899.917,271.75 902.75,278.25C905.583,284.75 907,291.5 907,298.5C907,313.167 901.667,325.833 891,336.5L421.5,805.5C416.5,810.5 410.75,814.417 404.25,817.25C397.75,820.083 391,821.5 384,821.5C369.667,821.5 357.167,816.167 346.5,805.5L133,592.5C122.667,582.167 117.5,569.5 117.5,554.5Z");
      add_location(path, file15, 42, 4, 3291);
      set_svg_attributes(svg, svg_data);
      toggle_class(svg, "svelte-1kvqfof", true);
      add_location(svg, file15, 41, 3, 3241);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, dirty) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        /*svgProps*/
        ctx2[4],
        { viewBox: "118 245 790 577" }
      ]));
      toggle_class(svg, "svelte-1kvqfof", true);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_18.name,
    type: "if",
    source: "(41:35) ",
    ctx
  });
  return block;
}
function create_if_block8(ctx) {
  let svg;
  let path;
  let svg_levels = [
    /*svgProps*/
    ctx[4],
    { viewBox: "162 118 701 789" }
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M862.5,680C862.5,687.333 861.083,694.25 858.25,700.75C855.417,707.25 851.583,712.917 846.75,717.75C841.917,722.583 836.25,726.417 829.75,729.25C823.25,732.083 816.333,733.5 809,733.5C800,733.5 791.333,731.167 783,726.5L565.5,603.5L565.5,853.5C565.5,860.833 564.083,867.75 561.25,874.25C558.417,880.75 554.583,886.333 549.75,891C544.917,895.667 539.25,899.417 532.75,902.25C526.25,905.083 519.333,906.5 512,906.5C504.667,906.5 497.75,905.083 491.25,902.25C484.75,899.417 479.083,895.667 474.25,891C469.417,886.333 465.583,880.75 462.75,874.25C459.917,867.75 458.5,860.833 458.5,853.5L458.5,603.5L241,726.5C232.667,731.167 224,733.5 215,733.5C207.667,733.5 200.75,732.083 194.25,729.25C187.75,726.417 182.083,722.583 177.25,717.75C172.417,712.917 168.583,707.25 165.75,700.75C162.917,694.25 161.5,687.333 161.5,680C161.5,670.667 164,661.75 169,653.25C174,644.75 180.5,638.167 188.5,633.5L403.5,512L188.5,390.5C180.5,385.833 174,379.25 169,370.75C164,362.25 161.5,353.333 161.5,344C161.5,336.667 162.917,329.75 165.75,323.25C168.583,316.75 172.417,311.083 177.25,306.25C182.083,301.417 187.75,297.583 194.25,294.75C200.75,291.917 207.667,290.5 215,290.5C224.667,290.5 233.333,292.833 241,297.5L458.5,420.5L458.5,170.5C458.5,163.167 459.917,156.25 462.75,149.75C465.583,143.25 469.417,137.667 474.25,133C479.083,128.333 484.75,124.583 491.25,121.75C497.75,118.917 504.667,117.5 512,117.5C519.333,117.5 526.25,118.917 532.75,121.75C539.25,124.583 544.917,128.333 549.75,133C554.583,137.667 558.417,143.25 561.25,149.75C564.083,156.25 565.5,163.167 565.5,170.5L565.5,420.5L783,297.5C791.333,292.833 800,290.5 809,290.5C816.333,290.5 823.25,291.917 829.75,294.75C836.25,297.583 841.917,301.417 846.75,306.25C851.583,311.083 855.417,316.75 858.25,323.25C861.083,329.75 862.5,336.667 862.5,344C862.5,353.333 860,362.25 855,370.75C850,379.25 843.5,385.833 835.5,390.5L620.5,512L835.5,633.5C843.5,638.167 850,644.75 855,653.25C860,661.75 862.5,670.667 862.5,680Z");
      add_location(path, file15, 35, 4, 1193);
      set_svg_attributes(svg, svg_data);
      toggle_class(svg, "svelte-1kvqfof", true);
      add_location(svg, file15, 34, 3, 1143);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, dirty) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        /*svgProps*/
        ctx2[4],
        { viewBox: "162 118 701 789" }
      ]));
      toggle_class(svg, "svelte-1kvqfof", true);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: '(34:2) {#if severity === \\"attention\\"}',
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*severity*/
      ctx2[1] === "attention"
    )
      return create_if_block8;
    if (
      /*severity*/
      ctx2[1] === "success"
    )
      return create_if_block_18;
    if (
      /*severity*/
      ctx2[1] === "caution"
    )
      return create_if_block_23;
    if (
      /*severity*/
      ctx2[1] === "critical"
    )
      return create_if_block_32;
    if (
      /*severity*/
      ctx2[1] === "information"
    )
      return create_if_block_42;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type && current_block_type(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if (if_block) {
        if_block.d(detaching);
      }
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(33:7)    ",
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let span;
  let span_class_value;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  let span_levels = [
    {
      class: span_class_value = "info-badge severity-" + /*severity*/
      ctx[1] + " " + /*className*/
      ctx[2]
    },
    /*$$restProps*/
    ctx[5]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      toggle_class(span, "svelte-1kvqfof", true);
      add_location(span, file15, 26, 0, 981);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(span, null);
      }
      ctx[8](span);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(forwardEvents_action = /*forwardEvents*/
        ctx[3].call(null, span));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*severity*/
        2)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*severity, className*/
        6 && span_class_value !== (span_class_value = "info-badge severity-" + /*severity*/
        ctx2[1] + " " + /*className*/
        ctx2[2])) && { class: span_class_value },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
      toggle_class(span, "svelte-1kvqfof", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[8](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  const omit_props_names = ["severity", "class", "element"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InfoBadge", slots, ["default"]);
  let { severity = "attention" } = $$props;
  let { class: className = "" } = $$props;
  let { element: element2 = null } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  const svgProps = {
    "aria-hidden": true,
    xmlns: "http://www.w3.org/2000/svg"
  };
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("severity" in $$new_props)
      $$invalidate(1, severity = $$new_props.severity);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventForwarder,
    get_current_component,
    severity,
    className,
    element: element2,
    forwardEvents,
    svgProps
  });
  $$self.$inject_state = ($$new_props) => {
    if ("severity" in $$props)
      $$invalidate(1, severity = $$new_props.severity);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    severity,
    className,
    forwardEvents,
    svgProps,
    $$restProps,
    $$scope,
    slots,
    span_binding
  ];
}
var InfoBadge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { severity: 1, class: 2, element: 0 }, add_css15);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InfoBadge",
      options,
      id: create_fragment15.name
    });
  }
  get severity() {
    throw new Error("<InfoBadge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set severity(value) {
    throw new Error("<InfoBadge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<InfoBadge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<InfoBadge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<InfoBadge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<InfoBadge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InfoBadge_default = InfoBadge;

// node_modules/fluent-svelte/Flyout/FlyoutWrapper.svelte
var file16 = "node_modules\\fluent-svelte\\Flyout\\FlyoutWrapper.svelte";
function add_css16(target) {
  append_styles(target, "svelte-1gamowb", "@-webkit-keyframes svelte-1gamowb-flyout-in{0%{opacity:0;transform:var(--fds-flyout-transform) var(--fds-flyout-transition-offset,translateY(12px))}to{opacity:1;transform:var(--fds-flyout-transform)}}@keyframes svelte-1gamowb-flyout-in{0%{opacity:0;transform:var(--fds-flyout-transform) var(--fds-flyout-transition-offset,translateY(12px))}to{opacity:1;transform:var(--fds-flyout-transform)}}.flyout-wrapper.svelte-1gamowb{block-size:-webkit-fit-content;block-size:-moz-fit-content;block-size:fit-content;display:inline-block;inline-size:-webkit-fit-content;inline-size:-moz-fit-content;inline-size:fit-content;position:relative}.flyout-backdrop.svelte-1gamowb{block-size:100%;inline-size:100%;left:0;position:fixed;top:0;z-index:9999}.flyout-anchor.svelte-1gamowb{-webkit-animation:svelte-1gamowb-flyout-in var(--fds-control-normal-duration) var(--fds-control-fast-out-slow-in-easing);animation:svelte-1gamowb-flyout-in var(--fds-control-normal-duration) var(--fds-control-fast-out-slow-in-easing);position:absolute;transform:var(--fds-flyout-transform);z-index:10000}.flyout-anchor.placement-top.svelte-1gamowb{--fds-flyout-transition-offset:translateY(12px);bottom:calc(100% + var(--fds-flyout-offset))}.flyout-anchor.placement-bottom.svelte-1gamowb{--fds-flyout-transition-offset:translateY(-12px);top:calc(100% + var(--fds-flyout-offset))}.flyout-anchor.placement-left.svelte-1gamowb{--fds-flyout-transition-offset:translateX(12px);right:calc(100% + var(--fds-flyout-offset))}.flyout-anchor.placement-right.svelte-1gamowb{--fds-flyout-transition-offset:translateX(-12px);left:calc(100% + var(--fds-flyout-offset))}.flyout-anchor.placement-bottom.alignment-start.svelte-1gamowb,.flyout-anchor.placement-top.alignment-start.svelte-1gamowb{inset-inline-start:0}.flyout-anchor.placement-bottom.alignment-end.svelte-1gamowb,.flyout-anchor.placement-top.alignment-end.svelte-1gamowb{inset-inline-end:0}.flyout-anchor.placement-bottom.alignment-center.svelte-1gamowb,.flyout-anchor.placement-top.alignment-center.svelte-1gamowb{--fds-flyout-transform:translateX(-50%);inset-inline-start:50%}.flyout-anchor.placement-left.alignment-start.svelte-1gamowb,.flyout-anchor.placement-right.alignment-start.svelte-1gamowb{inset-block-start:0}.flyout-anchor.placement-left.alignment-end.svelte-1gamowb,.flyout-anchor.placement-right.alignment-end.svelte-1gamowb{inset-block-end:0}.flyout-anchor.placement-left.alignment-center.svelte-1gamowb,.flyout-anchor.placement-right.alignment-center.svelte-1gamowb{--fds-flyout-transform:translateY(-50%);inset-block-start:50%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRmx5b3V0V3JhcHBlci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBNEdRLG1CQUFBLHdCQUFBLENBQTZCLEVBQUEsQ0FBRyxRQUFBLENBQVMsQ0FBQyxVQUFBLElBQUEsc0JBQUEsQ0FBQSxDQUFBLElBQUEsOEJBQUEsQ0FBQSxnQkFBQSxDQUEwRixDQUFDLEVBQUEsQ0FBRyxRQUFBLENBQVMsQ0FBQyxVQUFBLElBQUEsc0JBQUEsQ0FBcUMsQ0FBQyxDQUFDLFdBQUEsd0JBQUEsQ0FBcUIsRUFBQSxDQUFHLFFBQUEsQ0FBUyxDQUFDLFVBQUEsSUFBQSxzQkFBQSxDQUFBLENBQUEsSUFBQSw4QkFBQSxDQUFBLGdCQUFBLENBQTBGLENBQUMsRUFBQSxDQUFHLFFBQUEsQ0FBUyxDQUFDLFVBQUEsSUFBQSxzQkFBQSxDQUFxQyxDQUFDLENBQUMsOEJBQUEsQ0FBZ0IsV0FBQSxtQkFBOEIsQ0FBQyxXQUFBLGdCQUEyQixDQUFDLFdBQUEsV0FBc0IsQ0FBQyxRQUFBLFlBQW9CLENBQUMsWUFBQSxtQkFBK0IsQ0FBQyxZQUFBLGdCQUE0QixDQUFDLFlBQUEsV0FBdUIsQ0FBQyxTQUFBLFFBQWlCLENBQUMsK0JBQUEsQ0FBaUIsV0FBQSxJQUFlLENBQUMsWUFBQSxJQUFnQixDQUFDLEtBQUEsQ0FBTSxDQUFDLFNBQUEsS0FBYyxDQUFDLElBQUEsQ0FBSyxDQUFDLFFBQUEsSUFBWSxDQUFDLDZCQUFBLENBQWUsa0JBQUEsd0JBQUEsQ0FBQSxJQUFBLDZCQUFBLENBQUEsQ0FBQSxJQUFBLHFDQUFBLENBQXlHLENBQUMsVUFBQSx3QkFBQSxDQUFBLElBQUEsNkJBQUEsQ0FBQSxDQUFBLElBQUEscUNBQUEsQ0FBaUcsQ0FBQyxTQUFBLFFBQWlCLENBQUMsVUFBQSxJQUFBLHNCQUFBLENBQXFDLENBQUMsUUFBQSxLQUFhLENBQUMsY0FBQSw2QkFBQSxDQUE2QiwrQkFBQSxnQkFBK0MsQ0FBQyxPQUFBLEtBQUEsSUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLG1CQUFBLENBQUEsQ0FBNEMsQ0FBQyxjQUFBLGdDQUFBLENBQWdDLCtCQUFBLGlCQUFnRCxDQUFDLElBQUEsS0FBQSxJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsbUJBQUEsQ0FBQSxDQUF5QyxDQUFDLGNBQUEsOEJBQUEsQ0FBOEIsK0JBQUEsZ0JBQStDLENBQUMsTUFBQSxLQUFBLElBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxtQkFBQSxDQUFBLENBQTJDLENBQUMsY0FBQSwrQkFBQSxDQUErQiwrQkFBQSxpQkFBZ0QsQ0FBQyxLQUFBLEtBQUEsSUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLG1CQUFBLENBQUEsQ0FBMEMsQ0FBQyxjQUFBLGlCQUFBLCtCQUFBLENBQUEsY0FBQSxjQUFBLCtCQUFBLENBQTZGLG1CQUFBLENBQW9CLENBQUMsY0FBQSxpQkFBQSw2QkFBQSxDQUFBLGNBQUEsY0FBQSw2QkFBQSxDQUF5RixpQkFBQSxDQUFrQixDQUFDLGNBQUEsaUJBQUEsZ0NBQUEsQ0FBQSxjQUFBLGNBQUEsZ0NBQUEsQ0FBK0YsdUJBQUEsZ0JBQXVDLENBQUMsbUJBQUEsR0FBc0IsQ0FBQyxjQUFBLGVBQUEsK0JBQUEsQ0FBQSxjQUFBLGdCQUFBLCtCQUFBLENBQTZGLGtCQUFBLENBQW1CLENBQUMsY0FBQSxlQUFBLDZCQUFBLENBQUEsY0FBQSxnQkFBQSw2QkFBQSxDQUF5RixnQkFBQSxDQUFpQixDQUFDLGNBQUEsZUFBQSxnQ0FBQSxDQUFBLGNBQUEsZ0JBQUEsZ0NBQUEsQ0FBK0YsdUJBQUEsZ0JBQXVDLENBQUMsa0JBQUEsR0FBcUIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJGbHlvdXRXcmFwcGVyLnN2ZWx0ZSJdfQ== */");
}
var get_flyout_slot_changes = (dirty) => ({});
var get_flyout_slot_context = (ctx) => ({});
var get_override_slot_changes = (dirty) => ({});
var get_override_slot_context = (ctx) => ({});
function create_if_block9(ctx) {
  let div0;
  let div0_class_value;
  let div0_style_value;
  let _focusTrap_action;
  let div0_outro;
  let t;
  let div1;
  let current;
  let mounted;
  let dispose;
  const override_slot_template = (
    /*#slots*/
    ctx[17].override
  );
  const override_slot = create_slot(
    override_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    get_override_slot_context
  );
  const override_slot_or_fallback = override_slot || fallback_block2(ctx);
  let div0_levels = [
    { id: (
      /*menuId*/
      ctx[10]
    ) },
    {
      class: div0_class_value = "flyout-anchor placement-" + /*placement*/
      ctx[5] + " alignment-" + /*alignment*/
      ctx[6]
    },
    {
      style: div0_style_value = "--fds-flyout-offset: " + /*offset*/
      ctx[7] + "px;"
    },
    /*$$restProps*/
    ctx[14]
  ];
  let div0_data = {};
  for (let i = 0; i < div0_levels.length; i += 1) {
    div0_data = assign(div0_data, div0_levels[i]);
  }
  const block = {
    c: function create() {
      div0 = element("div");
      if (override_slot_or_fallback)
        override_slot_or_fallback.c();
      t = space();
      div1 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div0 = claim_element(nodes, "DIV", { id: true, class: true, style: true });
      var div0_nodes = children(div0);
      if (override_slot_or_fallback)
        override_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      children(div1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div0, div0_data);
      toggle_class(div0, "svelte-1gamowb", true);
      add_location(div0, file16, 80, 2, 2725);
      attr_dev(div1, "class", "flyout-backdrop svelte-1gamowb");
      add_location(div1, file16, 99, 2, 3222);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div0, anchor);
      if (override_slot_or_fallback) {
        override_slot_or_fallback.m(div0, null);
      }
      ctx[19](div0);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, div1, anchor);
      ctx[20](div1);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(_focusTrap_action = /*_focusTrap*/
          ctx[9].call(null, div0)),
          listen_dev(div0, "click", click_handler, false, false, false),
          listen_dev(div1, "click", click_handler_1, false, false, false),
          listen_dev(
            div1,
            "mousedown",
            /*closeFlyout*/
            ctx[12],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (override_slot) {
        if (override_slot.p && (!current || dirty & /*$$scope*/
        8388608)) {
          update_slot_base(
            override_slot,
            override_slot_template,
            ctx,
            /*$$scope*/
            ctx[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[23]
            ) : get_slot_changes(
              override_slot_template,
              /*$$scope*/
              ctx[23],
              dirty,
              get_override_slot_changes
            ),
            get_override_slot_context
          );
        }
      } else {
        if (override_slot_or_fallback && override_slot_or_fallback.p && (!current || dirty & /*menuElement, $$scope*/
        8388616)) {
          override_slot_or_fallback.p(ctx, !current ? -1 : dirty);
        }
      }
      set_attributes(div0, div0_data = get_spread_update(div0_levels, [
        { id: (
          /*menuId*/
          ctx[10]
        ) },
        (!current || dirty & /*placement, alignment*/
        96 && div0_class_value !== (div0_class_value = "flyout-anchor placement-" + /*placement*/
        ctx[5] + " alignment-" + /*alignment*/
        ctx[6])) && { class: div0_class_value },
        (!current || dirty & /*offset*/
        128 && div0_style_value !== (div0_style_value = "--fds-flyout-offset: " + /*offset*/
        ctx[7] + "px;")) && { style: div0_style_value },
        dirty & /*$$restProps*/
        16384 && /*$$restProps*/
        ctx[14]
      ]));
      toggle_class(div0, "svelte-1gamowb", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(override_slot_or_fallback, local);
      if (div0_outro)
        div0_outro.end(1);
      current = true;
    },
    o: function outro(local) {
      transition_out(override_slot_or_fallback, local);
      if (local) {
        div0_outro = create_out_transition(div0, fade, {
          duration: getCSSDuration("--fds-control-faster-duration"),
          easing: circOut
        });
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div0);
      if (override_slot_or_fallback)
        override_slot_or_fallback.d(detaching);
      ctx[19](null);
      if (detaching && div0_outro)
        div0_outro.end();
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(div1);
      ctx[20](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(80:1) {#if open}",
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let current;
  const flyout_slot_template = (
    /*#slots*/
    ctx[17].flyout
  );
  const flyout_slot = create_slot(
    flyout_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    get_flyout_slot_context
  );
  const block = {
    c: function create() {
      if (flyout_slot)
        flyout_slot.c();
    },
    l: function claim(nodes) {
      if (flyout_slot)
        flyout_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (flyout_slot) {
        flyout_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (flyout_slot) {
        if (flyout_slot.p && (!current || dirty & /*$$scope*/
        8388608)) {
          update_slot_base(
            flyout_slot,
            flyout_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              flyout_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              get_flyout_slot_changes
            ),
            get_flyout_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(flyout_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(flyout_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (flyout_slot)
        flyout_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(95:4) <FlyoutSurface bind:element={menuElement}>",
    ctx
  });
  return block;
}
function fallback_block2(ctx) {
  let flyoutsurface;
  let updating_element;
  let current;
  function flyoutsurface_element_binding(value) {
    ctx[18](value);
  }
  let flyoutsurface_props = {
    $$slots: { default: [create_default_slot3] },
    $$scope: { ctx }
  };
  if (
    /*menuElement*/
    ctx[3] !== void 0
  ) {
    flyoutsurface_props.element = /*menuElement*/
    ctx[3];
  }
  flyoutsurface = new FlyoutSurface_default({
    props: flyoutsurface_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(flyoutsurface, "element", flyoutsurface_element_binding));
  const block = {
    c: function create() {
      create_component(flyoutsurface.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(flyoutsurface.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(flyoutsurface, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const flyoutsurface_changes = {};
      if (dirty & /*$$scope*/
      8388608) {
        flyoutsurface_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_element && dirty & /*menuElement*/
      8) {
        updating_element = true;
        flyoutsurface_changes.element = /*menuElement*/
        ctx2[3];
        add_flush_callback(() => updating_element = false);
      }
      flyoutsurface.$set(flyoutsurface_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(flyoutsurface.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(flyoutsurface.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(flyoutsurface, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block2.name,
    type: "fallback",
    source: "(94:25)      ",
    ctx
  });
  return block;
}
function create_fragment16(ctx) {
  let div;
  let t;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    null
  );
  let if_block = (
    /*open*/
    ctx[0] && create_if_block9(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "aria-expanded": true,
        "aria-haspopup": true,
        "aria-controls": true
      });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "flyout-wrapper " + /*className*/
      ctx[8] + " svelte-1gamowb");
      attr_dev(
        div,
        "aria-expanded",
        /*open*/
        ctx[0]
      );
      attr_dev(
        div,
        "aria-haspopup",
        /*open*/
        ctx[0]
      );
      attr_dev(
        div,
        "aria-controls",
        /*menuId*/
        ctx[10]
      );
      add_location(div, file16, 69, 0, 2501);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_hydration_dev(div, t);
      if (if_block)
        if_block.m(div, null);
      ctx[22](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "keydown",
            /*handleEscapeKey*/
            ctx[11],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "click",
            /*click_handler_2*/
            ctx[21],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keydown",
            /*handleKeyDown*/
            ctx[13],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8388608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*open*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*open*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*className*/
      256 && div_class_value !== (div_class_value = "flyout-wrapper " + /*className*/
      ctx2[8] + " svelte-1gamowb")) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*open*/
      1) {
        attr_dev(
          div,
          "aria-expanded",
          /*open*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*open*/
      1) {
        attr_dev(
          div,
          "aria-haspopup",
          /*open*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[22](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var click_handler = (e) => e.stopPropagation();
var click_handler_1 = (e) => e.stopPropagation();
function instance16($$self, $$props, $$invalidate) {
  let _focusTrap;
  const omit_props_names = [
    "open",
    "closable",
    "placement",
    "alignment",
    "offset",
    "trapFocus",
    "class",
    "wrapperElement",
    "anchorElement",
    "menuElement",
    "backdropElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FlyoutWrapper", slots, ["default", "flyout", "override"]);
  let { open = false } = $$props;
  let { closable = true } = $$props;
  let { placement = "top" } = $$props;
  let { alignment = "center" } = $$props;
  let { offset = 4 } = $$props;
  let { trapFocus = true } = $$props;
  let { class: className = "" } = $$props;
  let { wrapperElement = null } = $$props;
  let { anchorElement = null } = $$props;
  let { menuElement = null } = $$props;
  let { backdropElement = null } = $$props;
  const dispatch = createEventDispatcher();
  const menuId = uid("fds-flyout-anchor-");
  function handleEscapeKey({ key }) {
    if (key === "Escape" && closable)
      $$invalidate(0, open = false);
  }
  function closeFlyout() {
    if (closable)
      $$invalidate(0, open = false);
  }
  function handleKeyDown2(event2) {
    if (event2.key === " " || event2.key === "Enter") {
      event2.preventDefault();
      $$invalidate(0, open = !open);
    }
  }
  function flyoutsurface_element_binding(value) {
    menuElement = value;
    $$invalidate(3, menuElement);
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      anchorElement = $$value;
      $$invalidate(2, anchorElement);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      backdropElement = $$value;
      $$invalidate(4, backdropElement);
    });
  }
  const click_handler_2 = () => $$invalidate(0, open = !open);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      wrapperElement = $$value;
      $$invalidate(1, wrapperElement);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("closable" in $$new_props)
      $$invalidate(15, closable = $$new_props.closable);
    if ("placement" in $$new_props)
      $$invalidate(5, placement = $$new_props.placement);
    if ("alignment" in $$new_props)
      $$invalidate(6, alignment = $$new_props.alignment);
    if ("offset" in $$new_props)
      $$invalidate(7, offset = $$new_props.offset);
    if ("trapFocus" in $$new_props)
      $$invalidate(16, trapFocus = $$new_props.trapFocus);
    if ("class" in $$new_props)
      $$invalidate(8, className = $$new_props.class);
    if ("wrapperElement" in $$new_props)
      $$invalidate(1, wrapperElement = $$new_props.wrapperElement);
    if ("anchorElement" in $$new_props)
      $$invalidate(2, anchorElement = $$new_props.anchorElement);
    if ("menuElement" in $$new_props)
      $$invalidate(3, menuElement = $$new_props.menuElement);
    if ("backdropElement" in $$new_props)
      $$invalidate(4, backdropElement = $$new_props.backdropElement);
    if ("$$scope" in $$new_props)
      $$invalidate(23, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    uid,
    focusTrap,
    getCSSDuration,
    fade,
    circOut,
    FlyoutSurface: FlyoutSurface_default,
    open,
    closable,
    placement,
    alignment,
    offset,
    trapFocus,
    className,
    wrapperElement,
    anchorElement,
    menuElement,
    backdropElement,
    dispatch,
    menuId,
    handleEscapeKey,
    closeFlyout,
    handleKeyDown: handleKeyDown2,
    _focusTrap
  });
  $$self.$inject_state = ($$new_props) => {
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("closable" in $$props)
      $$invalidate(15, closable = $$new_props.closable);
    if ("placement" in $$props)
      $$invalidate(5, placement = $$new_props.placement);
    if ("alignment" in $$props)
      $$invalidate(6, alignment = $$new_props.alignment);
    if ("offset" in $$props)
      $$invalidate(7, offset = $$new_props.offset);
    if ("trapFocus" in $$props)
      $$invalidate(16, trapFocus = $$new_props.trapFocus);
    if ("className" in $$props)
      $$invalidate(8, className = $$new_props.className);
    if ("wrapperElement" in $$props)
      $$invalidate(1, wrapperElement = $$new_props.wrapperElement);
    if ("anchorElement" in $$props)
      $$invalidate(2, anchorElement = $$new_props.anchorElement);
    if ("menuElement" in $$props)
      $$invalidate(3, menuElement = $$new_props.menuElement);
    if ("backdropElement" in $$props)
      $$invalidate(4, backdropElement = $$new_props.backdropElement);
    if ("_focusTrap" in $$props)
      $$invalidate(9, _focusTrap = $$new_props._focusTrap);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*trapFocus*/
    65536) {
      $:
        $$invalidate(9, _focusTrap = trapFocus ? focusTrap : () => {
        });
    }
    if ($$self.$$.dirty & /*open*/
    1) {
      $:
        if (open) {
          dispatch("open");
        } else {
          dispatch("close");
        }
    }
  };
  return [
    open,
    wrapperElement,
    anchorElement,
    menuElement,
    backdropElement,
    placement,
    alignment,
    offset,
    className,
    _focusTrap,
    menuId,
    handleEscapeKey,
    closeFlyout,
    handleKeyDown2,
    $$restProps,
    closable,
    trapFocus,
    slots,
    flyoutsurface_element_binding,
    div0_binding,
    div1_binding,
    click_handler_2,
    div_binding,
    $$scope
  ];
}
var FlyoutWrapper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance16,
      create_fragment16,
      safe_not_equal,
      {
        open: 0,
        closable: 15,
        placement: 5,
        alignment: 6,
        offset: 7,
        trapFocus: 16,
        class: 8,
        wrapperElement: 1,
        anchorElement: 2,
        menuElement: 3,
        backdropElement: 4
      },
      add_css16
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FlyoutWrapper",
      options,
      id: create_fragment16.name
    });
  }
  get open() {
    throw new Error("<FlyoutWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<FlyoutWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closable() {
    throw new Error("<FlyoutWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closable(value) {
    throw new Error("<FlyoutWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placement() {
    throw new Error("<FlyoutWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placement(value) {
    throw new Error("<FlyoutWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alignment() {
    throw new Error("<FlyoutWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alignment(value) {
    throw new Error("<FlyoutWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get offset() {
    throw new Error("<FlyoutWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set offset(value) {
    throw new Error("<FlyoutWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get trapFocus() {
    throw new Error("<FlyoutWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set trapFocus(value) {
    throw new Error("<FlyoutWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<FlyoutWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FlyoutWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapperElement() {
    throw new Error("<FlyoutWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapperElement(value) {
    throw new Error("<FlyoutWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchorElement() {
    throw new Error("<FlyoutWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchorElement(value) {
    throw new Error("<FlyoutWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get menuElement() {
    throw new Error("<FlyoutWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set menuElement(value) {
    throw new Error("<FlyoutWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdropElement() {
    throw new Error("<FlyoutWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdropElement(value) {
    throw new Error("<FlyoutWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FlyoutWrapper_default = FlyoutWrapper;

// node_modules/fluent-svelte/InfoBar/InfoBar.svelte
var file17 = "node_modules\\fluent-svelte\\InfoBar\\InfoBar.svelte";
function add_css17(target) {
  append_styles(target, "svelte-p86mq6", ".info-bar.svelte-p86mq6.svelte-p86mq6{-webkit-padding-start:15px;align-items:center;background-clip:padding-box;border:1px solid var(--fds-card-stroke-default);border-radius:var(--fds-control-corner-radius);box-sizing:border-box;display:flex;font-family:var(--fds-font-family-text);min-block-size:48px;padding-inline-start:15px;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.info-bar.severity-information.svelte-p86mq6.svelte-p86mq6{background-color:var(--fds-card-background-secondary)}.info-bar.severity-success.svelte-p86mq6.svelte-p86mq6{background-color:var(--fds-system-background-success)}.info-bar.severity-caution.svelte-p86mq6.svelte-p86mq6{background-color:var(--fds-system-background-caution)}.info-bar.severity-critical.svelte-p86mq6.svelte-p86mq6{background-color:var(--fds-system-background-critical)}.info-bar.severity-attention.svelte-p86mq6.svelte-p86mq6{background-color:var(--fds-system-background-attention)}.info-bar-icon.svelte-p86mq6.svelte-p86mq6{-webkit-margin-before:16px;align-self:flex-start;display:flex;flex:0 0 auto;margin-block-start:16px}.info-bar-content.svelte-p86mq6.svelte-p86mq6{-webkit-margin-start:13px;-webkit-margin-before:7px;-webkit-margin-after:7px;align-items:center;box-sizing:border-box;display:flex;flex:1 1 auto;flex-wrap:wrap;margin-block-end:7px;margin-block-start:7px;margin-inline-start:13px;position:relative}.info-bar-content.action-wrapped.svelte-p86mq6.svelte-p86mq6,.info-bar-content.message-wrapped.svelte-p86mq6.svelte-p86mq6{-webkit-margin-before:13px;-webkit-margin-after:15px;margin-block-end:15px;margin-block-start:13px}.info-bar-content.message-wrapped.svelte-p86mq6 h5.svelte-p86mq6,.info-bar-content.message-wrapped.svelte-p86mq6 p.svelte-p86mq6{align-self:flex-start}.info-bar-content.message-wrapped.svelte-p86mq6 .info-bar-action.svelte-p86mq6{-webkit-margin-end:50%;margin-inline-end:50%}.info-bar-content.action-wrapped.svelte-p86mq6 .info-bar-action.svelte-p86mq6{-webkit-padding-before:16px;padding-block-start:16px}.info-bar.svelte-p86mq6 h5.svelte-p86mq6,.info-bar.svelte-p86mq6 p.svelte-p86mq6{color:var(--fds-text-primary);font-size:var(--fds-body-font-size);font-weight:400;line-height:20px;margin:0}.info-bar.svelte-p86mq6 h5.svelte-p86mq6{-webkit-margin-end:12px;font-weight:600;margin-inline-end:12px}.info-bar.svelte-p86mq6 p.svelte-p86mq6{-webkit-margin-end:15px;flex:1 1 auto;margin-inline-end:15px}.info-bar-action.svelte-p86mq6.svelte-p86mq6{-webkit-margin-end:4px;margin-inline-end:4px}.info-bar-action.svelte-p86mq6.svelte-p86mq6,.info-bar-close-button.svelte-p86mq6.svelte-p86mq6{align-items:center;align-self:flex-start;display:flex}.info-bar-close-button.svelte-p86mq6.svelte-p86mq6{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:var(--fds-subtle-fill-transparent);block-size:38px;border:none;border-radius:var(--fds-control-corner-radius);color:var(--fds-text-primary);flex:0 0 auto;inline-size:38px;justify-content:center;margin:4px;outline:none;transition:var(--fds-control-fast-duration) var(--fds-control-fast-out-slow-in-easing)}.info-bar-close-button.svelte-p86mq6.svelte-p86mq6:focus-visible{box-shadow:var(--fds-focus-stroke)}.info-bar-close-button.svelte-p86mq6.svelte-p86mq6:hover{background-color:var(--fds-subtle-fill-secondary)}.info-bar-close-button.svelte-p86mq6.svelte-p86mq6:active{background-color:var(--fds-subtle-fill-tertiary);color:var(--fds-text-secondary)}.info-bar-close-button.svelte-p86mq6 svg.svelte-p86mq6{fill:currentColor;block-size:12px;inline-size:12px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5mb0Jhci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBa0hRLHFDQUFBLENBQVUsc0JBQUEsSUFBMEIsQ0FBQyxZQUFBLE1BQWtCLENBQUMsZ0JBQUEsV0FBMkIsQ0FBQyxPQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSx5QkFBQSxDQUErQyxDQUFDLGNBQUEsSUFBQSwyQkFBQSxDQUE4QyxDQUFDLFdBQUEsVUFBcUIsQ0FBQyxRQUFBLElBQVksQ0FBQyxZQUFBLElBQUEsc0JBQUEsQ0FBdUMsQ0FBQyxlQUFBLElBQW1CLENBQUMscUJBQUEsSUFBeUIsQ0FBQyxTQUFBLFFBQWlCLENBQUMsb0JBQUEsSUFBd0IsQ0FBQyxpQkFBQSxJQUFxQixDQUFDLGdCQUFBLElBQW9CLENBQUMsWUFBQSxJQUFnQixDQUFDLFNBQUEsaURBQUEsQ0FBK0IsaUJBQUEsSUFBQSwrQkFBQSxDQUFxRCxDQUFDLFNBQUEsNkNBQUEsQ0FBMkIsaUJBQUEsSUFBQSwrQkFBQSxDQUFxRCxDQUFDLFNBQUEsNkNBQUEsQ0FBMkIsaUJBQUEsSUFBQSwrQkFBQSxDQUFxRCxDQUFDLFNBQUEsOENBQUEsQ0FBNEIsaUJBQUEsSUFBQSxnQ0FBQSxDQUFzRCxDQUFDLFNBQUEsK0NBQUEsQ0FBNkIsaUJBQUEsSUFBQSxpQ0FBQSxDQUF1RCxDQUFDLDBDQUFBLENBQWUsc0JBQUEsSUFBMEIsQ0FBQyxXQUFBLFVBQXFCLENBQUMsUUFBQSxJQUFZLENBQUMsS0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLElBQWEsQ0FBQyxtQkFBQSxJQUF1QixDQUFDLDZDQUFBLENBQWtCLHFCQUFBLElBQXlCLENBQUMsc0JBQUEsR0FBeUIsQ0FBQyxxQkFBQSxHQUF3QixDQUFDLFlBQUEsTUFBa0IsQ0FBQyxXQUFBLFVBQXFCLENBQUMsUUFBQSxJQUFZLENBQUMsS0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLElBQWEsQ0FBQyxVQUFBLElBQWMsQ0FBQyxpQkFBQSxHQUFvQixDQUFDLG1CQUFBLEdBQXNCLENBQUMsb0JBQUEsSUFBd0IsQ0FBQyxTQUFBLFFBQWlCLENBQUMsaUJBQUEsMkNBQUEsQ0FBQSxpQkFBQSw0Q0FBQSxDQUFtRSxzQkFBQSxJQUEwQixDQUFDLHFCQUFBLElBQXlCLENBQUMsaUJBQUEsSUFBcUIsQ0FBQyxtQkFBQSxJQUF1QixDQUFDLGlCQUFBLDhCQUFBLENBQUEsZ0JBQUEsQ0FBQSxpQkFBQSw4QkFBQSxDQUFBLGVBQUEsQ0FBeUUsV0FBQSxVQUFxQixDQUFDLGlCQUFBLDhCQUFBLENBQUEsOEJBQUEsQ0FBbUQsbUJBQUEsR0FBc0IsQ0FBQyxrQkFBQSxHQUFxQixDQUFDLGlCQUFBLDZCQUFBLENBQUEsOEJBQUEsQ0FBa0QsdUJBQUEsSUFBMkIsQ0FBQyxvQkFBQSxJQUF3QixDQUFDLHVCQUFBLENBQUEsZ0JBQUEsQ0FBQSx1QkFBQSxDQUFBLGVBQUEsQ0FBeUIsTUFBQSxJQUFBLGtCQUFBLENBQTZCLENBQUMsVUFBQSxJQUFBLG9CQUFBLENBQW1DLENBQUMsWUFBQSxHQUFlLENBQUMsWUFBQSxJQUFnQixDQUFDLE9BQUEsQ0FBUSxDQUFDLHVCQUFBLENBQUEsZ0JBQUEsQ0FBYSxtQkFBQSxJQUF1QixDQUFDLFlBQUEsR0FBZSxDQUFDLGtCQUFBLElBQXNCLENBQUMsdUJBQUEsQ0FBQSxlQUFBLENBQVksbUJBQUEsSUFBdUIsQ0FBQyxLQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsSUFBYSxDQUFDLGtCQUFBLElBQXNCLENBQUMsNENBQUEsQ0FBaUIsbUJBQUEsR0FBc0IsQ0FBQyxrQkFBQSxHQUFxQixDQUFDLDRDQUFBLENBQUEsa0RBQUEsQ0FBd0MsWUFBQSxNQUFrQixDQUFDLFdBQUEsVUFBcUIsQ0FBQyxRQUFBLElBQVksQ0FBQyxrREFBQSxDQUF1QixtQkFBQSxJQUF1QixDQUFDLGdCQUFBLElBQW9CLENBQUMsV0FBQSxJQUFlLENBQUMsaUJBQUEsSUFBQSw2QkFBQSxDQUFtRCxDQUFDLFdBQUEsSUFBZSxDQUFDLE9BQUEsSUFBVyxDQUFDLGNBQUEsSUFBQSwyQkFBQSxDQUE4QyxDQUFDLE1BQUEsSUFBQSxrQkFBQSxDQUE2QixDQUFDLEtBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxJQUFhLENBQUMsWUFBQSxJQUFnQixDQUFDLGdCQUFBLE1BQXNCLENBQUMsT0FBQSxHQUFVLENBQUMsUUFBQSxJQUFZLENBQUMsV0FBQSxJQUFBLDJCQUFBLENBQUEsQ0FBQSxJQUFBLHFDQUFBLENBQXNGLENBQUMsa0RBQUEsY0FBQSxDQUFxQyxXQUFBLElBQUEsa0JBQUEsQ0FBa0MsQ0FBQyxrREFBQSxNQUFBLENBQTZCLGlCQUFBLElBQUEsMkJBQUEsQ0FBaUQsQ0FBQyxrREFBQSxPQUFBLENBQThCLGlCQUFBLElBQUEsMEJBQUEsQ0FBZ0QsQ0FBQyxNQUFBLElBQUEsb0JBQUEsQ0FBK0IsQ0FBQyxvQ0FBQSxDQUFBLGlCQUFBLENBQTJCLEtBQUEsWUFBaUIsQ0FBQyxXQUFBLElBQWUsQ0FBQyxZQUFBLElBQWdCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiSW5mb0Jhci5zdmVsdGUiXX0= */");
}
var get_action_slot_changes = (dirty) => ({});
var get_action_slot_context = (ctx) => ({});
var get_icon_slot_changes2 = (dirty) => ({});
var get_icon_slot_context2 = (ctx) => ({});
function create_if_block10(ctx) {
  let div2;
  let div0;
  let t0;
  let div1;
  let t1;
  let t2;
  let t3;
  let div2_class_value;
  let forwardEvents_action;
  let div2_resize_listener;
  let current;
  let mounted;
  let dispose;
  const icon_slot_template = (
    /*#slots*/
    ctx[19].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_icon_slot_context2
  );
  const icon_slot_or_fallback = icon_slot || fallback_block3(ctx);
  let if_block0 = (
    /*title*/
    ctx[8] && create_if_block_43(ctx)
  );
  let if_block1 = (
    /*message*/
    (ctx[9] || /*$$slots*/
    ctx[17].default) && create_if_block_33(ctx)
  );
  let if_block2 = (
    /*$$slots*/
    ctx[17].action && create_if_block_24(ctx)
  );
  let if_block3 = (
    /*closable*/
    ctx[6] && create_if_block_19(ctx)
  );
  let div2_levels = [
    {
      class: div2_class_value = "info-bar severity-" + /*severity*/
      ctx[7] + " " + /*className*/
      ctx[10]
    },
    { role: "alert" },
    /*$$restProps*/
    ctx[16]
  ];
  let div2_data = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div2_data = assign(div2_data, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.c();
      t0 = space();
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, role: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t1 = claim_space(div1_nodes);
      if (if_block1)
        if_block1.l(div1_nodes);
      t2 = claim_space(div1_nodes);
      if (if_block2)
        if_block2.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t3 = claim_space(div2_nodes);
      if (if_block3)
        if_block3.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "info-bar-icon svelte-p86mq6");
      add_location(div0, file17, 60, 2, 2510);
      attr_dev(div1, "class", "info-bar-content svelte-p86mq6");
      toggle_class(
        div1,
        "wrapped",
        /*wrapped*/
        ctx[14]
      );
      toggle_class(
        div1,
        "action-visible",
        /*$$slots*/
        ctx[17].action
      );
      toggle_class(
        div1,
        "action-wrapped",
        /*actionWrapped*/
        ctx[13]
      );
      toggle_class(
        div1,
        "message-wrapped",
        /*messageWrapped*/
        ctx[12]
      );
      add_location(div1, file17, 65, 2, 2611);
      set_attributes(div2, div2_data);
      add_render_callback(() => (
        /*div2_elementresize_handler*/
        ctx[26].call(div2)
      ));
      toggle_class(div2, "svelte-p86mq6", true);
      add_location(div2, file17, 52, 1, 2353);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div0, null);
      }
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      append_hydration_dev(div1, t2);
      if (if_block2)
        if_block2.m(div1, null);
      append_hydration_dev(div2, t3);
      if (if_block3)
        if_block3.m(div2, null);
      ctx[25](div2);
      div2_resize_listener = add_resize_listener(
        div2,
        /*div2_elementresize_handler*/
        ctx[26].bind(div2)
      );
      current = true;
      if (!mounted) {
        dispose = action_destroyer(forwardEvents_action = /*forwardEvents*/
        ctx[15].call(null, div2));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_icon_slot_changes2
            ),
            get_icon_slot_context2
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & /*severity*/
        128)) {
          icon_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (
        /*title*/
        ctx2[8]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_43(ctx2);
          if_block0.c();
          if_block0.m(div1, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*message*/
        ctx2[9] || /*$$slots*/
        ctx2[17].default
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*message, $$slots*/
          131584) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_33(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[17].action
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          131072) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_24(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*$$slots*/
      131072) {
        toggle_class(
          div1,
          "action-visible",
          /*$$slots*/
          ctx2[17].action
        );
      }
      if (!current || dirty & /*actionWrapped*/
      8192) {
        toggle_class(
          div1,
          "action-wrapped",
          /*actionWrapped*/
          ctx2[13]
        );
      }
      if (!current || dirty & /*messageWrapped*/
      4096) {
        toggle_class(
          div1,
          "message-wrapped",
          /*messageWrapped*/
          ctx2[12]
        );
      }
      if (
        /*closable*/
        ctx2[6]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_19(ctx2);
          if_block3.c();
          if_block3.m(div2, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      set_attributes(div2, div2_data = get_spread_update(div2_levels, [
        (!current || dirty & /*severity, className*/
        1152 && div2_class_value !== (div2_class_value = "info-bar severity-" + /*severity*/
        ctx2[7] + " " + /*className*/
        ctx2[10])) && { class: div2_class_value },
        { role: "alert" },
        dirty & /*$$restProps*/
        65536 && /*$$restProps*/
        ctx2[16]
      ]));
      toggle_class(div2, "svelte-p86mq6", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot_or_fallback, local);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      ctx[25](null);
      div2_resize_listener();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(52:0) {#if open}",
    ctx
  });
  return block;
}
function fallback_block3(ctx) {
  let infobadge;
  let current;
  infobadge = new InfoBadge_default({
    props: { severity: (
      /*severity*/
      ctx[7]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(infobadge.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(infobadge.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(infobadge, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const infobadge_changes = {};
      if (dirty & /*severity*/
      128)
        infobadge_changes.severity = /*severity*/
        ctx2[7];
      infobadge.$set(infobadge_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(infobadge.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(infobadge.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(infobadge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block3.name,
    type: "fallback",
    source: "(62:21)      ",
    ctx
  });
  return block;
}
function create_if_block_43(ctx) {
  let h5;
  let t;
  const block = {
    c: function create() {
      h5 = element("h5");
      t = text(
        /*title*/
        ctx[8]
      );
      this.h();
    },
    l: function claim(nodes) {
      h5 = claim_element(nodes, "H5", { class: true });
      var h5_nodes = children(h5);
      t = claim_text(
        h5_nodes,
        /*title*/
        ctx[8]
      );
      h5_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h5, "class", "svelte-p86mq6");
      add_location(h5, file17, 73, 4, 2807);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h5, anchor);
      append_hydration_dev(h5, t);
      ctx[20](h5);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      256)
        set_data_dev(
          t,
          /*title*/
          ctx2[8]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h5);
      ctx[20](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_43.name,
    type: "if",
    source: "(73:3) {#if title}",
    ctx
  });
  return block;
}
function create_if_block_33(ctx) {
  let p;
  let t0;
  let t1;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  const block = {
    c: function create() {
      p = element("p");
      t0 = text(
        /*message*/
        ctx[9]
      );
      t1 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      t0 = claim_text(
        p_nodes,
        /*message*/
        ctx[9]
      );
      t1 = claim_space(p_nodes);
      if (default_slot)
        default_slot.l(p_nodes);
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(p, "class", "svelte-p86mq6");
      add_location(p, file17, 78, 4, 2909);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t0);
      append_hydration_dev(p, t1);
      if (default_slot) {
        default_slot.m(p, null);
      }
      ctx[21](p);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*message*/
      512)
        set_data_dev(
          t0,
          /*message*/
          ctx2[9]
        );
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
      if (default_slot)
        default_slot.d(detaching);
      ctx[21](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_33.name,
    type: "if",
    source: "(78:3) {#if message || $$slots.default}",
    ctx
  });
  return block;
}
function create_if_block_24(ctx) {
  let div;
  let current;
  const action_slot_template = (
    /*#slots*/
    ctx[19].action
  );
  const action_slot = create_slot(
    action_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_action_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (action_slot)
        action_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (action_slot)
        action_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "info-bar-action svelte-p86mq6");
      add_location(div, file17, 84, 4, 3015);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (action_slot) {
        action_slot.m(div, null);
      }
      ctx[22](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (action_slot) {
        if (action_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            action_slot,
            action_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              action_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_action_slot_changes
            ),
            get_action_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(action_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(action_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (action_slot)
        action_slot.d(detaching);
      ctx[22](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_24.name,
    type: "if",
    source: "(84:3) {#if $$slots.action}",
    ctx
  });
  return block;
}
function create_if_block_19(ctx) {
  let button;
  let svg;
  let path;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        class: true,
        type: true,
        "aria-label": true
      });
      var button_nodes = children(button);
      svg = claim_svg_element(button_nodes, "svg", {
        "aria-hidden": true,
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M512,584.5L87.5,1009C77.5,1019 65.5,1024 51.5,1024C36.8333,1024 24.5833,1019.08 14.75,1009.25C4.91667,999.417 0,987.167 0,972.5C0,958.5 5,946.5 15,936.5L439.5,512L15,87.5C5,77.5 0,65.3334 0,51C0,44 1.33333,37.3334 4,31C6.66667,24.6667 10.3333,19.25 15,14.75C19.6667,10.25 25.1667,6.66669 31.5,4C37.8333,1.33337 44.5,0 51.5,0C65.5,0 77.5,5 87.5,15L512,439.5L936.5,15C946.5,5 958.667,0 973,0C980,0 986.583,1.33337 992.75,4C998.917,6.66669 1004.33,10.3334 1009,15C1013.67,19.6667 1017.33,25.0834 1020,31.25C1022.67,37.4167 1024,44 1024,51C1024,65.3334 1019,77.5 1009,87.5L584.5,512L1009,936.5C1019,946.5 1024,958.5 1024,972.5C1024,979.5 1022.67,986.167 1020,992.5C1017.33,998.833 1013.75,1004.33 1009.25,1009C1004.75,1013.67 999.333,1017.33 993,1020C986.667,1022.67 980,1024 973,1024C958.667,1024 946.5,1019 936.5,1009Z");
      add_location(path, file17, 104, 5, 3453);
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "12");
      attr_dev(svg, "height", "12");
      attr_dev(svg, "viewBox", "0 0 1024 1024");
      attr_dev(svg, "class", "svelte-p86mq6");
      add_location(svg, file17, 97, 4, 3311);
      attr_dev(button, "class", "info-bar-close-button svelte-p86mq6");
      attr_dev(button, "type", "button");
      attr_dev(button, "aria-label", "Close");
      add_location(button, file17, 90, 3, 3148);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, svg);
      append_hydration_dev(svg, path);
      ctx[24](button);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[23],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      ctx[24](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_19.name,
    type: "if",
    source: "(90:2) {#if closable}",
    ctx
  });
  return block;
}
function create_fragment17(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*open*/
    ctx[0] && create_if_block10(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*open*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*open*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block10(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let actionWrapped;
  let messageWrapped;
  const omit_props_names = [
    "open",
    "closable",
    "severity",
    "title",
    "message",
    "class",
    "element",
    "titleElement",
    "messageElement",
    "actionElement",
    "closeButtonElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InfoBar", slots, ["icon", "default", "action"]);
  const $$slots = compute_slots(slots);
  let { open = true } = $$props;
  let { closable = true } = $$props;
  let { severity = "information" } = $$props;
  let { title = "" } = $$props;
  let { message = "" } = $$props;
  let { class: className = "" } = $$props;
  let { element: element2 = null } = $$props;
  let { titleElement = null } = $$props;
  let { messageElement = null } = $$props;
  let { actionElement = null } = $$props;
  let { closeButtonElement = null } = $$props;
  let wrapped = false;
  let clientHeight = 0;
  const dispatch = createEventDispatcher();
  const forwardEvents = createEventForwarder(get_current_component());
  function h5_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      titleElement = $$value;
      $$invalidate(1, titleElement);
    });
  }
  function p_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      messageElement = $$value;
      $$invalidate(2, messageElement);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      actionElement = $$value;
      $$invalidate(3, actionElement);
    });
  }
  const click_handler3 = () => $$invalidate(0, open = false);
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      closeButtonElement = $$value;
      $$invalidate(5, closeButtonElement);
    });
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(4, element2);
    });
  }
  function div2_elementresize_handler() {
    clientHeight = this.clientHeight;
    $$invalidate(11, clientHeight);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("closable" in $$new_props)
      $$invalidate(6, closable = $$new_props.closable);
    if ("severity" in $$new_props)
      $$invalidate(7, severity = $$new_props.severity);
    if ("title" in $$new_props)
      $$invalidate(8, title = $$new_props.title);
    if ("message" in $$new_props)
      $$invalidate(9, message = $$new_props.message);
    if ("class" in $$new_props)
      $$invalidate(10, className = $$new_props.class);
    if ("element" in $$new_props)
      $$invalidate(4, element2 = $$new_props.element);
    if ("titleElement" in $$new_props)
      $$invalidate(1, titleElement = $$new_props.titleElement);
    if ("messageElement" in $$new_props)
      $$invalidate(2, messageElement = $$new_props.messageElement);
    if ("actionElement" in $$new_props)
      $$invalidate(3, actionElement = $$new_props.actionElement);
    if ("closeButtonElement" in $$new_props)
      $$invalidate(5, closeButtonElement = $$new_props.closeButtonElement);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    get_current_component,
    createEventForwarder,
    InfoBadge: InfoBadge_default,
    open,
    closable,
    severity,
    title,
    message,
    className,
    element: element2,
    titleElement,
    messageElement,
    actionElement,
    closeButtonElement,
    wrapped,
    clientHeight,
    dispatch,
    forwardEvents,
    messageWrapped,
    actionWrapped
  });
  $$self.$inject_state = ($$new_props) => {
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("closable" in $$props)
      $$invalidate(6, closable = $$new_props.closable);
    if ("severity" in $$props)
      $$invalidate(7, severity = $$new_props.severity);
    if ("title" in $$props)
      $$invalidate(8, title = $$new_props.title);
    if ("message" in $$props)
      $$invalidate(9, message = $$new_props.message);
    if ("className" in $$props)
      $$invalidate(10, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(4, element2 = $$new_props.element);
    if ("titleElement" in $$props)
      $$invalidate(1, titleElement = $$new_props.titleElement);
    if ("messageElement" in $$props)
      $$invalidate(2, messageElement = $$new_props.messageElement);
    if ("actionElement" in $$props)
      $$invalidate(3, actionElement = $$new_props.actionElement);
    if ("closeButtonElement" in $$props)
      $$invalidate(5, closeButtonElement = $$new_props.closeButtonElement);
    if ("wrapped" in $$props)
      $$invalidate(14, wrapped = $$new_props.wrapped);
    if ("clientHeight" in $$props)
      $$invalidate(11, clientHeight = $$new_props.clientHeight);
    if ("messageWrapped" in $$props)
      $$invalidate(12, messageWrapped = $$new_props.messageWrapped);
    if ("actionWrapped" in $$props)
      $$invalidate(13, actionWrapped = $$new_props.actionWrapped);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*clientHeight, actionElement*/
    2056) {
      $:
        $$invalidate(13, actionWrapped = clientHeight && (actionElement === null || actionElement === void 0 ? void 0 : actionElement.offsetTop) > 0);
    }
    if ($$self.$$.dirty & /*clientHeight, messageElement, titleElement*/
    2054) {
      $:
        $$invalidate(12, messageWrapped = clientHeight && (messageElement === null || messageElement === void 0 ? void 0 : messageElement.offsetTop) > (titleElement === null || titleElement === void 0 ? void 0 : titleElement.offsetTop));
    }
    if ($$self.$$.dirty & /*open*/
    1) {
      $:
        if (open) {
          dispatch("open");
        } else {
          dispatch("close");
        }
    }
  };
  return [
    open,
    titleElement,
    messageElement,
    actionElement,
    element2,
    closeButtonElement,
    closable,
    severity,
    title,
    message,
    className,
    clientHeight,
    messageWrapped,
    actionWrapped,
    wrapped,
    forwardEvents,
    $$restProps,
    $$slots,
    $$scope,
    slots,
    h5_binding,
    p_binding,
    div_binding,
    click_handler3,
    button_binding,
    div2_binding,
    div2_elementresize_handler
  ];
}
var InfoBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance17,
      create_fragment17,
      safe_not_equal,
      {
        open: 0,
        closable: 6,
        severity: 7,
        title: 8,
        message: 9,
        class: 10,
        element: 4,
        titleElement: 1,
        messageElement: 2,
        actionElement: 3,
        closeButtonElement: 5
      },
      add_css17
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InfoBar",
      options,
      id: create_fragment17.name
    });
  }
  get open() {
    throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closable() {
    throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closable(value) {
    throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get severity() {
    throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set severity(value) {
    throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get message() {
    throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set message(value) {
    throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleElement() {
    throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleElement(value) {
    throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get messageElement() {
    throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set messageElement(value) {
    throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get actionElement() {
    throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set actionElement(value) {
    throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeButtonElement() {
    throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeButtonElement(value) {
    throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InfoBar_default = InfoBar;

// node_modules/fluent-svelte/NumberBox/NumberBox.svelte
var file18 = "node_modules\\fluent-svelte\\NumberBox\\NumberBox.svelte";
function add_css18(target) {
  append_styles(target, "svelte-11n91nk", ".number-box input{-webkit-appearance:textfield;-moz-appearance:textfield;appearance:textfield}.number-box input::-webkit-inner-spin-button,.number-box input::-webkit-outer-spin-button{-webkit-appearance:none;appearance:none;margin:0}.number-box-spinner-flyout.svelte-11n91nk{background-clip:padding-box;background-color:var(--fds-solid-background-quarternary);border:1px solid var(--fds-surface-stroke-flyout);border-radius:var(--fds-overlay-corner-radius);box-shadow:var(--fds-flyout-shadow);box-sizing:border-box;display:flex;flex-direction:column;inset-inline-end:-16px;padding:2px 4px;position:absolute;z-index:100}.number-box-spinner-flyout.svelte-11n91nk .number-box-spinner{block-size:36px;inline-size:36px;margin:2px 1px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTnVtYmVyQm94LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFnUFEsV0FBQSxBQUFBLENBQUEsQUFBQSxLQUFBLEFBQUEsQ0FBb0MsbUJBQUEsU0FBNEIsQ0FBQyxnQkFBQSxTQUF5QixDQUFDLFdBQUEsU0FBb0IsQ0FBQyxBQUFBLFdBQUEsQUFBQSxDQUFBLEFBQUEsZ0NBQUEsQUFBQSxDQUFBLEFBQUEsV0FBQSxBQUFBLENBQUEsQUFBQSxnQ0FBQSxBQUFBLENBQThILG1CQUFBLElBQXVCLENBQUMsV0FBQSxJQUFlLENBQUMsT0FBQSxDQUFRLENBQUMseUNBQUEsQ0FBMkIsZ0JBQUEsV0FBMkIsQ0FBQyxpQkFBQSxJQUFBLGtDQUFBLENBQXdELENBQUMsT0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsMkJBQUEsQ0FBaUQsQ0FBQyxjQUFBLElBQUEsMkJBQUEsQ0FBOEMsQ0FBQyxXQUFBLElBQUEsbUJBQUEsQ0FBbUMsQ0FBQyxXQUFBLFVBQXFCLENBQUMsUUFBQSxJQUFZLENBQUMsZUFBQSxNQUFxQixDQUFDLGlCQUFBLEtBQXNCLENBQUMsUUFBQSxHQUFBLENBQUEsR0FBZSxDQUFDLFNBQUEsUUFBaUIsQ0FBQyxRQUFBLEdBQVcsQ0FBQyx5Q0FBQSxDQUFBLEFBQUEsbUJBQUEsQUFBQSxDQUF3RCxXQUFBLElBQWUsQ0FBQyxZQUFBLElBQWdCLENBQUMsT0FBQSxHQUFBLENBQUEsR0FBYyxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIk51bWJlckJveC5zdmVsdGUiXX0= */");
}
var get_buttons_slot_changes2 = (dirty) => ({});
var get_buttons_slot_context2 = (ctx) => ({});
function create_default_slot_5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[24].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[56],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[56],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[56]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[56],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5.name,
    type: "slot",
    source: `(80:0) <TextBox  class=\\"number-box {className ?? ''}\\"  type=\\"number\\"  bind:inputElement  bind:containerElement  bind:buttonsContainerElement  bind:clearButtonElement  bind:value  on:outermousedown={() => (spinnerFlyoutOpen = false)}  on:change  on:input  on:beforeinput  on:click  on:blur  on:focus={() => (spinnerFlyoutOpen = true)}  on:focus  on:dblclick  on:contextmenu  on:mousedown  on:mouseup  on:mouseover  on:mouseout  on:mouseenter  on:mouseleave  on:keypress  on:keydown  on:keyup  on:clear  {min}  {max}  {step}  {disabled}  {...$$restProps} >`,
    ctx
  });
  return block;
}
function create_else_block4(ctx) {
  let textboxbutton;
  let t;
  let if_block_anchor;
  let current;
  textboxbutton = new TextBoxButton_default({
    props: {
      disabled: (
        /*disabled*/
        ctx[12]
      ),
      class: "number-box-spinner-compact",
      tabindex: "-1",
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  textboxbutton.$on(
    "mousedown",
    /*mousedown_handler_1*/
    ctx[27]
  );
  let if_block = (
    /*spinnerFlyoutOpen*/
    ctx[14] && create_if_block_25(ctx)
  );
  const block = {
    c: function create() {
      create_component(textboxbutton.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(textboxbutton.$$.fragment, nodes);
      t = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(textboxbutton, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const textboxbutton_changes = {};
      if (dirty[0] & /*disabled*/
      4096)
        textboxbutton_changes.disabled = /*disabled*/
        ctx2[12];
      if (dirty[1] & /*$$scope*/
      33554432) {
        textboxbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      textboxbutton.$set(textboxbutton_changes);
      if (
        /*spinnerFlyoutOpen*/
        ctx2[14]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*spinnerFlyoutOpen*/
          16384) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_25(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(textboxbutton.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(textboxbutton.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(textboxbutton, detaching);
      if (detaching)
        detach_dev(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(165:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block11(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*disabled*/
  ctx[12] && create_if_block_110(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!/*disabled*/
      ctx2[12]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*disabled*/
          4096) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_110(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(116:2) {#if inline}",
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        "aria-hidden": true,
        xmlns: true,
        height: true,
        width: true,
        viewBox: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M128,384C128,375.333 131.167,367.833 137.5,361.5L487,10.5C494,3.5 502.333,0 512,0C521.667,0 530,3.5 537,10.5L886.5,361.5C892.833,367.833 896,375.333 896,384C896,392.667 892.833,400.167 886.5,406.5C880.167,412.833 872.667,416 864,416C855.333,416 847.833,412.833 841.5,406.5L512,76L182.5,406.5C176.167,412.833 168.667,416 160,416C151.333,416 143.833,412.833 137.5,406.5C131.167,400.167 128,392.667 128,384ZM128,640C128,631.333 131.167,623.833 137.5,617.5C143.833,611.167 151.333,608 160,608C168.667,608 176.167,611.167 182.5,617.5L512,948L841.5,617.5C847.833,611.167 855.333,608 864,608C872.667,608 880.167,611.167 886.5,617.5C892.833,623.833 896,631.333 896,640C896,648.667 892.833,656.167 886.5,662.5L537,1013.5C530,1020.5 521.667,1024 512,1024C502.333,1024 494,1020.5 487,1013.5L137.5,662.5C131.167,656.167 128,648.667 128,640Z");
      add_location(path, file18, 178, 5, 6076);
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "height", "12");
      attr_dev(svg, "width", "100%");
      attr_dev(svg, "viewBox", "128 0 768 1024");
      add_location(svg, file18, 171, 4, 5931);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: '(166:3) <TextBoxButton     {disabled}     class=\\"number-box-spinner-compact\\"     tabindex=\\"-1\\"     on:mousedown={() => inputElement.focus()}    >',
    ctx
  });
  return block;
}
function create_if_block_25(ctx) {
  let div;
  let textboxbutton0;
  let updating_element;
  let t;
  let textboxbutton1;
  let updating_element_1;
  let current;
  function textboxbutton0_element_binding_1(value) {
    ctx[28](value);
  }
  let textboxbutton0_props = {
    class: "number-box-spinner",
    disabled: (
      /*spinUpButtonDisabled*/
      ctx[16]
    ),
    "aria-label": "Increase number",
    tabindex: "-1",
    $$slots: { default: [create_default_slot_3] },
    $$scope: { ctx }
  };
  if (
    /*spinUpButtonElement*/
    ctx[4] !== void 0
  ) {
    textboxbutton0_props.element = /*spinUpButtonElement*/
    ctx[4];
  }
  textboxbutton0 = new TextBoxButton_default({
    props: textboxbutton0_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(textboxbutton0, "element", textboxbutton0_element_binding_1));
  textboxbutton0.$on(
    "mousedown",
    /*spinUp*/
    ctx[17]
  );
  textboxbutton0.$on(
    "mouseup",
    /*stopSpinIntervals*/
    ctx[19]
  );
  textboxbutton0.$on(
    "mouseleave",
    /*stopSpinIntervals*/
    ctx[19]
  );
  function textboxbutton1_element_binding_1(value) {
    ctx[29](value);
  }
  let textboxbutton1_props = {
    tabindex: "-1",
    "aria-label": "Decrease number",
    class: "number-box-spinner",
    disabled: (
      /*spinDownButtonDisabled*/
      ctx[15]
    ),
    $$slots: { default: [create_default_slot_23] },
    $$scope: { ctx }
  };
  if (
    /*spinDownButtonElement*/
    ctx[6] !== void 0
  ) {
    textboxbutton1_props.element = /*spinDownButtonElement*/
    ctx[6];
  }
  textboxbutton1 = new TextBoxButton_default({
    props: textboxbutton1_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(textboxbutton1, "element", textboxbutton1_element_binding_1));
  textboxbutton1.$on(
    "mousedown",
    /*spinDown*/
    ctx[18]
  );
  textboxbutton1.$on(
    "mouseup",
    /*stopSpinIntervals*/
    ctx[19]
  );
  textboxbutton1.$on(
    "mouseleave",
    /*stopSpinIntervals*/
    ctx[19]
  );
  const block = {
    c: function create() {
      div = element("div");
      create_component(textboxbutton0.$$.fragment);
      t = space();
      create_component(textboxbutton1.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(textboxbutton0.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      claim_component(textboxbutton1.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "number-box-spinner-flyout svelte-11n91nk");
      add_location(div, file18, 185, 4, 7017);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(textboxbutton0, div, null);
      append_hydration_dev(div, t);
      mount_component(textboxbutton1, div, null);
      ctx[30](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const textboxbutton0_changes = {};
      if (dirty[0] & /*spinUpButtonDisabled*/
      65536)
        textboxbutton0_changes.disabled = /*spinUpButtonDisabled*/
        ctx2[16];
      if (dirty[1] & /*$$scope*/
      33554432) {
        textboxbutton0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_element && dirty[0] & /*spinUpButtonElement*/
      16) {
        updating_element = true;
        textboxbutton0_changes.element = /*spinUpButtonElement*/
        ctx2[4];
        add_flush_callback(() => updating_element = false);
      }
      textboxbutton0.$set(textboxbutton0_changes);
      const textboxbutton1_changes = {};
      if (dirty[0] & /*spinDownButtonDisabled*/
      32768)
        textboxbutton1_changes.disabled = /*spinDownButtonDisabled*/
        ctx2[15];
      if (dirty[1] & /*$$scope*/
      33554432) {
        textboxbutton1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_element_1 && dirty[0] & /*spinDownButtonElement*/
      64) {
        updating_element_1 = true;
        textboxbutton1_changes.element = /*spinDownButtonElement*/
        ctx2[6];
        add_flush_callback(() => updating_element_1 = false);
      }
      textboxbutton1.$set(textboxbutton1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(textboxbutton0.$$.fragment, local);
      transition_in(textboxbutton1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(textboxbutton0.$$.fragment, local);
      transition_out(textboxbutton1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(textboxbutton0);
      destroy_component(textboxbutton1);
      ctx[30](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_25.name,
    type: "if",
    source: "(185:3) {#if spinnerFlyoutOpen}",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        "aria-hidden": true,
        xmlns: true,
        width: true,
        height: true,
        viewBox: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M3.14645 10.3536C3.34171 10.5488 3.65829 10.5488 3.85355 10.3536L8 6.20711L12.1464 10.3536C12.3417 10.5488 12.6583 10.5488 12.8536 10.3536C13.0488 10.1583 13.0488 9.84171 12.8536 9.64645L8.35355 5.14645C8.15829 4.95118 7.84171 4.95118 7.64645 5.14645L3.14645 9.64645C2.95118 9.84171 2.95118 10.1583 3.14645 10.3536Z");
      add_location(path, file18, 203, 7, 7547);
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "16");
      attr_dev(svg, "height", "16");
      attr_dev(svg, "viewBox", "0 0 16 16");
      add_location(svg, file18, 196, 6, 7395);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: '(187:5) <TextBoxButton       on:mousedown={spinUp}       on:mouseup={stopSpinIntervals}       on:mouseleave={stopSpinIntervals}       bind:element={spinUpButtonElement}       class=\\"number-box-spinner\\"       disabled={spinUpButtonDisabled}       aria-label=\\"Increase number\\"       tabindex=\\"-1\\"      >',
    ctx
  });
  return block;
}
function create_default_slot_23(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        "aria-hidden": true,
        xmlns: true,
        width: true,
        height: true,
        viewBox: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M3.14645 5.64645C3.34171 5.45118 3.65829 5.45118 3.85355 5.64645L8 9.79289L12.1464 5.64645C12.3417 5.45118 12.6583 5.45118 12.8536 5.64645C13.0488 5.84171 13.0488 6.15829 12.8536 6.35355L8.35355 10.8536C8.15829 11.0488 7.84171 11.0488 7.64645 10.8536L3.14645 6.35355C2.95118 6.15829 2.95118 5.84171 3.14645 5.64645Z");
      add_location(path, file18, 226, 7, 8417);
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "16");
      attr_dev(svg, "height", "16");
      attr_dev(svg, "viewBox", "0 0 16 16");
      add_location(svg, file18, 219, 6, 8265);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_23.name,
    type: "slot",
    source: '(210:5) <TextBoxButton       on:mousedown={spinDown}       on:mouseup={stopSpinIntervals}       on:mouseleave={stopSpinIntervals}       bind:element={spinDownButtonElement}       tabindex=\\"-1\\"       aria-label=\\"Decrease number\\"       class=\\"number-box-spinner\\"       disabled={spinDownButtonDisabled}      >',
    ctx
  });
  return block;
}
function create_if_block_110(ctx) {
  let textboxbutton0;
  let updating_element;
  let t;
  let textboxbutton1;
  let updating_element_1;
  let current;
  function textboxbutton0_element_binding(value) {
    ctx[25](value);
  }
  let textboxbutton0_props = {
    tabindex: "-1",
    "aria-label": "Increase number",
    disabled: (
      /*spinUpButtonDisabled*/
      ctx[16]
    ),
    class: "number-box-spinner",
    $$slots: { default: [create_default_slot_13] },
    $$scope: { ctx }
  };
  if (
    /*spinUpButtonElement*/
    ctx[4] !== void 0
  ) {
    textboxbutton0_props.element = /*spinUpButtonElement*/
    ctx[4];
  }
  textboxbutton0 = new TextBoxButton_default({
    props: textboxbutton0_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(textboxbutton0, "element", textboxbutton0_element_binding));
  textboxbutton0.$on(
    "mousedown",
    /*spinUp*/
    ctx[17]
  );
  textboxbutton0.$on(
    "mouseup",
    /*stopSpinIntervals*/
    ctx[19]
  );
  textboxbutton0.$on(
    "mouseleave",
    /*stopSpinIntervals*/
    ctx[19]
  );
  function textboxbutton1_element_binding(value) {
    ctx[26](value);
  }
  let textboxbutton1_props = {
    tabindex: "-1",
    "aria-label": "Decrease number",
    class: "number-box-spinner",
    disabled: (
      /*spinDownButtonDisabled*/
      ctx[15]
    ),
    $$slots: { default: [create_default_slot4] },
    $$scope: { ctx }
  };
  if (
    /*spinDownButtonElement*/
    ctx[6] !== void 0
  ) {
    textboxbutton1_props.element = /*spinDownButtonElement*/
    ctx[6];
  }
  textboxbutton1 = new TextBoxButton_default({
    props: textboxbutton1_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(textboxbutton1, "element", textboxbutton1_element_binding));
  textboxbutton1.$on(
    "mousedown",
    /*spinDown*/
    ctx[18]
  );
  textboxbutton1.$on(
    "mouseup",
    /*stopSpinIntervals*/
    ctx[19]
  );
  textboxbutton1.$on(
    "mouseleave",
    /*stopSpinIntervals*/
    ctx[19]
  );
  const block = {
    c: function create() {
      create_component(textboxbutton0.$$.fragment);
      t = space();
      create_component(textboxbutton1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(textboxbutton0.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(textboxbutton1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(textboxbutton0, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(textboxbutton1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const textboxbutton0_changes = {};
      if (dirty[0] & /*spinUpButtonDisabled*/
      65536)
        textboxbutton0_changes.disabled = /*spinUpButtonDisabled*/
        ctx2[16];
      if (dirty[1] & /*$$scope*/
      33554432) {
        textboxbutton0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_element && dirty[0] & /*spinUpButtonElement*/
      16) {
        updating_element = true;
        textboxbutton0_changes.element = /*spinUpButtonElement*/
        ctx2[4];
        add_flush_callback(() => updating_element = false);
      }
      textboxbutton0.$set(textboxbutton0_changes);
      const textboxbutton1_changes = {};
      if (dirty[0] & /*spinDownButtonDisabled*/
      32768)
        textboxbutton1_changes.disabled = /*spinDownButtonDisabled*/
        ctx2[15];
      if (dirty[1] & /*$$scope*/
      33554432) {
        textboxbutton1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_element_1 && dirty[0] & /*spinDownButtonElement*/
      64) {
        updating_element_1 = true;
        textboxbutton1_changes.element = /*spinDownButtonElement*/
        ctx2[6];
        add_flush_callback(() => updating_element_1 = false);
      }
      textboxbutton1.$set(textboxbutton1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(textboxbutton0.$$.fragment, local);
      transition_in(textboxbutton1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(textboxbutton0.$$.fragment, local);
      transition_out(textboxbutton1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(textboxbutton0, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(textboxbutton1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_110.name,
    type: "if",
    source: "(117:3) {#if !disabled}",
    ctx
  });
  return block;
}
function create_default_slot_13(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        "aria-hidden": true,
        xmlns: true,
        width: true,
        height: true,
        viewBox: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M2.14645 7.35355C2.34171 7.54882 2.65829 7.54882 2.85355 7.35355L6 4.20711L9.14645 7.35355C9.34171 7.54882 9.65829 7.54882 9.85355 7.35355C10.0488 7.15829 10.0488 6.84171 9.85355 6.64645L6.35355 3.14645C6.15829 2.95118 5.84171 2.95118 5.64645 3.14645L2.14645 6.64645C1.95118 6.84171 1.95118 7.15829 2.14645 7.35355Z");
      add_location(path, file18, 134, 6, 4518);
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "12");
      attr_dev(svg, "height", "12");
      attr_dev(svg, "viewBox", "0 0 12 12");
      add_location(svg, file18, 127, 5, 4373);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_13.name,
    type: "slot",
    source: '(118:4) <TextBoxButton      on:mousedown={spinUp}      on:mouseup={stopSpinIntervals}      on:mouseleave={stopSpinIntervals}      bind:element={spinUpButtonElement}      tabindex=\\"-1\\"      aria-label=\\"Increase number\\"      disabled={spinUpButtonDisabled}      class=\\"number-box-spinner\\"     >',
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        "aria-hidden": true,
        xmlns: true,
        width: true,
        height: true,
        viewBox: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M2.14645 4.64645C2.34171 4.45118 2.65829 4.45118 2.85355 4.64645L6 7.79289L9.14645 4.64645C9.34171 4.45118 9.65829 4.45118 9.85355 4.64645C10.0488 4.84171 10.0488 5.15829 9.85355 5.35355L6.35355 8.85355C6.15829 9.04882 5.84171 9.04882 5.64645 8.85355L2.14645 5.35355C1.95118 5.15829 1.95118 4.84171 2.14645 4.64645Z");
      add_location(path, file18, 157, 6, 5365);
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "12");
      attr_dev(svg, "height", "12");
      attr_dev(svg, "viewBox", "0 0 12 12");
      add_location(svg, file18, 150, 5, 5220);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: '(141:4) <TextBoxButton      on:mousedown={spinDown}      on:mouseup={stopSpinIntervals}      on:mouseleave={stopSpinIntervals}      bind:element={spinDownButtonElement}      tabindex=\\"-1\\"      aria-label=\\"Decrease number\\"      class=\\"number-box-spinner\\"      disabled={spinDownButtonDisabled}     >',
    ctx
  });
  return block;
}
function create_buttons_slot2(ctx) {
  let current_block_type_index;
  let if_block;
  let t;
  let current;
  const if_block_creators = [create_if_block11, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*inline*/
      ctx2[8]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const buttons_slot_template = (
    /*#slots*/
    ctx[24].buttons
  );
  const buttons_slot = create_slot(
    buttons_slot_template,
    ctx,
    /*$$scope*/
    ctx[56],
    get_buttons_slot_context2
  );
  const block = {
    c: function create() {
      if_block.c();
      t = space();
      if (buttons_slot)
        buttons_slot.c();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      t = claim_space(nodes);
      if (buttons_slot)
        buttons_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (buttons_slot) {
        buttons_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t.parentNode, t);
      }
      if (buttons_slot) {
        if (buttons_slot.p && (!current || dirty[1] & /*$$scope*/
        33554432)) {
          update_slot_base(
            buttons_slot,
            buttons_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[56],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[56]
            ) : get_slot_changes(
              buttons_slot_template,
              /*$$scope*/
              ctx2[56],
              dirty,
              get_buttons_slot_changes2
            ),
            get_buttons_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(buttons_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(buttons_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(t);
      if (buttons_slot)
        buttons_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_buttons_slot2.name,
    type: "slot",
    source: '(115:1) <svelte:fragment slot=\\"buttons\\">',
    ctx
  });
  return block;
}
function create_fragment18(ctx) {
  let textbox;
  let updating_inputElement;
  let updating_containerElement;
  let updating_buttonsContainerElement;
  let updating_clearButtonElement;
  let updating_value;
  let current;
  let mounted;
  let dispose;
  const textbox_spread_levels = [
    {
      class: "number-box " + /*className*/
      (ctx[13] ?? "")
    },
    { type: "number" },
    { min: (
      /*min*/
      ctx[9]
    ) },
    { max: (
      /*max*/
      ctx[10]
    ) },
    { step: (
      /*step*/
      ctx[11]
    ) },
    { disabled: (
      /*disabled*/
      ctx[12]
    ) },
    /*$$restProps*/
    ctx[21]
  ];
  function textbox_inputElement_binding(value) {
    ctx[31](value);
  }
  function textbox_containerElement_binding(value) {
    ctx[32](value);
  }
  function textbox_buttonsContainerElement_binding(value) {
    ctx[33](value);
  }
  function textbox_clearButtonElement_binding(value) {
    ctx[34](value);
  }
  function textbox_value_binding(value) {
    ctx[35](value);
  }
  let textbox_props = {
    $$slots: {
      buttons: [create_buttons_slot2],
      default: [create_default_slot_5]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < textbox_spread_levels.length; i += 1) {
    textbox_props = assign(textbox_props, textbox_spread_levels[i]);
  }
  if (
    /*inputElement*/
    ctx[1] !== void 0
  ) {
    textbox_props.inputElement = /*inputElement*/
    ctx[1];
  }
  if (
    /*containerElement*/
    ctx[2] !== void 0
  ) {
    textbox_props.containerElement = /*containerElement*/
    ctx[2];
  }
  if (
    /*buttonsContainerElement*/
    ctx[3] !== void 0
  ) {
    textbox_props.buttonsContainerElement = /*buttonsContainerElement*/
    ctx[3];
  }
  if (
    /*clearButtonElement*/
    ctx[5] !== void 0
  ) {
    textbox_props.clearButtonElement = /*clearButtonElement*/
    ctx[5];
  }
  if (
    /*value*/
    ctx[0] !== void 0
  ) {
    textbox_props.value = /*value*/
    ctx[0];
  }
  textbox = new TextBox_default({ props: textbox_props, $$inline: true });
  binding_callbacks.push(() => bind(textbox, "inputElement", textbox_inputElement_binding));
  binding_callbacks.push(() => bind(textbox, "containerElement", textbox_containerElement_binding));
  binding_callbacks.push(() => bind(textbox, "buttonsContainerElement", textbox_buttonsContainerElement_binding));
  binding_callbacks.push(() => bind(textbox, "clearButtonElement", textbox_clearButtonElement_binding));
  binding_callbacks.push(() => bind(textbox, "value", textbox_value_binding));
  textbox.$on(
    "outermousedown",
    /*outermousedown_handler*/
    ctx[36]
  );
  textbox.$on(
    "change",
    /*change_handler*/
    ctx[37]
  );
  textbox.$on(
    "input",
    /*input_handler*/
    ctx[38]
  );
  textbox.$on(
    "beforeinput",
    /*beforeinput_handler*/
    ctx[39]
  );
  textbox.$on(
    "click",
    /*click_handler*/
    ctx[40]
  );
  textbox.$on(
    "blur",
    /*blur_handler*/
    ctx[41]
  );
  textbox.$on(
    "focus",
    /*focus_handler_1*/
    ctx[42]
  );
  textbox.$on(
    "focus",
    /*focus_handler*/
    ctx[43]
  );
  textbox.$on(
    "dblclick",
    /*dblclick_handler*/
    ctx[44]
  );
  textbox.$on(
    "contextmenu",
    /*contextmenu_handler*/
    ctx[45]
  );
  textbox.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[46]
  );
  textbox.$on(
    "mouseup",
    /*mouseup_handler*/
    ctx[47]
  );
  textbox.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[48]
  );
  textbox.$on(
    "mouseout",
    /*mouseout_handler*/
    ctx[49]
  );
  textbox.$on(
    "mouseenter",
    /*mouseenter_handler*/
    ctx[50]
  );
  textbox.$on(
    "mouseleave",
    /*mouseleave_handler*/
    ctx[51]
  );
  textbox.$on(
    "keypress",
    /*keypress_handler*/
    ctx[52]
  );
  textbox.$on(
    "keydown",
    /*keydown_handler*/
    ctx[53]
  );
  textbox.$on(
    "keyup",
    /*keyup_handler*/
    ctx[54]
  );
  textbox.$on(
    "clear",
    /*clear_handler*/
    ctx[55]
  );
  const block = {
    c: function create() {
      create_component(textbox.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(textbox.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(textbox, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window,
          "keydown",
          /*handleTabKey*/
          ctx[20],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const textbox_changes = dirty[0] & /*className, min, max, step, disabled, $$restProps*/
      2113024 ? get_spread_update(textbox_spread_levels, [
        dirty[0] & /*className*/
        8192 && {
          class: "number-box " + /*className*/
          (ctx2[13] ?? "")
        },
        textbox_spread_levels[1],
        dirty[0] & /*min*/
        512 && { min: (
          /*min*/
          ctx2[9]
        ) },
        dirty[0] & /*max*/
        1024 && { max: (
          /*max*/
          ctx2[10]
        ) },
        dirty[0] & /*step*/
        2048 && { step: (
          /*step*/
          ctx2[11]
        ) },
        dirty[0] & /*disabled*/
        4096 && { disabled: (
          /*disabled*/
          ctx2[12]
        ) },
        dirty[0] & /*$$restProps*/
        2097152 && get_spread_object(
          /*$$restProps*/
          ctx2[21]
        )
      ]) : {};
      if (dirty[0] & /*spinDownButtonDisabled, spinDownButtonElement, spinUpButtonDisabled, spinUpButtonElement, disabled, inline, spinnerFlyoutElement, spinnerFlyoutOpen, inputElement*/
      119250 | dirty[1] & /*$$scope*/
      33554432) {
        textbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inputElement && dirty[0] & /*inputElement*/
      2) {
        updating_inputElement = true;
        textbox_changes.inputElement = /*inputElement*/
        ctx2[1];
        add_flush_callback(() => updating_inputElement = false);
      }
      if (!updating_containerElement && dirty[0] & /*containerElement*/
      4) {
        updating_containerElement = true;
        textbox_changes.containerElement = /*containerElement*/
        ctx2[2];
        add_flush_callback(() => updating_containerElement = false);
      }
      if (!updating_buttonsContainerElement && dirty[0] & /*buttonsContainerElement*/
      8) {
        updating_buttonsContainerElement = true;
        textbox_changes.buttonsContainerElement = /*buttonsContainerElement*/
        ctx2[3];
        add_flush_callback(() => updating_buttonsContainerElement = false);
      }
      if (!updating_clearButtonElement && dirty[0] & /*clearButtonElement*/
      32) {
        updating_clearButtonElement = true;
        textbox_changes.clearButtonElement = /*clearButtonElement*/
        ctx2[5];
        add_flush_callback(() => updating_clearButtonElement = false);
      }
      if (!updating_value && dirty[0] & /*value*/
      1) {
        updating_value = true;
        textbox_changes.value = /*value*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      textbox.$set(textbox_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(textbox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(textbox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(textbox, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let spinUpButtonDisabled;
  let spinDownButtonDisabled;
  const omit_props_names = [
    "inline",
    "value",
    "min",
    "max",
    "step",
    "disabled",
    "class",
    "inputElement",
    "containerElement",
    "buttonsContainerElement",
    "spinUpButtonElement",
    "clearButtonElement",
    "spinDownButtonElement",
    "spinnerFlyoutElement",
    "stepUp",
    "stepDown"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NumberBox", slots, ["buttons", "default"]);
  let { inline = false } = $$props;
  let { value = "" } = $$props;
  let { min = void 0 } = $$props;
  let { max = void 0 } = $$props;
  let { step = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { class: className = "" } = $$props;
  let { inputElement = null } = $$props;
  let { containerElement = null } = $$props;
  let { buttonsContainerElement = null } = $$props;
  let { spinUpButtonElement = null } = $$props;
  let { clearButtonElement = null } = $$props;
  let { spinDownButtonElement = null } = $$props;
  let { spinnerFlyoutElement = null } = $$props;
  let spinUpTimeout;
  let spinDownTimeout;
  let spinUpInterval;
  let spinDownInterval;
  let spinnerFlyoutOpen = false;
  function spinUp() {
    stepUp();
    spinUpTimeout = setTimeout(
      () => {
        spinUpInterval = setInterval(
          () => {
            stepUp();
          },
          50
        );
      },
      500
    );
  }
  function spinDown() {
    stepDown();
    spinDownTimeout = setTimeout(
      () => {
        spinDownInterval = setInterval(
          () => {
            stepDown();
          },
          50
        );
      },
      500
    );
  }
  function stopSpinIntervals() {
    clearTimeout(spinUpTimeout);
    clearInterval(spinUpInterval);
    clearTimeout(spinDownTimeout);
    clearInterval(spinDownInterval);
  }
  function handleTabKey({ key }) {
    if (key === "Tab")
      $$invalidate(14, spinnerFlyoutOpen = false);
  }
  function stepUp() {
    inputElement.stepUp();
    $$invalidate(0, value = inputElement.value);
  }
  function stepDown() {
    inputElement.stepDown();
    $$invalidate(0, value = inputElement.value);
  }
  function textboxbutton0_element_binding(value2) {
    spinUpButtonElement = value2;
    $$invalidate(4, spinUpButtonElement);
  }
  function textboxbutton1_element_binding(value2) {
    spinDownButtonElement = value2;
    $$invalidate(6, spinDownButtonElement);
  }
  const mousedown_handler_1 = () => inputElement.focus();
  function textboxbutton0_element_binding_1(value2) {
    spinUpButtonElement = value2;
    $$invalidate(4, spinUpButtonElement);
  }
  function textboxbutton1_element_binding_1(value2) {
    spinDownButtonElement = value2;
    $$invalidate(6, spinDownButtonElement);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      spinnerFlyoutElement = $$value;
      $$invalidate(7, spinnerFlyoutElement);
    });
  }
  function textbox_inputElement_binding(value2) {
    inputElement = value2;
    $$invalidate(1, inputElement);
  }
  function textbox_containerElement_binding(value2) {
    containerElement = value2;
    $$invalidate(2, containerElement);
  }
  function textbox_buttonsContainerElement_binding(value2) {
    buttonsContainerElement = value2;
    $$invalidate(3, buttonsContainerElement);
  }
  function textbox_clearButtonElement_binding(value2) {
    clearButtonElement = value2;
    $$invalidate(5, clearButtonElement);
  }
  function textbox_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  const outermousedown_handler = () => $$invalidate(14, spinnerFlyoutOpen = false);
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function beforeinput_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler3(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const focus_handler_1 = () => $$invalidate(14, spinnerFlyoutOpen = true);
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function dblclick_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function contextmenu_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mousedown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseout_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keypress_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function clear_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(21, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("inline" in $$new_props)
      $$invalidate(8, inline = $$new_props.inline);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("min" in $$new_props)
      $$invalidate(9, min = $$new_props.min);
    if ("max" in $$new_props)
      $$invalidate(10, max = $$new_props.max);
    if ("step" in $$new_props)
      $$invalidate(11, step = $$new_props.step);
    if ("disabled" in $$new_props)
      $$invalidate(12, disabled = $$new_props.disabled);
    if ("class" in $$new_props)
      $$invalidate(13, className = $$new_props.class);
    if ("inputElement" in $$new_props)
      $$invalidate(1, inputElement = $$new_props.inputElement);
    if ("containerElement" in $$new_props)
      $$invalidate(2, containerElement = $$new_props.containerElement);
    if ("buttonsContainerElement" in $$new_props)
      $$invalidate(3, buttonsContainerElement = $$new_props.buttonsContainerElement);
    if ("spinUpButtonElement" in $$new_props)
      $$invalidate(4, spinUpButtonElement = $$new_props.spinUpButtonElement);
    if ("clearButtonElement" in $$new_props)
      $$invalidate(5, clearButtonElement = $$new_props.clearButtonElement);
    if ("spinDownButtonElement" in $$new_props)
      $$invalidate(6, spinDownButtonElement = $$new_props.spinDownButtonElement);
    if ("spinnerFlyoutElement" in $$new_props)
      $$invalidate(7, spinnerFlyoutElement = $$new_props.spinnerFlyoutElement);
    if ("$$scope" in $$new_props)
      $$invalidate(56, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    TextBox: TextBox_default,
    TextBoxButton: TextBoxButton_default,
    inline,
    value,
    min,
    max,
    step,
    disabled,
    className,
    inputElement,
    containerElement,
    buttonsContainerElement,
    spinUpButtonElement,
    clearButtonElement,
    spinDownButtonElement,
    spinnerFlyoutElement,
    spinUpTimeout,
    spinDownTimeout,
    spinUpInterval,
    spinDownInterval,
    spinnerFlyoutOpen,
    spinUp,
    spinDown,
    stopSpinIntervals,
    handleTabKey,
    stepUp,
    stepDown,
    spinDownButtonDisabled,
    spinUpButtonDisabled
  });
  $$self.$inject_state = ($$new_props) => {
    if ("inline" in $$props)
      $$invalidate(8, inline = $$new_props.inline);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("min" in $$props)
      $$invalidate(9, min = $$new_props.min);
    if ("max" in $$props)
      $$invalidate(10, max = $$new_props.max);
    if ("step" in $$props)
      $$invalidate(11, step = $$new_props.step);
    if ("disabled" in $$props)
      $$invalidate(12, disabled = $$new_props.disabled);
    if ("className" in $$props)
      $$invalidate(13, className = $$new_props.className);
    if ("inputElement" in $$props)
      $$invalidate(1, inputElement = $$new_props.inputElement);
    if ("containerElement" in $$props)
      $$invalidate(2, containerElement = $$new_props.containerElement);
    if ("buttonsContainerElement" in $$props)
      $$invalidate(3, buttonsContainerElement = $$new_props.buttonsContainerElement);
    if ("spinUpButtonElement" in $$props)
      $$invalidate(4, spinUpButtonElement = $$new_props.spinUpButtonElement);
    if ("clearButtonElement" in $$props)
      $$invalidate(5, clearButtonElement = $$new_props.clearButtonElement);
    if ("spinDownButtonElement" in $$props)
      $$invalidate(6, spinDownButtonElement = $$new_props.spinDownButtonElement);
    if ("spinnerFlyoutElement" in $$props)
      $$invalidate(7, spinnerFlyoutElement = $$new_props.spinnerFlyoutElement);
    if ("spinUpTimeout" in $$props)
      spinUpTimeout = $$new_props.spinUpTimeout;
    if ("spinDownTimeout" in $$props)
      spinDownTimeout = $$new_props.spinDownTimeout;
    if ("spinUpInterval" in $$props)
      spinUpInterval = $$new_props.spinUpInterval;
    if ("spinDownInterval" in $$props)
      spinDownInterval = $$new_props.spinDownInterval;
    if ("spinnerFlyoutOpen" in $$props)
      $$invalidate(14, spinnerFlyoutOpen = $$new_props.spinnerFlyoutOpen);
    if ("spinDownButtonDisabled" in $$props)
      $$invalidate(15, spinDownButtonDisabled = $$new_props.spinDownButtonDisabled);
    if ("spinUpButtonDisabled" in $$props)
      $$invalidate(16, spinUpButtonDisabled = $$new_props.spinUpButtonDisabled);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*value, max, min*/
    1537) {
      $:
        if ((value === null || value === void 0 ? void 0 : value.toString()) === (max === null || max === void 0 ? void 0 : max.toString()) || (value === null || value === void 0 ? void 0 : value.toString()) === (min === null || min === void 0 ? void 0 : min.toString()))
          stopSpinIntervals();
    }
    if ($$self.$$.dirty[0] & /*disabled, value, max*/
    5121) {
      $:
        $$invalidate(16, spinUpButtonDisabled = disabled || (value === null || value === void 0 ? void 0 : value.toString()) === (max === null || max === void 0 ? void 0 : max.toString()));
    }
    if ($$self.$$.dirty[0] & /*disabled, value, min*/
    4609) {
      $:
        $$invalidate(15, spinDownButtonDisabled = disabled || (value === null || value === void 0 ? void 0 : value.toString()) === (min === null || min === void 0 ? void 0 : min.toString()));
    }
  };
  return [
    value,
    inputElement,
    containerElement,
    buttonsContainerElement,
    spinUpButtonElement,
    clearButtonElement,
    spinDownButtonElement,
    spinnerFlyoutElement,
    inline,
    min,
    max,
    step,
    disabled,
    className,
    spinnerFlyoutOpen,
    spinDownButtonDisabled,
    spinUpButtonDisabled,
    spinUp,
    spinDown,
    stopSpinIntervals,
    handleTabKey,
    $$restProps,
    stepUp,
    stepDown,
    slots,
    textboxbutton0_element_binding,
    textboxbutton1_element_binding,
    mousedown_handler_1,
    textboxbutton0_element_binding_1,
    textboxbutton1_element_binding_1,
    div_binding,
    textbox_inputElement_binding,
    textbox_containerElement_binding,
    textbox_buttonsContainerElement_binding,
    textbox_clearButtonElement_binding,
    textbox_value_binding,
    outermousedown_handler,
    change_handler,
    input_handler,
    beforeinput_handler,
    click_handler3,
    blur_handler,
    focus_handler_1,
    focus_handler,
    dblclick_handler,
    contextmenu_handler,
    mousedown_handler,
    mouseup_handler,
    mouseover_handler,
    mouseout_handler,
    mouseenter_handler,
    mouseleave_handler,
    keypress_handler,
    keydown_handler,
    keyup_handler,
    clear_handler,
    $$scope
  ];
}
var NumberBox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance18,
      create_fragment18,
      safe_not_equal,
      {
        inline: 8,
        value: 0,
        min: 9,
        max: 10,
        step: 11,
        disabled: 12,
        class: 13,
        inputElement: 1,
        containerElement: 2,
        buttonsContainerElement: 3,
        spinUpButtonElement: 4,
        clearButtonElement: 5,
        spinDownButtonElement: 6,
        spinnerFlyoutElement: 7,
        stepUp: 22,
        stepDown: 23
      },
      add_css18,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NumberBox",
      options,
      id: create_fragment18.name
    });
  }
  get inline() {
    throw new Error("<NumberBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<NumberBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<NumberBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<NumberBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<NumberBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<NumberBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<NumberBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<NumberBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<NumberBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<NumberBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<NumberBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<NumberBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<NumberBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NumberBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<NumberBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value) {
    throw new Error("<NumberBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerElement() {
    throw new Error("<NumberBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerElement(value) {
    throw new Error("<NumberBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonsContainerElement() {
    throw new Error("<NumberBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonsContainerElement(value) {
    throw new Error("<NumberBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spinUpButtonElement() {
    throw new Error("<NumberBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spinUpButtonElement(value) {
    throw new Error("<NumberBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearButtonElement() {
    throw new Error("<NumberBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clearButtonElement(value) {
    throw new Error("<NumberBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spinDownButtonElement() {
    throw new Error("<NumberBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spinDownButtonElement(value) {
    throw new Error("<NumberBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spinnerFlyoutElement() {
    throw new Error("<NumberBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spinnerFlyoutElement(value) {
    throw new Error("<NumberBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stepUp() {
    return this.$$.ctx[22];
  }
  set stepUp(value) {
    throw new Error("<NumberBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stepDown() {
    return this.$$.ctx[23];
  }
  set stepDown(value) {
    throw new Error("<NumberBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NumberBox_default = NumberBox;

// node_modules/fluent-svelte/TextBlock/TextBlock.svelte
var file19 = "node_modules\\fluent-svelte\\TextBlock\\TextBlock.svelte";
function add_css19(target) {
  append_styles(target, "svelte-gpp4g7", ".text-block.svelte-gpp4g7{color:currentColor;display:inline-block;margin:0;padding:0}.text-block.type-display.svelte-gpp4g7,.text-block.type-subtitle.svelte-gpp4g7,.text-block.type-title.svelte-gpp4g7,.text-block.type-title-large.svelte-gpp4g7{font-family:var(--fds-font-family-display);font-weight:600}.text-block.type-body.svelte-gpp4g7,.text-block.type-body-large.svelte-gpp4g7,.text-block.type-body-strong.svelte-gpp4g7{font-family:var(--fds-font-family-text)}.text-block.type-caption.svelte-gpp4g7{font-family:var(--fds-font-family-small);font-size:var(--fds-caption-font-size);font-weight:400;line-height:16px}.text-block.type-body.svelte-gpp4g7,.text-block.type-body-large.svelte-gpp4g7,.text-block.type-body-strong.svelte-gpp4g7{font-size:var(--fds-body-font-size);font-weight:400;line-height:20px}.text-block.type-body-strong.svelte-gpp4g7{font-weight:600}.text-block.type-body-large.svelte-gpp4g7{font-size:var(--fds-body-large-font-size);line-height:24px}.text-block.type-subtitle.svelte-gpp4g7{font-size:var(--fds-subtitle-font-size);line-height:28px}.text-block.type-title.svelte-gpp4g7{font-size:var(--fds-title-font-size);line-height:36px}.text-block.type-title-large.svelte-gpp4g7{font-size:var(--fds-title-large-font-size);line-height:52px}.text-block.type-display.svelte-gpp4g7{font-size:var(--fds-display-font-size);line-height:92px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGV4dEJsb2NrLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFzRFEseUJBQUEsQ0FBWSxNQUFBLFlBQWtCLENBQUMsUUFBQSxZQUFvQixDQUFDLE9BQUEsQ0FBUSxDQUFDLFFBQUEsQ0FBUyxDQUFDLFdBQUEsMkJBQUEsQ0FBQSxXQUFBLDRCQUFBLENBQUEsV0FBQSx5QkFBQSxDQUFBLFdBQUEsK0JBQUEsQ0FBdUcsWUFBQSxJQUFBLHlCQUFBLENBQTBDLENBQUMsWUFBQSxHQUFlLENBQUMsV0FBQSx3QkFBQSxDQUFBLFdBQUEsOEJBQUEsQ0FBQSxXQUFBLCtCQUFBLENBQStFLFlBQUEsSUFBQSxzQkFBQSxDQUF1QyxDQUFDLFdBQUEsMkJBQUEsQ0FBeUIsWUFBQSxJQUFBLHVCQUFBLENBQXdDLENBQUMsVUFBQSxJQUFBLHVCQUFBLENBQXNDLENBQUMsWUFBQSxHQUFlLENBQUMsWUFBQSxJQUFnQixDQUFDLFdBQUEsd0JBQUEsQ0FBQSxXQUFBLDhCQUFBLENBQUEsV0FBQSwrQkFBQSxDQUErRSxVQUFBLElBQUEsb0JBQUEsQ0FBbUMsQ0FBQyxZQUFBLEdBQWUsQ0FBQyxZQUFBLElBQWdCLENBQUMsV0FBQSwrQkFBQSxDQUE2QixZQUFBLEdBQWUsQ0FBQyxXQUFBLDhCQUFBLENBQTRCLFVBQUEsSUFBQSwwQkFBQSxDQUF5QyxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxXQUFBLDRCQUFBLENBQTBCLFVBQUEsSUFBQSx3QkFBQSxDQUF1QyxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxXQUFBLHlCQUFBLENBQXVCLFVBQUEsSUFBQSxxQkFBQSxDQUFvQyxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxXQUFBLCtCQUFBLENBQTZCLFVBQUEsSUFBQSwyQkFBQSxDQUEwQyxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxXQUFBLDJCQUFBLENBQXlCLFVBQUEsSUFBQSx1QkFBQSxDQUFzQyxDQUFDLFlBQUEsSUFBZ0IsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJUZXh0QmxvY2suc3ZlbHRlIl19 */");
}
function create_dynamic_element2(ctx) {
  let svelte_element;
  let svelte_element_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let svelte_element_levels = [
    {
      class: svelte_element_class_value = "text-block type-" + /*map*/
      ctx[4][
        /*variant*/
        ctx[1]
      ].name + " " + /*className*/
      ctx[3]
    },
    /*$$restProps*/
    ctx[5]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*tag*/
        ctx[2] ? (
          /*tag*/
          ctx[2]
        ) : (
          /*map*/
          ctx[4][
            /*variant*/
            ctx[1]
          ].tag
        )
      );
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*tag*/
        ((ctx[2] ? (
          /*tag*/
          ctx[2]
        ) : (
          /*map*/
          ctx[4][
            /*variant*/
            ctx[1]
          ].tag
        )) || "null").toUpperCase(),
        { class: true }
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (/-/.test(
        /*tag*/
        ctx[2] ? (
          /*tag*/
          ctx[2]
        ) : (
          /*map*/
          ctx[4][
            /*variant*/
            ctx[1]
          ].tag
        )
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      toggle_class(svelte_element, "svelte-gpp4g7", true);
      add_location(svelte_element, file19, 45, 0, 1003);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      ctx[8](svelte_element);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty & /*variant, className*/
        10 && svelte_element_class_value !== (svelte_element_class_value = "text-block type-" + /*map*/
        ctx2[4][
          /*variant*/
          ctx2[1]
        ].name + " " + /*className*/
        ctx2[3])) && { class: svelte_element_class_value },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]);
      if (/-/.test(
        /*tag*/
        ctx2[2] ? (
          /*tag*/
          ctx2[2]
        ) : (
          /*map*/
          ctx2[4][
            /*variant*/
            ctx2[1]
          ].tag
        )
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      toggle_class(svelte_element, "svelte-gpp4g7", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if (default_slot)
        default_slot.d(detaching);
      ctx[8](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element2.name,
    type: "child_dynamic_element",
    source: '(46:0) <svelte:element  this={tag ? tag : map[variant].tag}  class=\\"text-block type-{map[variant].name} {className}\\"  bind:this={element}  {...$$restProps} >',
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let previous_tag = (
    /*tag*/
    ctx[2] ? (
      /*tag*/
      ctx[2]
    ) : (
      /*map*/
      ctx[4][
        /*variant*/
        ctx[1]
      ].tag
    )
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*tag*/
    ctx[2] ? (
      /*tag*/
      ctx[2]
    ) : (
      /*map*/
      ctx[4][
        /*variant*/
        ctx[1]
      ].tag
    )
  );
  validate_void_dynamic_element(
    /*tag*/
    ctx[2] ? (
      /*tag*/
      ctx[2]
    ) : (
      /*map*/
      ctx[4][
        /*variant*/
        ctx[1]
      ].tag
    )
  );
  let svelte_element = (
    /*tag*/
    (ctx[2] ? (
      /*tag*/
      ctx[2]
    ) : (
      /*map*/
      ctx[4][
        /*variant*/
        ctx[1]
      ].tag
    )) && create_dynamic_element2(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*tag*/
        ctx2[2] ? (
          /*tag*/
          ctx2[2]
        ) : (
          /*map*/
          ctx2[4][
            /*variant*/
            ctx2[1]
          ].tag
        )
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element2(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*tag*/
          ctx2[2] ? (
            /*tag*/
            ctx2[2]
          ) : (
            /*map*/
            ctx2[4][
              /*variant*/
              ctx2[1]
            ].tag
          )
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*tag*/
            ctx2[2] ? (
              /*tag*/
              ctx2[2]
            ) : (
              /*map*/
              ctx2[4][
                /*variant*/
                ctx2[1]
              ].tag
            )
          );
          validate_void_dynamic_element(
            /*tag*/
            ctx2[2] ? (
              /*tag*/
              ctx2[2]
            ) : (
              /*map*/
              ctx2[4][
                /*variant*/
                ctx2[1]
              ].tag
            )
          );
          svelte_element = create_dynamic_element2(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = /*tag*/
      ctx2[2] ? (
        /*tag*/
        ctx2[2]
      ) : (
        /*map*/
        ctx2[4][
          /*variant*/
          ctx2[1]
        ].tag
      );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  const omit_props_names = ["variant", "tag", "class", "element"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TextBlock", slots, ["default"]);
  let { variant = "body" } = $$props;
  let { tag = void 0 } = $$props;
  let { class: className = "" } = $$props;
  let { element: element2 = null } = $$props;
  const map = {
    caption: { tag: "span", name: "caption" },
    body: { tag: "span", name: "body" },
    bodyStrong: { tag: "h5", name: "body-strong" },
    bodyLarge: { tag: "h5", name: "body-large" },
    subtitle: { tag: "h4", name: "subtitle" },
    title: { tag: "h3", name: "title" },
    titleLarge: { tag: "h2", name: "title-large" },
    display: { tag: "h1", name: "display" }
  };
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("variant" in $$new_props)
      $$invalidate(1, variant = $$new_props.variant);
    if ("tag" in $$new_props)
      $$invalidate(2, tag = $$new_props.tag);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ variant, tag, className, element: element2, map });
  $$self.$inject_state = ($$new_props) => {
    if ("variant" in $$props)
      $$invalidate(1, variant = $$new_props.variant);
    if ("tag" in $$props)
      $$invalidate(2, tag = $$new_props.tag);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    variant,
    tag,
    className,
    map,
    $$restProps,
    $$scope,
    slots,
    svelte_element_binding
  ];
}
var TextBlock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, { variant: 1, tag: 2, class: 3, element: 0 }, add_css19);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TextBlock",
      options,
      id: create_fragment19.name
    });
  }
  get variant() {
    throw new Error("<TextBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<TextBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<TextBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<TextBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TextBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TextBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<TextBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<TextBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TextBlock_default = TextBlock;

// node_modules/fluent-svelte/ListItem/ListItem.svelte
var file20 = "node_modules\\fluent-svelte\\ListItem\\ListItem.svelte";
function add_css20(target) {
  append_styles(target, "svelte-nu1wmp", '.list-item.svelte-nu1wmp{align-items:center;background-color:var(--fds-subtle-fill-transparent);block-size:34px;border-radius:var(--fds-control-corner-radius);box-sizing:border-box;color:var(--fds-text-primary);cursor:default;display:flex;flex:0 0 auto;inline-size:calc(100% - 10px);margin:3px 5px;outline:none;padding-inline:12px;position:relative;text-decoration:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.list-item.svelte-nu1wmp:before{background-color:var(--fds-accent-default);block-size:16px;border-radius:3px;content:"";inline-size:3px;inset-inline-start:0;opacity:0;position:absolute;transform:scaleY(0);transition:transform var(--fds-control-fast-duration) var(--fds-control-fast-out-slow-in-easing)}.list-item.selected.svelte-nu1wmp:before{opacity:1;transform:scaleY(1)}.list-item.svelte-nu1wmp:focus-visible{box-shadow:var(--fds-focus-stroke)}.list-item.selected.svelte-nu1wmp,.list-item.svelte-nu1wmp:hover{background-color:var(--fds-subtle-fill-secondary)}.list-item.svelte-nu1wmp:active{background-color:var(--fds-subtle-fill-tertiary);color:var(--fds-text-secondary)}.list-item.svelte-nu1wmp:active:before{transform:scaleY(.625)}.list-item.disabled.svelte-nu1wmp{background-color:var(--fds-subtle-fill-transparent);color:var(--fds-text-disabled);pointer-events:none}.list-item.disabled.selected.svelte-nu1wmp{background-color:var(--fds-subtle-fill-secondary)}.list-item.disabled.selected.svelte-nu1wmp:before{background-color:var(--fds-accent-disabled)}.list-item.svelte-nu1wmp>svg{fill:currentColor;-webkit-margin-end:16px;block-size:auto;inline-size:16px;margin-inline-end:16px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGlzdEl0ZW0uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTRFUSx3QkFBQSxDQUFXLFlBQUEsTUFBa0IsQ0FBQyxpQkFBQSxJQUFBLDZCQUFBLENBQW1ELENBQUMsV0FBQSxJQUFlLENBQUMsY0FBQSxJQUFBLDJCQUFBLENBQThDLENBQUMsV0FBQSxVQUFxQixDQUFDLE1BQUEsSUFBQSxrQkFBQSxDQUE2QixDQUFDLE9BQUEsT0FBYyxDQUFDLFFBQUEsSUFBWSxDQUFDLEtBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxJQUFhLENBQUMsWUFBQSxLQUFBLElBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUE2QixDQUFDLE9BQUEsR0FBQSxDQUFBLEdBQWMsQ0FBQyxRQUFBLElBQVksQ0FBQyxlQUFBLElBQW1CLENBQUMsU0FBQSxRQUFpQixDQUFDLGdCQUFBLElBQW9CLENBQUMsb0JBQUEsSUFBd0IsQ0FBQyxpQkFBQSxJQUFxQixDQUFDLGdCQUFBLElBQW9CLENBQUMsWUFBQSxJQUFnQixDQUFDLHdCQUFBLE9BQUEsQ0FBa0IsaUJBQUEsSUFBQSxvQkFBQSxDQUEwQyxDQUFDLFdBQUEsSUFBZSxDQUFDLGNBQUEsR0FBaUIsQ0FBQyxRQUFBLEVBQVUsQ0FBQyxZQUFBLEdBQWUsQ0FBQyxtQkFBQSxDQUFvQixDQUFDLFFBQUEsQ0FBUyxDQUFDLFNBQUEsUUFBaUIsQ0FBQyxVQUFBLE9BQUEsQ0FBQSxDQUFtQixDQUFDLFdBQUEsU0FBQSxDQUFBLElBQUEsMkJBQUEsQ0FBQSxDQUFBLElBQUEscUNBQUEsQ0FBZ0csQ0FBQyxVQUFBLHVCQUFBLE9BQUEsQ0FBMkIsUUFBQSxDQUFTLENBQUMsVUFBQSxPQUFBLENBQUEsQ0FBbUIsQ0FBQyx3QkFBQSxjQUFBLENBQXlCLFdBQUEsSUFBQSxrQkFBQSxDQUFrQyxDQUFDLFVBQUEsdUJBQUEsQ0FBQSx3QkFBQSxNQUFBLENBQXFDLGlCQUFBLElBQUEsMkJBQUEsQ0FBaUQsQ0FBQyx3QkFBQSxPQUFBLENBQWtCLGlCQUFBLElBQUEsMEJBQUEsQ0FBZ0QsQ0FBQyxNQUFBLElBQUEsb0JBQUEsQ0FBK0IsQ0FBQyx3QkFBQSxPQUFBLE9BQUEsQ0FBeUIsVUFBQSxPQUFBLElBQUEsQ0FBc0IsQ0FBQyxVQUFBLHVCQUFBLENBQW9CLGlCQUFBLElBQUEsNkJBQUEsQ0FBbUQsQ0FBQyxNQUFBLElBQUEsbUJBQUEsQ0FBOEIsQ0FBQyxlQUFBLElBQW1CLENBQUMsVUFBQSxTQUFBLHVCQUFBLENBQTZCLGlCQUFBLElBQUEsMkJBQUEsQ0FBaUQsQ0FBQyxVQUFBLFNBQUEsdUJBQUEsT0FBQSxDQUFvQyxpQkFBQSxJQUFBLHFCQUFBLENBQTJDLENBQUMsd0JBQUEsQ0FBQSxBQUFBLEdBQUEsQUFBQSxDQUF3QixLQUFBLFlBQWlCLENBQUMsbUJBQUEsSUFBdUIsQ0FBQyxXQUFBLElBQWUsQ0FBQyxZQUFBLElBQWdCLENBQUMsa0JBQUEsSUFBc0IsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJMaXN0SXRlbS5zdmVsdGUiXX0= */');
}
var get_icon_slot_changes_1 = (dirty) => ({});
var get_icon_slot_context_1 = (ctx) => ({});
var get_icon_slot_changes3 = (dirty) => ({});
var get_icon_slot_context3 = (ctx) => ({});
function create_else_block5(ctx) {
  let li;
  let t;
  let textblock;
  let li_tabindex_value;
  let li_class_value;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const icon_slot_template = (
    /*#slots*/
    ctx[8].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_icon_slot_context_1
  );
  textblock = new TextBlock_default({
    props: {
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let li_levels = [
    {
      tabindex: li_tabindex_value = /*disabled*/
      ctx[2] ? -1 : 0
    },
    { "aria-selected": (
      /*selected*/
      ctx[1]
    ) },
    {
      class: li_class_value = "list-item " + /*className*/
      ctx[5]
    },
    { href: (
      /*href*/
      ctx[3]
    ) },
    { role: (
      /*role*/
      ctx[4]
    ) },
    /*$$restProps*/
    ctx[7]
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if (icon_slot)
        icon_slot.c();
      t = space();
      create_component(textblock.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {
        tabindex: true,
        "aria-selected": true,
        class: true,
        href: true,
        role: true
      });
      var li_nodes = children(li);
      if (icon_slot)
        icon_slot.l(li_nodes);
      t = claim_space(li_nodes);
      claim_component(textblock.$$.fragment, li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(li, li_data);
      toggle_class(
        li,
        "selected",
        /*selected*/
        ctx[1]
      );
      toggle_class(
        li,
        "disabled",
        /*disabled*/
        ctx[2]
      );
      toggle_class(li, "svelte-nu1wmp", true);
      add_location(li, file20, 56, 1, 1898);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (icon_slot) {
        icon_slot.m(li, null);
      }
      append_hydration_dev(li, t);
      mount_component(textblock, li, null);
      ctx[10](li);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[6].call(null, li)),
          listen_dev(li, "keydown", handleKeyDown, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_icon_slot_changes_1
            ),
            get_icon_slot_context_1
          );
        }
      }
      const textblock_changes = {};
      if (dirty & /*$$scope*/
      2048) {
        textblock_changes.$$scope = { dirty, ctx: ctx2 };
      }
      textblock.$set(textblock_changes);
      set_attributes(li, li_data = get_spread_update(li_levels, [
        (!current || dirty & /*disabled*/
        4 && li_tabindex_value !== (li_tabindex_value = /*disabled*/
        ctx2[2] ? -1 : 0)) && { tabindex: li_tabindex_value },
        (!current || dirty & /*selected*/
        2) && { "aria-selected": (
          /*selected*/
          ctx2[1]
        ) },
        (!current || dirty & /*className*/
        32 && li_class_value !== (li_class_value = "list-item " + /*className*/
        ctx2[5])) && { class: li_class_value },
        (!current || dirty & /*href*/
        8) && { href: (
          /*href*/
          ctx2[3]
        ) },
        (!current || dirty & /*role*/
        16) && { role: (
          /*role*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
      toggle_class(
        li,
        "selected",
        /*selected*/
        ctx2[1]
      );
      toggle_class(
        li,
        "disabled",
        /*disabled*/
        ctx2[2]
      );
      toggle_class(li, "svelte-nu1wmp", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(textblock.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot, local);
      transition_out(textblock.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (icon_slot)
        icon_slot.d(detaching);
      destroy_component(textblock);
      ctx[10](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block5.name,
    type: "else",
    source: "(56:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block12(ctx) {
  let a;
  let t;
  let textblock;
  let a_tabindex_value;
  let a_class_value;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const icon_slot_template = (
    /*#slots*/
    ctx[8].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_icon_slot_context3
  );
  textblock = new TextBlock_default({
    props: {
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let a_levels = [
    {
      tabindex: a_tabindex_value = /*disabled*/
      ctx[2] ? -1 : 0
    },
    { "aria-selected": (
      /*selected*/
      ctx[1]
    ) },
    {
      class: a_class_value = "list-item " + /*className*/
      ctx[5]
    },
    { href: (
      /*href*/
      ctx[3]
    ) },
    { role: (
      /*role*/
      ctx[4]
    ) },
    /*$$restProps*/
    ctx[7]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (icon_slot)
        icon_slot.c();
      t = space();
      create_component(textblock.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", {
        tabindex: true,
        "aria-selected": true,
        class: true,
        href: true,
        role: true
      });
      var a_nodes = children(a);
      if (icon_slot)
        icon_slot.l(a_nodes);
      t = claim_space(a_nodes);
      claim_component(textblock.$$.fragment, a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      toggle_class(
        a,
        "selected",
        /*selected*/
        ctx[1]
      );
      toggle_class(
        a,
        "disabled",
        /*disabled*/
        ctx[2]
      );
      toggle_class(a, "svelte-nu1wmp", true);
      add_location(a, file20, 37, 1, 1581);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (icon_slot) {
        icon_slot.m(a, null);
      }
      append_hydration_dev(a, t);
      mount_component(textblock, a, null);
      ctx[9](a);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[6].call(null, a)),
          listen_dev(a, "keydown", handleKeyDown, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_icon_slot_changes3
            ),
            get_icon_slot_context3
          );
        }
      }
      const textblock_changes = {};
      if (dirty & /*$$scope*/
      2048) {
        textblock_changes.$$scope = { dirty, ctx: ctx2 };
      }
      textblock.$set(textblock_changes);
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*disabled*/
        4 && a_tabindex_value !== (a_tabindex_value = /*disabled*/
        ctx2[2] ? -1 : 0)) && { tabindex: a_tabindex_value },
        (!current || dirty & /*selected*/
        2) && { "aria-selected": (
          /*selected*/
          ctx2[1]
        ) },
        (!current || dirty & /*className*/
        32 && a_class_value !== (a_class_value = "list-item " + /*className*/
        ctx2[5])) && { class: a_class_value },
        (!current || dirty & /*href*/
        8) && { href: (
          /*href*/
          ctx2[3]
        ) },
        (!current || dirty & /*role*/
        16) && { role: (
          /*role*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
      toggle_class(
        a,
        "selected",
        /*selected*/
        ctx2[1]
      );
      toggle_class(
        a,
        "disabled",
        /*disabled*/
        ctx2[2]
      );
      toggle_class(a, "svelte-nu1wmp", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(textblock.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot, local);
      transition_out(textblock.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (icon_slot)
        icon_slot.d(detaching);
      destroy_component(textblock);
      ctx[9](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block12.name,
    type: "if",
    source: "(37:0) {#if href && !disabled}",
    ctx
  });
  return block;
}
function create_default_slot_14(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_14.name,
    type: "slot",
    source: "(71:2) <TextBlock>",
    ctx
  });
  return block;
}
function create_default_slot5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: "(52:2) <TextBlock>",
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block12, create_else_block5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*href*/
      ctx2[3] && !/*disabled*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function handleKeyDown({ key, target }) {
  if (key === "Enter")
    target.click();
}
function instance20($$self, $$props, $$invalidate) {
  const omit_props_names = ["selected", "disabled", "href", "role", "class", "element"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListItem", slots, ["icon", "default"]);
  let { selected = false } = $$props;
  let { disabled = false } = $$props;
  let { href = "" } = $$props;
  let { role = "listitem" } = $$props;
  let { class: className = "" } = $$props;
  let { element: element2 = null } = $$props;
  const forwardEvents = createEventForwarder(get_current_component(), ["select"]);
  const dispatch = createEventDispatcher();
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selected" in $$new_props)
      $$invalidate(1, selected = $$new_props.selected);
    if ("disabled" in $$new_props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("href" in $$new_props)
      $$invalidate(3, href = $$new_props.href);
    if ("role" in $$new_props)
      $$invalidate(4, role = $$new_props.role);
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    get_current_component,
    createEventForwarder,
    TextBlock: TextBlock_default,
    selected,
    disabled,
    href,
    role,
    className,
    element: element2,
    forwardEvents,
    dispatch,
    handleKeyDown
  });
  $$self.$inject_state = ($$new_props) => {
    if ("selected" in $$props)
      $$invalidate(1, selected = $$new_props.selected);
    if ("disabled" in $$props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("href" in $$props)
      $$invalidate(3, href = $$new_props.href);
    if ("role" in $$props)
      $$invalidate(4, role = $$new_props.role);
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*selected*/
    2) {
      $:
        if (selected)
          dispatch("select");
    }
  };
  return [
    element2,
    selected,
    disabled,
    href,
    role,
    className,
    forwardEvents,
    $$restProps,
    slots,
    a_binding,
    li_binding,
    $$scope
  ];
}
var ListItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance20,
      create_fragment20,
      safe_not_equal,
      {
        selected: 1,
        disabled: 2,
        href: 3,
        role: 4,
        class: 5,
        element: 0
      },
      add_css20
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListItem",
      options,
      id: create_fragment20.name
    });
  }
  get selected() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get role() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set role(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListItem_default = ListItem;

// node_modules/fluent-svelte/AutoSuggestBox/AutoSuggestBox.svelte
var file21 = "node_modules\\fluent-svelte\\AutoSuggestBox\\AutoSuggestBox.svelte";
function add_css21(target) {
  append_styles(target, "svelte-1x8syqx", '.auto-suggest-box-flyout.svelte-1x8syqx{background-clip:padding-box;background-color:var(--fds-solid-background-quarternary);border:1px solid var(--fds-surface-stroke-flyout);border-end-end-radius:0;border-end-start-radius:0;border-radius:var(--fds-overlay-corner-radius);box-shadow:var(--fds-flyout-shadow);box-sizing:border-box;color:var(--fds-text-primary);inline-size:calc(100% + 2px);inset-block-start:calc(100% + 1px);inset-inline-start:-1px;margin:0;max-block-size:472px;overflow:auto;padding:0;padding-block:2px;position:absolute;z-index:100}.auto-suggest-item-wrapper.svelte-1x8syqx{display:block}.auto-suggest-box.open{background-color:var(--fds-control-fill-input-active)!important}.auto-suggest-box.open .text-box-underline:after{border-bottom:2px solid var(--fds-accent-default);content:""}.auto-suggest-box.open input::-moz-placeholder{color:var(--fds-text-tertiary)}.auto-suggest-box.open input:-ms-input-placeholder{color:var(--fds-text-tertiary)}.auto-suggest-box.open input::placeholder{color:var(--fds-text-tertiary)}.auto-suggest-box.open .text-box-underline{border-bottom-left-radius:0;border-bottom-right-radius:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXV0b1N1Z2dlc3RCb3guc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTRKUSx1Q0FBQSxDQUF5QixnQkFBQSxXQUEyQixDQUFDLGlCQUFBLElBQUEsa0NBQUEsQ0FBd0QsQ0FBQyxPQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSwyQkFBQSxDQUFpRCxDQUFDLHNCQUFBLENBQXVCLENBQUMsd0JBQUEsQ0FBeUIsQ0FBQyxjQUFBLElBQUEsMkJBQUEsQ0FBOEMsQ0FBQyxXQUFBLElBQUEsbUJBQUEsQ0FBbUMsQ0FBQyxXQUFBLFVBQXFCLENBQUMsTUFBQSxJQUFBLGtCQUFBLENBQTZCLENBQUMsWUFBQSxLQUFBLElBQUEsQ0FBQSxDQUFBLENBQUEsR0FBQSxDQUE0QixDQUFDLGtCQUFBLEtBQUEsSUFBQSxDQUFBLENBQUEsQ0FBQSxHQUFBLENBQWtDLENBQUMsbUJBQUEsSUFBdUIsQ0FBQyxPQUFBLENBQVEsQ0FBQyxlQUFBLEtBQW9CLENBQUMsU0FBQSxJQUFhLENBQUMsUUFBQSxDQUFTLENBQUMsY0FBQSxHQUFpQixDQUFDLFNBQUEsUUFBaUIsQ0FBQyxRQUFBLEdBQVcsQ0FBQyx5Q0FBQSxDQUEyQixRQUFBLEtBQWEsQ0FBQyxBQUFBLHNCQUFBLEFBQUEsQ0FBZ0MsaUJBQUEsSUFBQSwrQkFBQSxDQUFBLFVBQStELENBQUMsQUFBQSxzQkFBQSxBQUFBLENBQUEsQUFBQSx5QkFBQSxBQUFBLENBQW1FLGNBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLG9CQUFBLENBQWlELENBQUMsUUFBQSxFQUFVLENBQUMsQUFBQSxzQkFBQSxBQUFBLENBQUEsQUFBQSx1QkFBQSxBQUFBLENBQWlFLE1BQUEsSUFBQSxtQkFBQSxDQUE4QixDQUFDLEFBQUEsc0JBQUEsQUFBQSxDQUFBLEFBQUEsMkJBQUEsQUFBQSxDQUFxRSxNQUFBLElBQUEsbUJBQUEsQ0FBOEIsQ0FBQyxBQUFBLHNCQUFBLEFBQUEsQ0FBQSxBQUFBLGtCQUFBLEFBQUEsQ0FBNEQsTUFBQSxJQUFBLG1CQUFBLENBQThCLENBQUMsQUFBQSxzQkFBQSxBQUFBLENBQUEsQUFBQSxtQkFBQSxBQUFBLENBQTZELDBCQUFBLENBQTJCLENBQUMsMkJBQUEsQ0FBNEIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJBdXRvU3VnZ2VzdEJveC5zdmVsdGUiXX0= */');
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[54] = list[i];
  child_ctx[56] = i;
  return child_ctx;
}
var get_item_template_slot_changes = (dirty) => ({
  id: dirty[0] & /*matches*/
  8,
  value: dirty[0] & /*value*/
  2,
  matches: dirty[0] & /*matches*/
  8,
  selection: dirty[0] & /*selection*/
  1,
  item: dirty[0] & /*matches*/
  8,
  index: dirty[0] & /*matches*/
  8
});
var get_item_template_slot_context = (ctx) => ({
  id: (
    /*flyoutId*/
    ctx[14] + "-item-" + /*index*/
    ctx[56]
  ),
  value: (
    /*value*/
    ctx[1]
  ),
  matches: (
    /*matches*/
    ctx[3]
  ),
  selection: (
    /*selection*/
    ctx[0]
  ),
  item: (
    /*item*/
    ctx[54]
  ),
  index: (
    /*index*/
    ctx[56]
  )
});
var get_buttons_slot_changes3 = (dirty) => ({});
var get_buttons_slot_context3 = (ctx) => ({ slot: "buttons" });
function create_if_block13(ctx) {
  let ul;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = (
    /*matches*/
    ctx[3]
  );
  validate_each_argument(each_value);
  const get_key = (ctx2) => (
    /*item*/
    ctx2[54]
  );
  validate_each_keys(ctx, each_value, get_each_context2, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  const block = {
    c: function create() {
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", { id: true, role: true, class: true });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        ul,
        "id",
        /*flyoutId*/
        ctx[14]
      );
      attr_dev(ul, "role", "listbox");
      attr_dev(ul, "class", "auto-suggest-box-flyout svelte-1x8syqx");
      add_location(ul, file21, 123, 2, 4089);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
      ctx[20](ul);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*flyoutId, matches, selection, value, open*/
      16399 | dirty[1] & /*$$scope*/
      1048576) {
        each_value = /*matches*/
        ctx2[3];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context2, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block2, null, get_each_context2);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[20](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block13.name,
    type: "if",
    source: "(123:1) {#if open && matches.length > 0}",
    ctx
  });
  return block;
}
function create_default_slot_15(ctx) {
  let t_value = (
    /*item*/
    ctx[54] + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*matches*/
      8 && t_value !== (t_value = /*item*/
      ctx2[54] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_15.name,
    type: "slot",
    source: '(136:6) <ListItem        tabindex={-1}        id=\\"{flyoutId}-item-{index}\\"        role=\\"option\\"        on:click={() => {         value = matches[selection];         selection = index;         open = false;        }}        selected={selection === index}>',
    ctx
  });
  return block;
}
function fallback_block4(ctx) {
  let listitem;
  let current;
  function click_handler_13() {
    return (
      /*click_handler_1*/
      ctx[19](
        /*index*/
        ctx[56]
      )
    );
  }
  listitem = new ListItem_default({
    props: {
      tabindex: -1,
      id: (
        /*flyoutId*/
        ctx[14] + "-item-" + /*index*/
        ctx[56]
      ),
      role: "option",
      selected: (
        /*selection*/
        ctx[0] === /*index*/
        ctx[56]
      ),
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  listitem.$on("click", click_handler_13);
  const block = {
    c: function create() {
      create_component(listitem.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(listitem.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(listitem, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const listitem_changes = {};
      if (dirty[0] & /*matches*/
      8)
        listitem_changes.id = /*flyoutId*/
        ctx[14] + "-item-" + /*index*/
        ctx[56];
      if (dirty[0] & /*selection, matches*/
      9)
        listitem_changes.selected = /*selection*/
        ctx[0] === /*index*/
        ctx[56];
      if (dirty[0] & /*matches*/
      8 | dirty[1] & /*$$scope*/
      1048576) {
        listitem_changes.$$scope = { dirty, ctx };
      }
      listitem.$set(listitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(listitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(listitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block4.name,
    type: "fallback",
    source: "(135:6)        ",
    ctx
  });
  return block;
}
function create_each_block2(key_1, ctx) {
  let div;
  let t;
  let current;
  const item_template_slot_template = (
    /*#slots*/
    ctx[18]["item-template"]
  );
  const item_template_slot = create_slot(
    item_template_slot_template,
    ctx,
    /*$$scope*/
    ctx[51],
    get_item_template_slot_context
  );
  const item_template_slot_or_fallback = item_template_slot || fallback_block4(ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      div = element("div");
      if (item_template_slot_or_fallback)
        item_template_slot_or_fallback.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (item_template_slot_or_fallback)
        item_template_slot_or_fallback.l(div_nodes);
      t = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "auto-suggest-item-wrapper svelte-1x8syqx");
      add_location(div, file21, 125, 4, 4226);
      this.first = div;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (item_template_slot_or_fallback) {
        item_template_slot_or_fallback.m(div, null);
      }
      append_hydration_dev(div, t);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (item_template_slot) {
        if (item_template_slot.p && (!current || dirty[0] & /*matches, value, selection*/
        11 | dirty[1] & /*$$scope*/
        1048576)) {
          update_slot_base(
            item_template_slot,
            item_template_slot_template,
            ctx,
            /*$$scope*/
            ctx[51],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[51]
            ) : get_slot_changes(
              item_template_slot_template,
              /*$$scope*/
              ctx[51],
              dirty,
              get_item_template_slot_changes
            ),
            get_item_template_slot_context
          );
        }
      } else {
        if (item_template_slot_or_fallback && item_template_slot_or_fallback.p && (!current || dirty[0] & /*matches, selection, value, open*/
        15)) {
          item_template_slot_or_fallback.p(ctx, !current ? [-1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(item_template_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(item_template_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (item_template_slot_or_fallback)
        item_template_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(125:3) {#each matches as item, index (item)}",
    ctx
  });
  return block;
}
function create_default_slot6(ctx) {
  let t;
  let current;
  let if_block = (
    /*open*/
    ctx[2] && /*matches*/
    ctx[3].length > 0 && create_if_block13(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[51],
    null
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*open*/
        ctx2[2] && /*matches*/
        ctx2[3].length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*open, matches*/
          12) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[51],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[51]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[51],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: '(75:0) <TextBox  type=\\"search\\"  class=\\"auto-suggest-box {open && matches.length > 0 ? \'open\' : \'\'} {className}\\"  aria-autocomplete=\\"list\\"  aria-activedescendant={open && matches.length > 0   ? `${flyoutId}-item-${items.indexOf(matches[selection])}`   : \\"\\"}  aria-expanded={open && matches.length > 0}  aria-controls={flyoutId}  on:search={() => {   if (open && matches.length > 0) value = matches[selection];  }}  on:search  on:input  on:input={handleInput}  on:outermousedown={() => (open = false)}  on:focus={() => (focused = true)}  on:focus  on:blur={() => (focused = false)}  on:blur  on:keydown={handleKeyDown}  on:keydown  on:change  on:beforeinput  on:click  on:dblclick  on:contextmenu  on:mousedown  on:mouseup  on:mouseover  on:mouseout  on:mouseenter  on:mouseleave  on:keypress  on:keyup  on:clear={() => {   typedValue = \\"\\";   if (items.length > 0) open = true;  }}  on:clear  bind:inputElement  bind:containerElement  bind:clearButtonElement  bind:searchButtonElement  bind:buttonsContainerElement  bind:value  {...$$restProps} >',
    ctx
  });
  return block;
}
function create_buttons_slot3(ctx) {
  let current;
  const buttons_slot_template = (
    /*#slots*/
    ctx[18].buttons
  );
  const buttons_slot = create_slot(
    buttons_slot_template,
    ctx,
    /*$$scope*/
    ctx[51],
    get_buttons_slot_context3
  );
  const block = {
    c: function create() {
      if (buttons_slot)
        buttons_slot.c();
    },
    l: function claim(nodes) {
      if (buttons_slot)
        buttons_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (buttons_slot) {
        buttons_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (buttons_slot) {
        if (buttons_slot.p && (!current || dirty[1] & /*$$scope*/
        1048576)) {
          update_slot_base(
            buttons_slot,
            buttons_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[51],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[51]
            ) : get_slot_changes(
              buttons_slot_template,
              /*$$scope*/
              ctx2[51],
              dirty,
              get_buttons_slot_changes3
            ),
            get_buttons_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(buttons_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(buttons_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (buttons_slot)
        buttons_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_buttons_slot3.name,
    type: "slot",
    source: "(154:1) ",
    ctx
  });
  return block;
}
function create_fragment21(ctx) {
  let textbox;
  let updating_inputElement;
  let updating_containerElement;
  let updating_clearButtonElement;
  let updating_searchButtonElement;
  let updating_buttonsContainerElement;
  let updating_value;
  let current;
  const textbox_spread_levels = [
    { type: "search" },
    {
      class: "auto-suggest-box " + /*open*/
      (ctx[2] && /*matches*/
      ctx[3].length > 0 ? "open" : "") + " " + /*className*/
      ctx[11]
    },
    { "aria-autocomplete": "list" },
    {
      "aria-activedescendant": (
        /*open*/
        ctx[2] && /*matches*/
        ctx[3].length > 0 ? `${/*flyoutId*/
        ctx[14]}-item-${/*items*/
        ctx[10].indexOf(
          /*matches*/
          ctx[3][
            /*selection*/
            ctx[0]
          ]
        )}` : ""
      )
    },
    {
      "aria-expanded": (
        /*open*/
        ctx[2] && /*matches*/
        ctx[3].length > 0
      )
    },
    { "aria-controls": (
      /*flyoutId*/
      ctx[14]
    ) },
    /*$$restProps*/
    ctx[17]
  ];
  function textbox_inputElement_binding(value) {
    ctx[21](value);
  }
  function textbox_containerElement_binding(value) {
    ctx[22](value);
  }
  function textbox_clearButtonElement_binding(value) {
    ctx[23](value);
  }
  function textbox_searchButtonElement_binding(value) {
    ctx[24](value);
  }
  function textbox_buttonsContainerElement_binding(value) {
    ctx[25](value);
  }
  function textbox_value_binding(value) {
    ctx[26](value);
  }
  let textbox_props = {
    $$slots: {
      buttons: [create_buttons_slot3],
      default: [create_default_slot6]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < textbox_spread_levels.length; i += 1) {
    textbox_props = assign(textbox_props, textbox_spread_levels[i]);
  }
  if (
    /*inputElement*/
    ctx[4] !== void 0
  ) {
    textbox_props.inputElement = /*inputElement*/
    ctx[4];
  }
  if (
    /*containerElement*/
    ctx[5] !== void 0
  ) {
    textbox_props.containerElement = /*containerElement*/
    ctx[5];
  }
  if (
    /*clearButtonElement*/
    ctx[7] !== void 0
  ) {
    textbox_props.clearButtonElement = /*clearButtonElement*/
    ctx[7];
  }
  if (
    /*searchButtonElement*/
    ctx[8] !== void 0
  ) {
    textbox_props.searchButtonElement = /*searchButtonElement*/
    ctx[8];
  }
  if (
    /*buttonsContainerElement*/
    ctx[6] !== void 0
  ) {
    textbox_props.buttonsContainerElement = /*buttonsContainerElement*/
    ctx[6];
  }
  if (
    /*value*/
    ctx[1] !== void 0
  ) {
    textbox_props.value = /*value*/
    ctx[1];
  }
  textbox = new TextBox_default({ props: textbox_props, $$inline: true });
  binding_callbacks.push(() => bind(textbox, "inputElement", textbox_inputElement_binding));
  binding_callbacks.push(() => bind(textbox, "containerElement", textbox_containerElement_binding));
  binding_callbacks.push(() => bind(textbox, "clearButtonElement", textbox_clearButtonElement_binding));
  binding_callbacks.push(() => bind(textbox, "searchButtonElement", textbox_searchButtonElement_binding));
  binding_callbacks.push(() => bind(textbox, "buttonsContainerElement", textbox_buttonsContainerElement_binding));
  binding_callbacks.push(() => bind(textbox, "value", textbox_value_binding));
  textbox.$on(
    "search",
    /*search_handler_1*/
    ctx[27]
  );
  textbox.$on(
    "search",
    /*search_handler*/
    ctx[28]
  );
  textbox.$on(
    "input",
    /*input_handler*/
    ctx[29]
  );
  textbox.$on(
    "input",
    /*handleInput*/
    ctx[15]
  );
  textbox.$on(
    "outermousedown",
    /*outermousedown_handler*/
    ctx[30]
  );
  textbox.$on(
    "focus",
    /*focus_handler_1*/
    ctx[31]
  );
  textbox.$on(
    "focus",
    /*focus_handler*/
    ctx[32]
  );
  textbox.$on(
    "blur",
    /*blur_handler_1*/
    ctx[33]
  );
  textbox.$on(
    "blur",
    /*blur_handler*/
    ctx[34]
  );
  textbox.$on(
    "keydown",
    /*handleKeyDown*/
    ctx[16]
  );
  textbox.$on(
    "keydown",
    /*keydown_handler*/
    ctx[35]
  );
  textbox.$on(
    "change",
    /*change_handler*/
    ctx[36]
  );
  textbox.$on(
    "beforeinput",
    /*beforeinput_handler*/
    ctx[37]
  );
  textbox.$on(
    "click",
    /*click_handler*/
    ctx[38]
  );
  textbox.$on(
    "dblclick",
    /*dblclick_handler*/
    ctx[39]
  );
  textbox.$on(
    "contextmenu",
    /*contextmenu_handler*/
    ctx[40]
  );
  textbox.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[41]
  );
  textbox.$on(
    "mouseup",
    /*mouseup_handler*/
    ctx[42]
  );
  textbox.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[43]
  );
  textbox.$on(
    "mouseout",
    /*mouseout_handler*/
    ctx[44]
  );
  textbox.$on(
    "mouseenter",
    /*mouseenter_handler*/
    ctx[45]
  );
  textbox.$on(
    "mouseleave",
    /*mouseleave_handler*/
    ctx[46]
  );
  textbox.$on(
    "keypress",
    /*keypress_handler*/
    ctx[47]
  );
  textbox.$on(
    "keyup",
    /*keyup_handler*/
    ctx[48]
  );
  textbox.$on(
    "clear",
    /*clear_handler_1*/
    ctx[49]
  );
  textbox.$on(
    "clear",
    /*clear_handler*/
    ctx[50]
  );
  const block = {
    c: function create() {
      create_component(textbox.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(textbox.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(textbox, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const textbox_changes = dirty[0] & /*open, matches, className, flyoutId, items, selection, $$restProps*/
      150541 ? get_spread_update(textbox_spread_levels, [
        textbox_spread_levels[0],
        dirty[0] & /*open, matches, className*/
        2060 && {
          class: "auto-suggest-box " + /*open*/
          (ctx2[2] && /*matches*/
          ctx2[3].length > 0 ? "open" : "") + " " + /*className*/
          ctx2[11]
        },
        textbox_spread_levels[2],
        dirty[0] & /*open, matches, flyoutId, items, selection*/
        17421 && {
          "aria-activedescendant": (
            /*open*/
            ctx2[2] && /*matches*/
            ctx2[3].length > 0 ? `${/*flyoutId*/
            ctx2[14]}-item-${/*items*/
            ctx2[10].indexOf(
              /*matches*/
              ctx2[3][
                /*selection*/
                ctx2[0]
              ]
            )}` : ""
          )
        },
        dirty[0] & /*open, matches*/
        12 && {
          "aria-expanded": (
            /*open*/
            ctx2[2] && /*matches*/
            ctx2[3].length > 0
          )
        },
        dirty[0] & /*flyoutId*/
        16384 && { "aria-controls": (
          /*flyoutId*/
          ctx2[14]
        ) },
        dirty[0] & /*$$restProps*/
        131072 && get_spread_object(
          /*$$restProps*/
          ctx2[17]
        )
      ]) : {};
      if (dirty[0] & /*flyoutElement, matches, selection, value, open*/
      527 | dirty[1] & /*$$scope*/
      1048576) {
        textbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inputElement && dirty[0] & /*inputElement*/
      16) {
        updating_inputElement = true;
        textbox_changes.inputElement = /*inputElement*/
        ctx2[4];
        add_flush_callback(() => updating_inputElement = false);
      }
      if (!updating_containerElement && dirty[0] & /*containerElement*/
      32) {
        updating_containerElement = true;
        textbox_changes.containerElement = /*containerElement*/
        ctx2[5];
        add_flush_callback(() => updating_containerElement = false);
      }
      if (!updating_clearButtonElement && dirty[0] & /*clearButtonElement*/
      128) {
        updating_clearButtonElement = true;
        textbox_changes.clearButtonElement = /*clearButtonElement*/
        ctx2[7];
        add_flush_callback(() => updating_clearButtonElement = false);
      }
      if (!updating_searchButtonElement && dirty[0] & /*searchButtonElement*/
      256) {
        updating_searchButtonElement = true;
        textbox_changes.searchButtonElement = /*searchButtonElement*/
        ctx2[8];
        add_flush_callback(() => updating_searchButtonElement = false);
      }
      if (!updating_buttonsContainerElement && dirty[0] & /*buttonsContainerElement*/
      64) {
        updating_buttonsContainerElement = true;
        textbox_changes.buttonsContainerElement = /*buttonsContainerElement*/
        ctx2[6];
        add_flush_callback(() => updating_buttonsContainerElement = false);
      }
      if (!updating_value && dirty[0] & /*value*/
      2) {
        updating_value = true;
        textbox_changes.value = /*value*/
        ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      textbox.$set(textbox_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(textbox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(textbox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(textbox, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "value",
    "items",
    "open",
    "selection",
    "matches",
    "class",
    "inputElement",
    "containerElement",
    "buttonsContainerElement",
    "clearButtonElement",
    "searchButtonElement",
    "flyoutElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AutoSuggestBox", slots, ["buttons", "item-template", "default"]);
  let { value = "" } = $$props;
  let { items = [] } = $$props;
  let { open = false } = $$props;
  let { selection = 0 } = $$props;
  let { matches = [] } = $$props;
  let { class: className = "" } = $$props;
  let { inputElement = null } = $$props;
  let { containerElement = null } = $$props;
  let { buttonsContainerElement = null } = $$props;
  let { clearButtonElement = null } = $$props;
  let { searchButtonElement = null } = $$props;
  let { flyoutElement = null } = $$props;
  let focused = false;
  let typedValue = "";
  const dispatch = createEventDispatcher();
  const flyoutId = uid("fds-auto-suggest-flyout-");
  function dispatchSelect() {
    dispatch("select", { item: items[selection], index: selection });
  }
  function handleInput() {
    $$invalidate(12, typedValue = inputElement.value);
    if (focused && value && items.length > 0)
      $$invalidate(2, open = true);
  }
  function handleKeyDown2(event2) {
    const { key } = event2;
    if (open && matches.length > 0) {
      if (key === "ArrowDown") {
        $$invalidate(0, selection++, selection);
        if (selection > matches.length - 1)
          $$invalidate(0, selection = 0);
      } else if (key === "ArrowUp") {
        $$invalidate(0, selection--, selection);
        if (selection < 0)
          $$invalidate(0, selection = matches.length - 1);
      } else if (key === "Enter" || key === "Escape") {
        $$invalidate(2, open = false);
      }
      if (key === "Enter" || key === "ArrowDown" || key === "ArrowUp") {
        event2.preventDefault();
        $$invalidate(1, value = matches[selection]);
        flyoutElement === null || flyoutElement === void 0 ? void 0 : flyoutElement.children[selection].scrollIntoView({ block: "nearest" });
      }
    } else if (!open && matches.length > 0 && (key === "ArrowDown" || key === "ArrowUp")) {
      $$invalidate(2, open = true);
    }
  }
  const click_handler_13 = (index) => {
    $$invalidate(1, value = matches[selection]);
    $$invalidate(0, selection = index);
    $$invalidate(2, open = false);
  };
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      flyoutElement = $$value;
      $$invalidate(9, flyoutElement);
    });
  }
  function textbox_inputElement_binding(value2) {
    inputElement = value2;
    $$invalidate(4, inputElement);
  }
  function textbox_containerElement_binding(value2) {
    containerElement = value2;
    $$invalidate(5, containerElement);
  }
  function textbox_clearButtonElement_binding(value2) {
    clearButtonElement = value2;
    $$invalidate(7, clearButtonElement);
  }
  function textbox_searchButtonElement_binding(value2) {
    searchButtonElement = value2;
    $$invalidate(8, searchButtonElement);
  }
  function textbox_buttonsContainerElement_binding(value2) {
    buttonsContainerElement = value2;
    $$invalidate(6, buttonsContainerElement);
  }
  function textbox_value_binding(value$1) {
    value = value$1;
    $$invalidate(1, value);
  }
  const search_handler_1 = () => {
    if (open && matches.length > 0)
      $$invalidate(1, value = matches[selection]);
  };
  function search_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const outermousedown_handler = () => $$invalidate(2, open = false);
  const focus_handler_1 = () => $$invalidate(13, focused = true);
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const blur_handler_1 = () => $$invalidate(13, focused = false);
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function beforeinput_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler3(event2) {
    bubble.call(this, $$self, event2);
  }
  function dblclick_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function contextmenu_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mousedown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseout_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keypress_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const clear_handler_1 = () => {
    $$invalidate(12, typedValue = "");
    if (items.length > 0)
      $$invalidate(2, open = true);
  };
  function clear_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("items" in $$new_props)
      $$invalidate(10, items = $$new_props.items);
    if ("open" in $$new_props)
      $$invalidate(2, open = $$new_props.open);
    if ("selection" in $$new_props)
      $$invalidate(0, selection = $$new_props.selection);
    if ("matches" in $$new_props)
      $$invalidate(3, matches = $$new_props.matches);
    if ("class" in $$new_props)
      $$invalidate(11, className = $$new_props.class);
    if ("inputElement" in $$new_props)
      $$invalidate(4, inputElement = $$new_props.inputElement);
    if ("containerElement" in $$new_props)
      $$invalidate(5, containerElement = $$new_props.containerElement);
    if ("buttonsContainerElement" in $$new_props)
      $$invalidate(6, buttonsContainerElement = $$new_props.buttonsContainerElement);
    if ("clearButtonElement" in $$new_props)
      $$invalidate(7, clearButtonElement = $$new_props.clearButtonElement);
    if ("searchButtonElement" in $$new_props)
      $$invalidate(8, searchButtonElement = $$new_props.searchButtonElement);
    if ("flyoutElement" in $$new_props)
      $$invalidate(9, flyoutElement = $$new_props.flyoutElement);
    if ("$$scope" in $$new_props)
      $$invalidate(51, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    uid,
    TextBox: TextBox_default,
    ListItem: ListItem_default,
    value,
    items,
    open,
    selection,
    matches,
    className,
    inputElement,
    containerElement,
    buttonsContainerElement,
    clearButtonElement,
    searchButtonElement,
    flyoutElement,
    focused,
    typedValue,
    dispatch,
    flyoutId,
    dispatchSelect,
    handleInput,
    handleKeyDown: handleKeyDown2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(1, value = $$new_props.value);
    if ("items" in $$props)
      $$invalidate(10, items = $$new_props.items);
    if ("open" in $$props)
      $$invalidate(2, open = $$new_props.open);
    if ("selection" in $$props)
      $$invalidate(0, selection = $$new_props.selection);
    if ("matches" in $$props)
      $$invalidate(3, matches = $$new_props.matches);
    if ("className" in $$props)
      $$invalidate(11, className = $$new_props.className);
    if ("inputElement" in $$props)
      $$invalidate(4, inputElement = $$new_props.inputElement);
    if ("containerElement" in $$props)
      $$invalidate(5, containerElement = $$new_props.containerElement);
    if ("buttonsContainerElement" in $$props)
      $$invalidate(6, buttonsContainerElement = $$new_props.buttonsContainerElement);
    if ("clearButtonElement" in $$props)
      $$invalidate(7, clearButtonElement = $$new_props.clearButtonElement);
    if ("searchButtonElement" in $$props)
      $$invalidate(8, searchButtonElement = $$new_props.searchButtonElement);
    if ("flyoutElement" in $$props)
      $$invalidate(9, flyoutElement = $$new_props.flyoutElement);
    if ("focused" in $$props)
      $$invalidate(13, focused = $$new_props.focused);
    if ("typedValue" in $$props)
      $$invalidate(12, typedValue = $$new_props.typedValue);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*items, typedValue*/
    5120) {
      $:
        $$invalidate(3, matches = items.filter((item) => item.toLowerCase().includes(typedValue.toLowerCase())));
    }
    if ($$self.$$.dirty[0] & /*selection*/
    1) {
      $:
        selection, dispatchSelect();
    }
  };
  return [
    selection,
    value,
    open,
    matches,
    inputElement,
    containerElement,
    buttonsContainerElement,
    clearButtonElement,
    searchButtonElement,
    flyoutElement,
    items,
    className,
    typedValue,
    focused,
    flyoutId,
    handleInput,
    handleKeyDown2,
    $$restProps,
    slots,
    click_handler_13,
    ul_binding,
    textbox_inputElement_binding,
    textbox_containerElement_binding,
    textbox_clearButtonElement_binding,
    textbox_searchButtonElement_binding,
    textbox_buttonsContainerElement_binding,
    textbox_value_binding,
    search_handler_1,
    search_handler,
    input_handler,
    outermousedown_handler,
    focus_handler_1,
    focus_handler,
    blur_handler_1,
    blur_handler,
    keydown_handler,
    change_handler,
    beforeinput_handler,
    click_handler3,
    dblclick_handler,
    contextmenu_handler,
    mousedown_handler,
    mouseup_handler,
    mouseover_handler,
    mouseout_handler,
    mouseenter_handler,
    mouseleave_handler,
    keypress_handler,
    keyup_handler,
    clear_handler_1,
    clear_handler,
    $$scope
  ];
}
var AutoSuggestBox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance21,
      create_fragment21,
      safe_not_equal,
      {
        value: 1,
        items: 10,
        open: 2,
        selection: 0,
        matches: 3,
        class: 11,
        inputElement: 4,
        containerElement: 5,
        buttonsContainerElement: 6,
        clearButtonElement: 7,
        searchButtonElement: 8,
        flyoutElement: 9
      },
      add_css21,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AutoSuggestBox",
      options,
      id: create_fragment21.name
    });
  }
  get value() {
    throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selection() {
    throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selection(value) {
    throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get matches() {
    throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set matches(value) {
    throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value) {
    throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerElement() {
    throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerElement(value) {
    throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonsContainerElement() {
    throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonsContainerElement(value) {
    throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearButtonElement() {
    throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clearButtonElement(value) {
    throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searchButtonElement() {
    throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searchButtonElement(value) {
    throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flyoutElement() {
    throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flyoutElement(value) {
    throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AutoSuggestBox_default = AutoSuggestBox;

// node_modules/fluent-svelte/Slider/Slider.svelte
var { window: window_1 } = globals;
var file22 = "node_modules\\fluent-svelte\\Slider\\Slider.svelte";
function add_css22(target) {
  append_styles(target, "svelte-5zuroa", '.slider.svelte-5zuroa.svelte-5zuroa{align-items:center;border-radius:var(--fds-control-corner-radius);display:flex;justify-content:center;min-block-size:32px;min-inline-size:32px;position:relative}.slider.svelte-5zuroa>*{direction:ltr}.slider.svelte-5zuroa.svelte-5zuroa:focus-visible{box-shadow:var(--fds-focus-stroke);outline:none}.slider-thumb.svelte-5zuroa:active .slider-tooltip,.slider.svelte-5zuroa:active .slider-tooltip,.slider.svelte-5zuroa:focus-visible .slider-tooltip{opacity:1}.slider.orientation-horizontal.svelte-5zuroa.svelte-5zuroa{block-size:32px;inline-size:100%}.slider.orientation-horizontal.svelte-5zuroa .slider-rail.svelte-5zuroa{block-size:4px;inline-size:100%;justify-content:flex-start}.slider.orientation-horizontal.svelte-5zuroa .slider-track.svelte-5zuroa{block-size:100%;inline-size:var(--fds-slider-percentage)}.slider.orientation-horizontal.svelte-5zuroa .slider-thumb.svelte-5zuroa{inset-inline-start:calc(var(--fds-slider-percentage) + var(--fds-slider-thumb-offset));transform:translateX(-50%)}.slider.orientation-horizontal.svelte-5zuroa .slider-tick.svelte-5zuroa{flex-direction:column;height:100%;inset-inline-start:var(--fds-slider-tick-percentage);padding:6px 0}.slider.orientation-horizontal.svelte-5zuroa .slider-tick.svelte-5zuroa:after,.slider.orientation-horizontal.svelte-5zuroa .slider-tick.svelte-5zuroa:before{-webkit-border-start:1px solid var(--fds-control-strong-fill-default);border-inline-start:1px solid var(--fds-control-strong-fill-default);height:4px;width:1px}.slider.orientation-horizontal.reverse.svelte-5zuroa .slider-rail.svelte-5zuroa{justify-content:flex-end}.slider.orientation-horizontal.reverse.svelte-5zuroa .slider-thumb.svelte-5zuroa{inset-inline-end:calc(var(--fds-slider-percentage) + var(--fds-slider-thumb-offset));inset-inline-start:unset;transform:translateX(50%)}.slider.orientation-horizontal.reverse.svelte-5zuroa .slider-tick.svelte-5zuroa{inset-inline-end:var(--fds-slider-tick-percentage);inset-inline-start:unset}.slider.orientation-vertical.svelte-5zuroa.svelte-5zuroa{block-size:100%;inline-size:32px}.slider.orientation-vertical.svelte-5zuroa .slider-rail.svelte-5zuroa{align-items:flex-end;block-size:100%;inline-size:4px}.slider.orientation-vertical.svelte-5zuroa .slider-track.svelte-5zuroa{block-size:var(--fds-slider-percentage);inline-size:100%}.slider.orientation-vertical.svelte-5zuroa .slider-thumb.svelte-5zuroa{inset-block-end:calc(var(--fds-slider-percentage) + var(--fds-slider-thumb-offset));transform:translateY(50%)}.slider.orientation-vertical.svelte-5zuroa .slider-tick.svelte-5zuroa{inset-block-end:var(--fds-slider-tick-percentage);padding:0 6px;width:100%}.slider.orientation-vertical.svelte-5zuroa .slider-tick.svelte-5zuroa:after,.slider.orientation-vertical.svelte-5zuroa .slider-tick.svelte-5zuroa:before{-webkit-border-before:1px solid var(--fds-control-strong-fill-default);border-block-start:1px solid var(--fds-control-strong-fill-default);height:1px;width:4px}.slider.orientation-vertical.reverse.svelte-5zuroa .slider-rail.svelte-5zuroa{align-items:flex-start}.slider.orientation-vertical.reverse.svelte-5zuroa .slider-thumb.svelte-5zuroa{inset-block-end:unset;inset-block-start:calc(var(--fds-slider-percentage) + var(--fds-slider-thumb-offset));transform:translateY(-50%)}.slider.orientation-vertical.reverse.svelte-5zuroa .slider-tick.svelte-5zuroa{inset-block-end:unset;inset-block-start:var(--fds-slider-tick-percentage)}.slider.disabled.svelte-5zuroa .slider-rail.svelte-5zuroa,.slider.disabled.svelte-5zuroa .slider-thumb.svelte-5zuroa:before,.slider.disabled.svelte-5zuroa .slider-track.svelte-5zuroa{background-color:var(--fds-accent-disabled)}.slider.disabled.svelte-5zuroa .slider-thumb.svelte-5zuroa:before{transform:none}.slider.disabled.svelte-5zuroa .slider-tick.svelte-5zuroa:after,.slider.disabled.svelte-5zuroa .slider-tick.svelte-5zuroa:before{border-color:var(--fds-control-fill-disabled)}.slider-rail.svelte-5zuroa.svelte-5zuroa{align-items:center;background-color:var(--fds-control-strong-fill-default);border-radius:50px;display:flex;overflow:hidden}.slider-track.svelte-5zuroa.svelte-5zuroa{background-color:var(--fds-accent-default)}.slider-tick-bar.svelte-5zuroa.svelte-5zuroa{height:100%;inset-block-start:0;inset-inline-start:0;position:absolute;width:100%;z-index:-1}.slider-tick-bar.placement-after.svelte-5zuroa .slider-tick.svelte-5zuroa:before,.slider-tick-bar.placement-before.svelte-5zuroa .slider-tick.svelte-5zuroa:after{visibility:hidden}.slider-tick.svelte-5zuroa.svelte-5zuroa{align-items:center;box-sizing:border-box;display:flex;justify-content:space-between;position:absolute}.slider-tick.svelte-5zuroa.svelte-5zuroa:after,.slider-tick.svelte-5zuroa.svelte-5zuroa:before{content:""}.slider-thumb.svelte-5zuroa.svelte-5zuroa{align-items:center;background-color:var(--fds-control-solid-fill-default);block-size:20px;box-shadow:0 0 0 1px var(--fds-control-stroke-default);display:flex;inline-size:20px;justify-content:center;z-index:10}.slider-thumb.svelte-5zuroa.svelte-5zuroa,.slider-thumb.svelte-5zuroa.svelte-5zuroa:before{border-radius:100%;position:absolute}.slider-thumb.svelte-5zuroa.svelte-5zuroa:before{background-color:var(--fds-accent-default);block-size:12px;content:"";inline-size:12px;transition:var(--fds-control-fast-duration) var(--fds-control-fast-out-slow-in-easing) transform}.slider-thumb.svelte-5zuroa.svelte-5zuroa:hover:before{transform:scale(1.167)}.slider-thumb.svelte-5zuroa:hover .slider-tooltip{opacity:1;transition-delay:1s}.slider-thumb.svelte-5zuroa.svelte-5zuroa:active:before{background-color:var(--fds-accent-tertiary);transform:scale(.833)}.slider.svelte-5zuroa .slider-tooltip{inset-block-end:calc(100% + 18px);inset-inline-start:50%;max-inline-size:unset;opacity:0;pointer-events:none;position:absolute;transform:translateX(-50%);transition:var(--fds-control-fast-duration) linear opacity;white-space:nowrap;z-index:100}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2xpZGVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFvT1EsbUNBQUEsQ0FBUSxZQUFBLE1BQWtCLENBQUMsY0FBQSxJQUFBLDJCQUFBLENBQThDLENBQUMsUUFBQSxJQUFZLENBQUMsZ0JBQUEsTUFBc0IsQ0FBQyxlQUFBLElBQW1CLENBQUMsZ0JBQUEsSUFBb0IsQ0FBQyxTQUFBLFFBQWlCLENBQUMscUJBQUEsQ0FBQSxBQUFBLENBQUEsQUFBQSxDQUFtQixVQUFBLEdBQWEsQ0FBQyxtQ0FBQSxjQUFBLENBQXNCLFdBQUEsSUFBQSxrQkFBQSxDQUFrQyxDQUFDLFFBQUEsSUFBWSxDQUFDLDJCQUFBLE9BQUEsQ0FBQSxBQUFBLGVBQUEsQUFBQSxDQUFBLHFCQUFBLE9BQUEsQ0FBQSxBQUFBLGVBQUEsQUFBQSxDQUFBLHFCQUFBLGNBQUEsQ0FBQSxBQUFBLGVBQUEsQUFBQSxDQUFxSSxRQUFBLENBQVMsQ0FBQyxPQUFBLG1EQUFBLENBQStCLFdBQUEsSUFBZSxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxPQUFBLHFDQUFBLENBQUEsMEJBQUEsQ0FBNEMsV0FBQSxHQUFjLENBQUMsWUFBQSxJQUFnQixDQUFDLGdCQUFBLFVBQTBCLENBQUMsT0FBQSxxQ0FBQSxDQUFBLDJCQUFBLENBQTZDLFdBQUEsSUFBZSxDQUFDLFlBQUEsSUFBQSx1QkFBQSxDQUF3QyxDQUFDLE9BQUEscUNBQUEsQ0FBQSwyQkFBQSxDQUE2QyxtQkFBQSxLQUFBLElBQUEsdUJBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLHlCQUFBLENBQUEsQ0FBc0YsQ0FBQyxVQUFBLFdBQUEsSUFBQSxDQUEwQixDQUFDLE9BQUEscUNBQUEsQ0FBQSwwQkFBQSxDQUE0QyxlQUFBLE1BQXFCLENBQUMsT0FBQSxJQUFXLENBQUMsbUJBQUEsSUFBQSw0QkFBQSxDQUFvRCxDQUFDLFFBQUEsR0FBQSxDQUFBLENBQWEsQ0FBQyxPQUFBLHFDQUFBLENBQUEsMEJBQUEsTUFBQSxDQUFBLE9BQUEscUNBQUEsQ0FBQSwwQkFBQSxPQUFBLENBQXFHLHFCQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxpQ0FBQSxDQUFxRSxDQUFDLG9CQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxpQ0FBQSxDQUFvRSxDQUFDLE9BQUEsR0FBVSxDQUFDLE1BQUEsR0FBUyxDQUFDLE9BQUEsdUJBQUEsc0JBQUEsQ0FBQSwwQkFBQSxDQUFvRCxnQkFBQSxRQUF3QixDQUFDLE9BQUEsdUJBQUEsc0JBQUEsQ0FBQSwyQkFBQSxDQUFxRCxpQkFBQSxLQUFBLElBQUEsdUJBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLHlCQUFBLENBQUEsQ0FBb0YsQ0FBQyxtQkFBQSxLQUF3QixDQUFDLFVBQUEsV0FBQSxHQUFBLENBQXlCLENBQUMsT0FBQSx1QkFBQSxzQkFBQSxDQUFBLDBCQUFBLENBQW9ELGlCQUFBLElBQUEsNEJBQUEsQ0FBa0QsQ0FBQyxtQkFBQSxLQUF3QixDQUFDLE9BQUEsaURBQUEsQ0FBNkIsV0FBQSxJQUFlLENBQUMsWUFBQSxJQUFnQixDQUFDLE9BQUEsbUNBQUEsQ0FBQSwwQkFBQSxDQUEwQyxZQUFBLFFBQW9CLENBQUMsV0FBQSxJQUFlLENBQUMsWUFBQSxHQUFlLENBQUMsT0FBQSxtQ0FBQSxDQUFBLDJCQUFBLENBQTJDLFdBQUEsSUFBQSx1QkFBQSxDQUF1QyxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxPQUFBLG1DQUFBLENBQUEsMkJBQUEsQ0FBMkMsZ0JBQUEsS0FBQSxJQUFBLHVCQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSx5QkFBQSxDQUFBLENBQW1GLENBQUMsVUFBQSxXQUFBLEdBQUEsQ0FBeUIsQ0FBQyxPQUFBLG1DQUFBLENBQUEsMEJBQUEsQ0FBMEMsZ0JBQUEsSUFBQSw0QkFBQSxDQUFpRCxDQUFDLFFBQUEsQ0FBQSxDQUFBLEdBQWEsQ0FBQyxNQUFBLElBQVUsQ0FBQyxPQUFBLG1DQUFBLENBQUEsMEJBQUEsTUFBQSxDQUFBLE9BQUEsbUNBQUEsQ0FBQSwwQkFBQSxPQUFBLENBQWlHLHNCQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxpQ0FBQSxDQUFzRSxDQUFDLG1CQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxpQ0FBQSxDQUFtRSxDQUFDLE9BQUEsR0FBVSxDQUFDLE1BQUEsR0FBUyxDQUFDLE9BQUEscUJBQUEsc0JBQUEsQ0FBQSwwQkFBQSxDQUFrRCxZQUFBLFVBQXNCLENBQUMsT0FBQSxxQkFBQSxzQkFBQSxDQUFBLDJCQUFBLENBQW1ELGdCQUFBLEtBQXFCLENBQUMsa0JBQUEsS0FBQSxJQUFBLHVCQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSx5QkFBQSxDQUFBLENBQXFGLENBQUMsVUFBQSxXQUFBLElBQUEsQ0FBMEIsQ0FBQyxPQUFBLHFCQUFBLHNCQUFBLENBQUEsMEJBQUEsQ0FBa0QsZ0JBQUEsS0FBcUIsQ0FBQyxrQkFBQSxJQUFBLDRCQUFBLENBQW1ELENBQUMsT0FBQSx1QkFBQSxDQUFBLDBCQUFBLENBQUEsT0FBQSx1QkFBQSxDQUFBLDJCQUFBLE9BQUEsQ0FBQSxPQUFBLHVCQUFBLENBQUEsMkJBQUEsQ0FBbUcsaUJBQUEsSUFBQSxxQkFBQSxDQUEyQyxDQUFDLE9BQUEsdUJBQUEsQ0FBQSwyQkFBQSxPQUFBLENBQXNDLFVBQUEsSUFBYyxDQUFDLE9BQUEsdUJBQUEsQ0FBQSwwQkFBQSxNQUFBLENBQUEsT0FBQSx1QkFBQSxDQUFBLDBCQUFBLE9BQUEsQ0FBeUUsYUFBQSxJQUFBLDJCQUFBLENBQTZDLENBQUMsd0NBQUEsQ0FBYSxZQUFBLE1BQWtCLENBQUMsaUJBQUEsSUFBQSxpQ0FBQSxDQUF1RCxDQUFDLGNBQUEsSUFBa0IsQ0FBQyxRQUFBLElBQVksQ0FBQyxTQUFBLE1BQWUsQ0FBQyx5Q0FBQSxDQUFjLGlCQUFBLElBQUEsb0JBQUEsQ0FBMEMsQ0FBQyw0Q0FBQSxDQUFpQixPQUFBLElBQVcsQ0FBQyxrQkFBQSxDQUFtQixDQUFDLG1CQUFBLENBQW9CLENBQUMsU0FBQSxRQUFpQixDQUFDLE1BQUEsSUFBVSxDQUFDLFFBQUEsRUFBVSxDQUFDLGdCQUFBLDhCQUFBLENBQUEsMEJBQUEsT0FBQSxDQUFBLGdCQUFBLCtCQUFBLENBQUEsMEJBQUEsTUFBQSxDQUEwRyxXQUFBLE1BQWlCLENBQUMsd0NBQUEsQ0FBYSxZQUFBLE1BQWtCLENBQUMsV0FBQSxVQUFxQixDQUFDLFFBQUEsSUFBWSxDQUFDLGdCQUFBLGFBQTZCLENBQUMsU0FBQSxRQUFpQixDQUFDLHdDQUFBLE1BQUEsQ0FBQSx3Q0FBQSxPQUFBLENBQXVDLFFBQUEsRUFBVSxDQUFDLHlDQUFBLENBQWMsWUFBQSxNQUFrQixDQUFDLGlCQUFBLElBQUEsZ0NBQUEsQ0FBc0QsQ0FBQyxXQUFBLElBQWUsQ0FBQyxXQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxJQUFBLDRCQUFBLENBQXNELENBQUMsUUFBQSxJQUFZLENBQUMsWUFBQSxJQUFnQixDQUFDLGdCQUFBLE1BQXNCLENBQUMsUUFBQSxFQUFVLENBQUMseUNBQUEsQ0FBQSx5Q0FBQSxPQUFBLENBQW1DLGNBQUEsSUFBa0IsQ0FBQyxTQUFBLFFBQWlCLENBQUMseUNBQUEsT0FBQSxDQUFxQixpQkFBQSxJQUFBLG9CQUFBLENBQTBDLENBQUMsV0FBQSxJQUFlLENBQUMsUUFBQSxFQUFVLENBQUMsWUFBQSxJQUFnQixDQUFDLFdBQUEsSUFBQSwyQkFBQSxDQUFBLENBQUEsSUFBQSxxQ0FBQSxDQUFBLENBQUEsU0FBZ0csQ0FBQyx5Q0FBQSxNQUFBLE9BQUEsQ0FBMkIsVUFBQSxNQUFBLEtBQUEsQ0FBc0IsQ0FBQywyQkFBQSxNQUFBLENBQUEsQUFBQSxlQUFBLEFBQUEsQ0FBNkMsUUFBQSxDQUFTLENBQUMsaUJBQUEsRUFBbUIsQ0FBQyx5Q0FBQSxPQUFBLE9BQUEsQ0FBNEIsaUJBQUEsSUFBQSxxQkFBQSxDQUEyQyxDQUFDLFVBQUEsTUFBQSxJQUFBLENBQXFCLENBQUMscUJBQUEsQ0FBQSxBQUFBLGVBQUEsQUFBQSxDQUFpQyxnQkFBQSxLQUFBLElBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUFpQyxDQUFDLG1CQUFBLEdBQXNCLENBQUMsZ0JBQUEsS0FBcUIsQ0FBQyxRQUFBLENBQVMsQ0FBQyxlQUFBLElBQW1CLENBQUMsU0FBQSxRQUFpQixDQUFDLFVBQUEsV0FBQSxJQUFBLENBQTBCLENBQUMsV0FBQSxJQUFBLDJCQUFBLENBQUEsQ0FBQSxNQUFBLENBQUEsT0FBMEQsQ0FBQyxZQUFBLE1BQWtCLENBQUMsUUFBQSxHQUFXLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiU2xpZGVyLnN2ZWx0ZSJdfQ== */');
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[46] = list[i];
  return child_ctx;
}
var get_tooltip_slot_changes = (dirty) => ({
  prefix: dirty[0] & /*prefix*/
  8192,
  suffix: dirty[0] & /*suffix*/
  16384,
  value: dirty[0] & /*value*/
  1
});
var get_tooltip_slot_context = (ctx) => ({
  prefix: (
    /*prefix*/
    ctx[13]
  ),
  suffix: (
    /*suffix*/
    ctx[14]
  ),
  value: (
    /*value*/
    ctx[0]
  )
});
function create_if_block_26(ctx) {
  let tooltipsurface;
  let current;
  tooltipsurface = new TooltipSurface_default({
    props: {
      class: "slider-tooltip",
      $$slots: { default: [create_default_slot7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tooltipsurface.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tooltipsurface.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tooltipsurface, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tooltipsurface_changes = {};
      if (dirty[0] & /*suffix, value, prefix*/
      24577 | dirty[1] & /*$$scope*/
      4096) {
        tooltipsurface_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tooltipsurface.$set(tooltipsurface_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tooltipsurface.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tooltipsurface.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tooltipsurface, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_26.name,
    type: "if",
    source: "(200:2) {#if tooltip && !disabled}",
    ctx
  });
  return block;
}
function fallback_block5(ctx) {
  let t0;
  let t1;
  let t2;
  const block = {
    c: function create() {
      t0 = text(
        /*prefix*/
        ctx[13]
      );
      t1 = text(
        /*value*/
        ctx[0]
      );
      t2 = text(
        /*suffix*/
        ctx[14]
      );
    },
    l: function claim(nodes) {
      t0 = claim_text(
        nodes,
        /*prefix*/
        ctx[13]
      );
      t1 = claim_text(
        nodes,
        /*value*/
        ctx[0]
      );
      t2 = claim_text(
        nodes,
        /*suffix*/
        ctx[14]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, t2, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*prefix*/
      8192)
        set_data_dev(
          t0,
          /*prefix*/
          ctx2[13]
        );
      if (dirty[0] & /*value*/
      1)
        set_data_dev(
          t1,
          /*value*/
          ctx2[0]
        );
      if (dirty[0] & /*suffix*/
      16384)
        set_data_dev(
          t2,
          /*suffix*/
          ctx2[14]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(t2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block5.name,
    type: "fallback",
    source: "(202:51)       ",
    ctx
  });
  return block;
}
function create_default_slot7(ctx) {
  let current;
  const tooltip_slot_template = (
    /*#slots*/
    ctx[34].tooltip
  );
  const tooltip_slot = create_slot(
    tooltip_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    get_tooltip_slot_context
  );
  const tooltip_slot_or_fallback = tooltip_slot || fallback_block5(ctx);
  const block = {
    c: function create() {
      if (tooltip_slot_or_fallback)
        tooltip_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (tooltip_slot_or_fallback)
        tooltip_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (tooltip_slot_or_fallback) {
        tooltip_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (tooltip_slot) {
        if (tooltip_slot.p && (!current || dirty[0] & /*prefix, suffix, value*/
        24577 | dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            tooltip_slot,
            tooltip_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              tooltip_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              get_tooltip_slot_changes
            ),
            get_tooltip_slot_context
          );
        }
      } else {
        if (tooltip_slot_or_fallback && tooltip_slot_or_fallback.p && (!current || dirty[0] & /*suffix, value, prefix*/
        24577)) {
          tooltip_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tooltip_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tooltip_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (tooltip_slot_or_fallback)
        tooltip_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: '(201:3) <TooltipSurface class=\\"slider-tooltip\\">',
    ctx
  });
  return block;
}
function create_if_block_111(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "slider-track svelte-5zuroa");
      add_location(div, file22, 210, 3, 6833);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      ctx[37](div);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[37](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_111.name,
    type: "if",
    source: "(210:2) {#if track}",
    ctx
  });
  return block;
}
function create_if_block14(ctx) {
  let div;
  let div_class_value;
  let each_value = (
    /*ticks*/
    ctx[10]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "slider-tick-bar placement-" + /*tickPlacement*/
      ctx[11] + " svelte-5zuroa");
      add_location(div, file22, 215, 2, 6919);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      ctx[39](div);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*valueToPercentage, ticks*/
      33555456) {
        each_value = /*ticks*/
        ctx2[10];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty[0] & /*tickPlacement*/
      2048 && div_class_value !== (div_class_value = "slider-tick-bar placement-" + /*tickPlacement*/
      ctx2[11] + " svelte-5zuroa")) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
      ctx[39](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block14.name,
    type: "if",
    source: "(215:1) {#if ticks}",
    ctx
  });
  return block;
}
function create_each_block3(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "slider-tick svelte-5zuroa");
      set_style(
        div,
        "--fds-slider-tick-percentage",
        /*valueToPercentage*/
        ctx[25](
          /*tick*/
          ctx[46]
        ) + "%"
      );
      add_location(div, file22, 217, 4, 7031);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*ticks*/
      1024) {
        set_style(
          div,
          "--fds-slider-tick-percentage",
          /*valueToPercentage*/
          ctx2[25](
            /*tick*/
            ctx2[46]
          ) + "%"
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(217:3) {#each ticks as tick}",
    ctx
  });
  return block;
}
function create_fragment22(ctx) {
  let div2;
  let div0;
  let div0_resize_listener;
  let t0;
  let div1;
  let t1;
  let t2;
  let input;
  let div2_tabindex_value;
  let div2_style_value;
  let div2_class_value;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*tooltip*/
    ctx[12] && !/*disabled*/
    ctx[17] && create_if_block_26(ctx)
  );
  let if_block1 = (
    /*track*/
    ctx[15] && create_if_block_111(ctx)
  );
  let if_block2 = (
    /*ticks*/
    ctx[10] && create_if_block14(ctx)
  );
  let div2_levels = [
    {
      tabindex: div2_tabindex_value = /*disabled*/
      ctx[17] ? -1 : 0
    },
    {
      style: div2_style_value = "--fds-slider-percentage: " + /*percentage*/
      ctx[23] + "%; --fds-slider-thumb-offset: " + /*thumbClientWidth*/
      (ctx[22] / 2 - linearScale([0, 50], [
        0,
        /*thumbClientWidth*/
        ctx[22] / 2
      ])(
        /*percentage*/
        ctx[23]
      )) + "px;"
    },
    {
      class: div2_class_value = "slider orientation-" + /*orientation*/
      ctx[16] + " " + /*className*/
      ctx[18]
    },
    /*$$restProps*/
    ctx[30]
  ];
  let div2_data = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div2_data = assign(div2_data, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div1 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { tabindex: true, style: true, class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", {
        class: true,
        role: true,
        "aria-valuemin": true,
        "aria-valuemax": true,
        "aria-valuenow": true
      });
      var div0_nodes = children(div0);
      if (if_block0)
        if_block0.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block1)
        if_block1.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      if (if_block2)
        if_block2.l(div2_nodes);
      t2 = claim_space(div2_nodes);
      input = claim_element(div2_nodes, "INPUT", {
        type: true,
        min: true,
        max: true,
        step: true
      });
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "slider-thumb svelte-5zuroa");
      attr_dev(div0, "role", "slider");
      attr_dev(
        div0,
        "aria-valuemin",
        /*min*/
        ctx[7]
      );
      attr_dev(
        div0,
        "aria-valuemax",
        /*max*/
        ctx[8]
      );
      attr_dev(
        div0,
        "aria-valuenow",
        /*value*/
        ctx[0]
      );
      add_render_callback(() => (
        /*div0_elementresize_handler*/
        ctx[36].call(div0)
      ));
      add_location(div0, file22, 190, 1, 6382);
      attr_dev(div1, "class", "slider-rail svelte-5zuroa");
      add_location(div1, file22, 208, 1, 6766);
      attr_dev(input, "type", "range");
      input.hidden = true;
      attr_dev(
        input,
        "min",
        /*min*/
        ctx[7]
      );
      attr_dev(
        input,
        "max",
        /*max*/
        ctx[8]
      );
      attr_dev(
        input,
        "step",
        /*step*/
        ctx[9]
      );
      input.disabled = /*disabled*/
      ctx[17];
      input.value = /*value*/
      ctx[0];
      add_location(input, file22, 225, 1, 7167);
      set_attributes(div2, div2_data);
      toggle_class(
        div2,
        "disabled",
        /*disabled*/
        ctx[17]
      );
      toggle_class(
        div2,
        "reverse",
        /*directionAwareReverse*/
        ctx[21]
      );
      toggle_class(div2, "svelte-5zuroa", true);
      add_location(div2, file22, 172, 0, 5857);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      if (if_block0)
        if_block0.m(div0, null);
      ctx[35](div0);
      div0_resize_listener = add_resize_listener(
        div0,
        /*div0_elementresize_handler*/
        ctx[36].bind(div0)
      );
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      if (if_block1)
        if_block1.m(div1, null);
      ctx[38](div1);
      append_hydration_dev(div2, t1);
      if (if_block2)
        if_block2.m(div2, null);
      append_hydration_dev(div2, t2);
      append_hydration_dev(div2, input);
      ctx[40](input);
      ctx[42](div2);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window_1,
            "mousemove",
            /*handleMove*/
            ctx[27],
            false,
            false,
            false
          ),
          listen_dev(
            window_1,
            "touchmove",
            /*handleMove*/
            ctx[27],
            false,
            false,
            false
          ),
          listen_dev(
            window_1,
            "mouseup",
            /*cancelMove*/
            ctx[26],
            false,
            false,
            false
          ),
          listen_dev(
            window_1,
            "touchend",
            /*cancelMove*/
            ctx[26],
            false,
            false,
            false
          ),
          listen_dev(
            window_1,
            "touchcancel",
            /*cancelMove*/
            ctx[26],
            false,
            false,
            false
          ),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[24].call(null, div2)),
          listen_dev(div2, "mousedown", prevent_default(
            /*mousedown_handler*/
            ctx[41]
          ), false, true, false),
          listen_dev(
            div2,
            "touchstart",
            /*handleTouchStart*/
            ctx[29],
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "keydown",
            /*handleArrowKeys*/
            ctx[28],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*tooltip*/
        ctx2[12] && !/*disabled*/
        ctx2[17]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*tooltip, disabled*/
          135168) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_26(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*min*/
      128) {
        attr_dev(
          div0,
          "aria-valuemin",
          /*min*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*max*/
      256) {
        attr_dev(
          div0,
          "aria-valuemax",
          /*max*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*value*/
      1) {
        attr_dev(
          div0,
          "aria-valuenow",
          /*value*/
          ctx2[0]
        );
      }
      if (
        /*track*/
        ctx2[15]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_111(ctx2);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*ticks*/
        ctx2[10]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block14(ctx2);
          if_block2.c();
          if_block2.m(div2, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (!current || dirty[0] & /*min*/
      128) {
        attr_dev(
          input,
          "min",
          /*min*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*max*/
      256) {
        attr_dev(
          input,
          "max",
          /*max*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*step*/
      512) {
        attr_dev(
          input,
          "step",
          /*step*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      131072) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[17]
        );
      }
      if (!current || dirty[0] & /*value*/
      1) {
        prop_dev(
          input,
          "value",
          /*value*/
          ctx2[0]
        );
      }
      set_attributes(div2, div2_data = get_spread_update(div2_levels, [
        (!current || dirty[0] & /*disabled*/
        131072 && div2_tabindex_value !== (div2_tabindex_value = /*disabled*/
        ctx2[17] ? -1 : 0)) && { tabindex: div2_tabindex_value },
        (!current || dirty[0] & /*percentage, thumbClientWidth*/
        12582912 && div2_style_value !== (div2_style_value = "--fds-slider-percentage: " + /*percentage*/
        ctx2[23] + "%; --fds-slider-thumb-offset: " + /*thumbClientWidth*/
        (ctx2[22] / 2 - linearScale([0, 50], [
          0,
          /*thumbClientWidth*/
          ctx2[22] / 2
        ])(
          /*percentage*/
          ctx2[23]
        )) + "px;")) && { style: div2_style_value },
        (!current || dirty[0] & /*orientation, className*/
        327680 && div2_class_value !== (div2_class_value = "slider orientation-" + /*orientation*/
        ctx2[16] + " " + /*className*/
        ctx2[18])) && { class: div2_class_value },
        dirty[0] & /*$$restProps*/
        1073741824 && /*$$restProps*/
        ctx2[30]
      ]));
      toggle_class(
        div2,
        "disabled",
        /*disabled*/
        ctx2[17]
      );
      toggle_class(
        div2,
        "reverse",
        /*directionAwareReverse*/
        ctx2[21]
      );
      toggle_class(div2, "svelte-5zuroa", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block0)
        if_block0.d();
      ctx[35](null);
      div0_resize_listener();
      if (if_block1)
        if_block1.d();
      ctx[38](null);
      if (if_block2)
        if_block2.d();
      ctx[40](null);
      ctx[42](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1])
      return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function instance22($$self, $$props, $$invalidate) {
  let percentage;
  const omit_props_names = [
    "value",
    "min",
    "max",
    "step",
    "ticks",
    "tickPlacement",
    "tooltip",
    "prefix",
    "suffix",
    "track",
    "orientation",
    "reverse",
    "disabled",
    "class",
    "inputElement",
    "containerElement",
    "tickBarElement",
    "thumbElement",
    "railElement",
    "trackElement",
    "stepUp",
    "stepDown"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Slider", slots, ["tooltip"]);
  let { value = 0 } = $$props;
  let { min = 0 } = $$props;
  let { max = 100 } = $$props;
  let { step = 1 } = $$props;
  let { ticks = [] } = $$props;
  let { tickPlacement = "around" } = $$props;
  let { tooltip = true } = $$props;
  let { prefix = "" } = $$props;
  let { suffix = "" } = $$props;
  let { track = true } = $$props;
  let { orientation = "horizontal" } = $$props;
  let { reverse = false } = $$props;
  let { disabled = false } = $$props;
  let { class: className = "" } = $$props;
  let { inputElement = null } = $$props;
  let { containerElement = null } = $$props;
  let { tickBarElement = null } = $$props;
  let { thumbElement = null } = $$props;
  let { railElement = null } = $$props;
  let { trackElement = null } = $$props;
  let dragging = false;
  let holding = false;
  let directionAwareReverse = false;
  let thumbClientWidth = 20;
  const dispatch = createEventDispatcher();
  const forwardEvents = createEventForwarder(get_current_component(), ["input", "change", "beforeinput"]);
  const valueToPercentage = (v) => (v - min) / (max - min) * 100;
  function cancelMove() {
    $$invalidate(20, holding = false);
    $$invalidate(19, dragging = false);
  }
  function handleMove() {
    if (holding)
      $$invalidate(19, dragging = true);
  }
  function calculateValue(event2) {
    if (disabled || !railElement)
      return;
    const { top, bottom, left, right, width, height } = railElement.getBoundingClientRect();
    const percentageX = event2.touches ? event2.touches[0].clientX : event2.clientX;
    const percentageY = event2.touches ? event2.touches[0].clientY : event2.clientY;
    const position = orientation === "horizontal" ? percentageX : percentageY;
    const startingPos = orientation === "horizontal" ? directionAwareReverse ? right : left : directionAwareReverse ? top : bottom;
    const length = orientation === "horizontal" ? width : height;
    let nextStep = min + Math.round((max - min) * ((position - startingPos) / length) * (directionAwareReverse ? -1 : 1) * (orientation === "vertical" ? -1 : 1) / step) * step;
    if (nextStep <= min)
      nextStep = min;
    else if (nextStep >= max)
      nextStep = max;
    $$invalidate(0, value = nextStep);
  }
  function handleArrowKeys(event2) {
    const { key } = event2;
    if (key === "ArrowDown" || key === "ArrowUp")
      event2.preventDefault();
    if (key === "ArrowLeft" || key === "ArrowDown" && !disabled) {
      if (reverse) {
        stepUp();
      } else {
        stepDown();
      }
    } else if (key === "ArrowRight" || key === "ArrowUp" && !disabled) {
      if (reverse) {
        stepDown();
      } else {
        stepUp();
      }
    }
  }
  function handleTouchStart(event2) {
    if (event2.cancelable)
      event2.preventDefault();
    $$invalidate(20, holding = true);
  }
  function stepUp() {
    $$invalidate(0, value += step);
    if (value > max)
      $$invalidate(0, value = max);
  }
  function stepDown() {
    $$invalidate(0, value -= step);
    if (value < min)
      $$invalidate(0, value = min);
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      thumbElement = $$value;
      $$invalidate(4, thumbElement);
    });
  }
  function div0_elementresize_handler() {
    thumbClientWidth = this.clientWidth;
    $$invalidate(22, thumbClientWidth);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      trackElement = $$value;
      $$invalidate(6, trackElement);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      railElement = $$value;
      $$invalidate(5, railElement);
    });
  }
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tickBarElement = $$value;
      $$invalidate(3, tickBarElement);
    });
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(2, inputElement);
    });
  }
  const mousedown_handler = () => {
    $$invalidate(20, holding = true);
    $$invalidate(19, dragging = true);
  };
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      containerElement = $$value;
      $$invalidate(1, containerElement);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(30, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("min" in $$new_props)
      $$invalidate(7, min = $$new_props.min);
    if ("max" in $$new_props)
      $$invalidate(8, max = $$new_props.max);
    if ("step" in $$new_props)
      $$invalidate(9, step = $$new_props.step);
    if ("ticks" in $$new_props)
      $$invalidate(10, ticks = $$new_props.ticks);
    if ("tickPlacement" in $$new_props)
      $$invalidate(11, tickPlacement = $$new_props.tickPlacement);
    if ("tooltip" in $$new_props)
      $$invalidate(12, tooltip = $$new_props.tooltip);
    if ("prefix" in $$new_props)
      $$invalidate(13, prefix = $$new_props.prefix);
    if ("suffix" in $$new_props)
      $$invalidate(14, suffix = $$new_props.suffix);
    if ("track" in $$new_props)
      $$invalidate(15, track = $$new_props.track);
    if ("orientation" in $$new_props)
      $$invalidate(16, orientation = $$new_props.orientation);
    if ("reverse" in $$new_props)
      $$invalidate(31, reverse = $$new_props.reverse);
    if ("disabled" in $$new_props)
      $$invalidate(17, disabled = $$new_props.disabled);
    if ("class" in $$new_props)
      $$invalidate(18, className = $$new_props.class);
    if ("inputElement" in $$new_props)
      $$invalidate(2, inputElement = $$new_props.inputElement);
    if ("containerElement" in $$new_props)
      $$invalidate(1, containerElement = $$new_props.containerElement);
    if ("tickBarElement" in $$new_props)
      $$invalidate(3, tickBarElement = $$new_props.tickBarElement);
    if ("thumbElement" in $$new_props)
      $$invalidate(4, thumbElement = $$new_props.thumbElement);
    if ("railElement" in $$new_props)
      $$invalidate(5, railElement = $$new_props.railElement);
    if ("trackElement" in $$new_props)
      $$invalidate(6, trackElement = $$new_props.trackElement);
    if ("$$scope" in $$new_props)
      $$invalidate(43, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventForwarder,
    TooltipSurface: TooltipSurface_default,
    createEventDispatcher,
    get_current_component,
    value,
    min,
    max,
    step,
    ticks,
    tickPlacement,
    tooltip,
    prefix,
    suffix,
    track,
    orientation,
    reverse,
    disabled,
    className,
    inputElement,
    containerElement,
    tickBarElement,
    thumbElement,
    railElement,
    trackElement,
    dragging,
    holding,
    directionAwareReverse,
    thumbClientWidth,
    dispatch,
    forwardEvents,
    valueToPercentage,
    cancelMove,
    handleMove,
    calculateValue,
    handleArrowKeys,
    handleTouchStart,
    linearScale,
    stepUp,
    stepDown,
    percentage
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("min" in $$props)
      $$invalidate(7, min = $$new_props.min);
    if ("max" in $$props)
      $$invalidate(8, max = $$new_props.max);
    if ("step" in $$props)
      $$invalidate(9, step = $$new_props.step);
    if ("ticks" in $$props)
      $$invalidate(10, ticks = $$new_props.ticks);
    if ("tickPlacement" in $$props)
      $$invalidate(11, tickPlacement = $$new_props.tickPlacement);
    if ("tooltip" in $$props)
      $$invalidate(12, tooltip = $$new_props.tooltip);
    if ("prefix" in $$props)
      $$invalidate(13, prefix = $$new_props.prefix);
    if ("suffix" in $$props)
      $$invalidate(14, suffix = $$new_props.suffix);
    if ("track" in $$props)
      $$invalidate(15, track = $$new_props.track);
    if ("orientation" in $$props)
      $$invalidate(16, orientation = $$new_props.orientation);
    if ("reverse" in $$props)
      $$invalidate(31, reverse = $$new_props.reverse);
    if ("disabled" in $$props)
      $$invalidate(17, disabled = $$new_props.disabled);
    if ("className" in $$props)
      $$invalidate(18, className = $$new_props.className);
    if ("inputElement" in $$props)
      $$invalidate(2, inputElement = $$new_props.inputElement);
    if ("containerElement" in $$props)
      $$invalidate(1, containerElement = $$new_props.containerElement);
    if ("tickBarElement" in $$props)
      $$invalidate(3, tickBarElement = $$new_props.tickBarElement);
    if ("thumbElement" in $$props)
      $$invalidate(4, thumbElement = $$new_props.thumbElement);
    if ("railElement" in $$props)
      $$invalidate(5, railElement = $$new_props.railElement);
    if ("trackElement" in $$props)
      $$invalidate(6, trackElement = $$new_props.trackElement);
    if ("dragging" in $$props)
      $$invalidate(19, dragging = $$new_props.dragging);
    if ("holding" in $$props)
      $$invalidate(20, holding = $$new_props.holding);
    if ("directionAwareReverse" in $$props)
      $$invalidate(21, directionAwareReverse = $$new_props.directionAwareReverse);
    if ("thumbClientWidth" in $$props)
      $$invalidate(22, thumbClientWidth = $$new_props.thumbClientWidth);
    if ("percentage" in $$props)
      $$invalidate(23, percentage = $$new_props.percentage);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*containerElement*/
    2 | $$self.$$.dirty[1] & /*reverse*/
    1) {
      $:
        if (containerElement) {
          $$invalidate(21, directionAwareReverse = (window === null || window === void 0 ? void 0 : window.getComputedStyle(containerElement).direction) === "ltr" ? reverse : !reverse);
        }
    }
    if ($$self.$$.dirty[0] & /*value, min, max, dragging*/
    524673) {
      $: {
        if (value <= min)
          $$invalidate(0, value = min);
        else if (value >= max)
          $$invalidate(0, value = max);
        if (dragging) {
          calculateValue(event);
          $$invalidate(19, dragging = false);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*value*/
    1) {
      $:
        dispatch("change", value);
    }
    if ($$self.$$.dirty[0] & /*value*/
    1) {
      $:
        $$invalidate(23, percentage = valueToPercentage(value));
    }
  };
  return [
    value,
    containerElement,
    inputElement,
    tickBarElement,
    thumbElement,
    railElement,
    trackElement,
    min,
    max,
    step,
    ticks,
    tickPlacement,
    tooltip,
    prefix,
    suffix,
    track,
    orientation,
    disabled,
    className,
    dragging,
    holding,
    directionAwareReverse,
    thumbClientWidth,
    percentage,
    forwardEvents,
    valueToPercentage,
    cancelMove,
    handleMove,
    handleArrowKeys,
    handleTouchStart,
    $$restProps,
    reverse,
    stepUp,
    stepDown,
    slots,
    div0_binding,
    div0_elementresize_handler,
    div_binding,
    div1_binding,
    div_binding_1,
    input_binding,
    mousedown_handler,
    div2_binding,
    $$scope
  ];
}
var Slider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance22,
      create_fragment22,
      safe_not_equal,
      {
        value: 0,
        min: 7,
        max: 8,
        step: 9,
        ticks: 10,
        tickPlacement: 11,
        tooltip: 12,
        prefix: 13,
        suffix: 14,
        track: 15,
        orientation: 16,
        reverse: 31,
        disabled: 17,
        class: 18,
        inputElement: 2,
        containerElement: 1,
        tickBarElement: 3,
        thumbElement: 4,
        railElement: 5,
        trackElement: 6,
        stepUp: 32,
        stepDown: 33
      },
      add_css22,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Slider",
      options,
      id: create_fragment22.name
    });
  }
  get value() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ticks() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ticks(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickPlacement() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickPlacement(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltip() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltip(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get prefix() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set prefix(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get suffix() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set suffix(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get track() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set track(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orientation() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orientation(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reverse() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reverse(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerElement() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerElement(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickBarElement() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickBarElement(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get thumbElement() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set thumbElement(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get railElement() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set railElement(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get trackElement() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set trackElement(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stepUp() {
    return this.$$.ctx[32];
  }
  set stepUp(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stepDown() {
    return this.$$.ctx[33];
  }
  set stepDown(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Slider_default = Slider;

// node_modules/fluent-svelte/PersonPicture/PersonPicture.svelte
var file23 = "node_modules\\fluent-svelte\\PersonPicture\\PersonPicture.svelte";
function add_css23(target) {
  append_styles(target, "svelte-n8rogs", ".person-picture.svelte-n8rogs{align-items:center;background-clip:padding-box;background-color:var(--fds-control-alt-fill-quarternary);block-size:100%;border:1px solid var(--fds-card-stroke-default);border-radius:50%;box-sizing:border-box;display:flex;flex:0 0 auto;font-family:var(--fds-font-family-display);font-size:calc(var(--fds-person-picture-size)*.41667);font-weight:600;inline-size:100%;justify-content:center;overflow:hidden;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.person-picture-container.svelte-n8rogs{block-size:var(--fds-person-picture-size);display:flex;inline-size:var(--fds-person-picture-size);position:relative}.person-picture-badge.svelte-n8rogs{align-items:flex-end;block-size:100%;display:flex;flex-direction:column;inline-size:100%;inset-block-start:0;inset-inline-start:0;position:absolute}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGVyc29uUGljdHVyZS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBb0RRLDZCQUFBLENBQWdCLFlBQUEsTUFBa0IsQ0FBQyxnQkFBQSxXQUEyQixDQUFDLGlCQUFBLElBQUEsa0NBQUEsQ0FBd0QsQ0FBQyxXQUFBLElBQWUsQ0FBQyxPQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSx5QkFBQSxDQUErQyxDQUFDLGNBQUEsR0FBaUIsQ0FBQyxXQUFBLFVBQXFCLENBQUMsUUFBQSxJQUFZLENBQUMsS0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLElBQWEsQ0FBQyxZQUFBLElBQUEseUJBQUEsQ0FBMEMsQ0FBQyxVQUFBLEtBQUEsSUFBQSx5QkFBQSxDQUFBLENBQUEsTUFBQSxDQUFxRCxDQUFDLFlBQUEsR0FBZSxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxnQkFBQSxNQUFzQixDQUFDLFNBQUEsTUFBZSxDQUFDLFdBQUEsTUFBaUIsQ0FBQyxvQkFBQSxJQUF3QixDQUFDLGlCQUFBLElBQXFCLENBQUMsZ0JBQUEsSUFBb0IsQ0FBQyxZQUFBLElBQWdCLENBQUMsdUNBQUEsQ0FBMEIsV0FBQSxJQUFBLHlCQUFBLENBQXlDLENBQUMsUUFBQSxJQUFZLENBQUMsWUFBQSxJQUFBLHlCQUFBLENBQTBDLENBQUMsU0FBQSxRQUFpQixDQUFDLG1DQUFBLENBQXNCLFlBQUEsUUFBb0IsQ0FBQyxXQUFBLElBQWUsQ0FBQyxRQUFBLElBQVksQ0FBQyxlQUFBLE1BQXFCLENBQUMsWUFBQSxJQUFnQixDQUFDLGtCQUFBLENBQW1CLENBQUMsbUJBQUEsQ0FBb0IsQ0FBQyxTQUFBLFFBQWlCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiUGVyc29uUGljdHVyZS5zdmVsdGUiXX0= */");
}
var get_badge_slot_changes = (dirty) => ({});
var get_badge_slot_context = (ctx) => ({});
function create_else_block6(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block6(ctx);
  let div_levels = [
    {
      class: div_class_value = "person-picture " + /*className*/
      ctx[5]
    },
    /*$$restProps*/
    ctx[7]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "svelte-n8rogs", true);
      add_location(div, file23, 35, 2, 1017);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div, null);
      }
      ctx[13](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*alt*/
        16)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*className*/
        32 && div_class_value !== (div_class_value = "person-picture " + /*className*/
        ctx2[5])) && { class: div_class_value },
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
      toggle_class(div, "svelte-n8rogs", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[13](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block6.name,
    type: "else",
    source: "(35:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block_112(ctx) {
  let img;
  let img_class_value;
  let img_src_value;
  let mounted;
  let dispose;
  let img_levels = [
    {
      class: img_class_value = "person-picture " + /*className*/
      ctx[5]
    },
    { width: (
      /*size*/
      ctx[2]
    ) },
    { height: (
      /*size*/
      ctx[2]
    ) },
    { src: img_src_value = /*src*/
    ctx[3] },
    { alt: (
      /*alt*/
      ctx[4]
    ) },
    /*$$restProps*/
    ctx[7]
  ];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", {
        class: true,
        width: true,
        height: true,
        src: true,
        alt: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(img, img_data);
      toggle_class(img, "svelte-n8rogs", true);
      add_location(img, file23, 24, 2, 829);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
      ctx[11](img);
      if (!mounted) {
        dispose = listen_dev(
          img,
          "error",
          /*error_handler*/
          ctx[12],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(img, img_data = get_spread_update(img_levels, [
        dirty & /*className*/
        32 && img_class_value !== (img_class_value = "person-picture " + /*className*/
        ctx2[5]) && { class: img_class_value },
        dirty & /*size*/
        4 && { width: (
          /*size*/
          ctx2[2]
        ) },
        dirty & /*size*/
        4 && { height: (
          /*size*/
          ctx2[2]
        ) },
        dirty & /*src*/
        8 && !src_url_equal(img.src, img_src_value = /*src*/
        ctx2[3]) && { src: img_src_value },
        dirty & /*alt*/
        16 && { alt: (
          /*alt*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
      toggle_class(img, "svelte-n8rogs", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
      ctx[11](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_112.name,
    type: "if",
    source: "(24:1) {#if src && !error}",
    ctx
  });
  return block;
}
function fallback_block6(ctx) {
  var _a;
  let t_value = (
    /*alt*/
    (((_a = ctx[4]) == null ? void 0 : _a.split(" ").map(func).join("").toUpperCase()) ?? "") + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2;
      if (dirty & /*alt*/
      16 && t_value !== (t_value = /*alt*/
      (((_a2 = ctx2[4]) == null ? void 0 : _a2.split(" ").map(func).join("").toUpperCase()) ?? "") + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block6.name,
    type: "fallback",
    source: "(37:9)      ",
    ctx
  });
  return block;
}
function create_if_block15(ctx) {
  let span;
  let current;
  const badge_slot_template = (
    /*#slots*/
    ctx[10].badge
  );
  const badge_slot = create_slot(
    badge_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_badge_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (badge_slot)
        badge_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (badge_slot)
        badge_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "person-picture-badge svelte-n8rogs");
      add_location(span, file23, 46, 2, 1252);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (badge_slot) {
        badge_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (badge_slot) {
        if (badge_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            badge_slot,
            badge_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              badge_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_badge_slot_changes
            ),
            get_badge_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(badge_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(badge_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (badge_slot)
        badge_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block15.name,
    type: "if",
    source: "(46:1) {#if $$slots.badge}",
    ctx
  });
  return block;
}
function create_fragment23(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t;
  let current;
  const if_block_creators = [create_if_block_112, create_else_block6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*src*/
      ctx2[3] && !/*error*/
      ctx2[6]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = (
    /*$$slots*/
    ctx[8].badge && create_if_block15(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      if_block0.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "person-picture-container svelte-n8rogs");
      set_style(
        div,
        "--fds-person-picture-size",
        /*size*/
        ctx[2] + "px"
      );
      add_location(div, file23, 18, 0, 690);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append_hydration_dev(div, t);
      if (if_block1)
        if_block1.m(div, null);
      ctx[14](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t);
      }
      if (
        /*$$slots*/
        ctx2[8].badge
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          256) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block15(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*size*/
      4) {
        set_style(
          div,
          "--fds-person-picture-size",
          /*size*/
          ctx2[2] + "px"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      ctx[14](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func = (i) => i.charAt(0);
function instance23($$self, $$props, $$invalidate) {
  const omit_props_names = ["size", "src", "alt", "class", "element", "containerElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PersonPicture", slots, ["default", "badge"]);
  const $$slots = compute_slots(slots);
  let { size = 72 } = $$props;
  let { src = void 0 } = $$props;
  let { alt = void 0 } = $$props;
  let { class: className = "" } = $$props;
  let { element: element2 = null } = $$props;
  let { containerElement = null } = $$props;
  let error = false;
  function img_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  const error_handler = () => $$invalidate(6, error = true);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      containerElement = $$value;
      $$invalidate(1, containerElement);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(2, size = $$new_props.size);
    if ("src" in $$new_props)
      $$invalidate(3, src = $$new_props.src);
    if ("alt" in $$new_props)
      $$invalidate(4, alt = $$new_props.alt);
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("containerElement" in $$new_props)
      $$invalidate(1, containerElement = $$new_props.containerElement);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    src,
    alt,
    className,
    element: element2,
    containerElement,
    error
  });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props)
      $$invalidate(2, size = $$new_props.size);
    if ("src" in $$props)
      $$invalidate(3, src = $$new_props.src);
    if ("alt" in $$props)
      $$invalidate(4, alt = $$new_props.alt);
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("containerElement" in $$props)
      $$invalidate(1, containerElement = $$new_props.containerElement);
    if ("error" in $$props)
      $$invalidate(6, error = $$new_props.error);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*src*/
    8) {
      $:
        if (src)
          $$invalidate(6, error = false);
    }
  };
  return [
    element2,
    containerElement,
    size,
    src,
    alt,
    className,
    error,
    $$restProps,
    $$slots,
    $$scope,
    slots,
    img_binding,
    error_handler,
    div_binding,
    div_binding_1
  ];
}
var PersonPicture = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance23,
      create_fragment23,
      safe_not_equal,
      {
        size: 2,
        src: 3,
        alt: 4,
        class: 5,
        element: 0,
        containerElement: 1
      },
      add_css23
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PersonPicture",
      options,
      id: create_fragment23.name
    });
  }
  get size() {
    throw new Error("<PersonPicture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PersonPicture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get src() {
    throw new Error("<PersonPicture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<PersonPicture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<PersonPicture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<PersonPicture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PersonPicture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PersonPicture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<PersonPicture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<PersonPicture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerElement() {
    throw new Error("<PersonPicture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerElement(value) {
    throw new Error("<PersonPicture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PersonPicture_default = PersonPicture;

// node_modules/fluent-svelte/Tooltip/TooltipWrapper.svelte
var file24 = "node_modules\\fluent-svelte\\Tooltip\\TooltipWrapper.svelte";
function add_css24(target) {
  append_styles(target, "svelte-jkic00", ".tooltip-wrapper.svelte-jkic00{display:block;position:relative}.tooltip-anchor.svelte-jkic00{pointer-events:none;position:absolute;z-index:100}.tooltip-anchor.placement-top.svelte-jkic00{bottom:calc(100% + var(--fds-tooltip-offset))}.tooltip-anchor.placement-bottom.svelte-jkic00{top:calc(100% + var(--fds-tooltip-offset))}.tooltip-anchor.placement-left.svelte-jkic00{right:calc(100% + var(--fds-tooltip-offset))}.tooltip-anchor.placement-right.svelte-jkic00{left:calc(100% + var(--fds-tooltip-offset))}.tooltip-anchor.placement-bottom.alignment-start.svelte-jkic00,.tooltip-anchor.placement-top.alignment-start.svelte-jkic00{inset-inline-start:0}.tooltip-anchor.placement-bottom.alignment-end.svelte-jkic00,.tooltip-anchor.placement-top.alignment-end.svelte-jkic00{inset-inline-end:0}.tooltip-anchor.placement-bottom.alignment-center.svelte-jkic00,.tooltip-anchor.placement-top.alignment-center.svelte-jkic00{inset-inline-start:50%;transform:translateX(-50%)}.tooltip-anchor.placement-left.alignment-start.svelte-jkic00,.tooltip-anchor.placement-right.alignment-start.svelte-jkic00{inset-block-start:0}.tooltip-anchor.placement-left.alignment-end.svelte-jkic00,.tooltip-anchor.placement-right.alignment-end.svelte-jkic00{inset-block-end:0}.tooltip-anchor.placement-left.alignment-center.svelte-jkic00,.tooltip-anchor.placement-right.alignment-center.svelte-jkic00{inset-block-start:50%;transform:translateY(-50%)}.tooltip-anchor.placement-auto.svelte-jkic00{transform:translateY(-100%)}.tooltip-anchor.placement-auto.alignment-center.svelte-jkic00{transform:translate(-50%,-100%)}.tooltip-anchor.placement-auto.alignment-end.svelte-jkic00{transform:translate(-100%,-100%)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVG9vbHRpcFdyYXBwZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQThGUSw4QkFBQSxDQUFpQixRQUFBLEtBQWEsQ0FBQyxTQUFBLFFBQWlCLENBQUMsNkJBQUEsQ0FBZ0IsZUFBQSxJQUFtQixDQUFDLFNBQUEsUUFBaUIsQ0FBQyxRQUFBLEdBQVcsQ0FBQyxlQUFBLDRCQUFBLENBQThCLE9BQUEsS0FBQSxJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsb0JBQUEsQ0FBQSxDQUE2QyxDQUFDLGVBQUEsK0JBQUEsQ0FBaUMsSUFBQSxLQUFBLElBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxvQkFBQSxDQUFBLENBQTBDLENBQUMsZUFBQSw2QkFBQSxDQUErQixNQUFBLEtBQUEsSUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLG9CQUFBLENBQUEsQ0FBNEMsQ0FBQyxlQUFBLDhCQUFBLENBQWdDLEtBQUEsS0FBQSxJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsb0JBQUEsQ0FBQSxDQUEyQyxDQUFDLGVBQUEsaUJBQUEsOEJBQUEsQ0FBQSxlQUFBLGNBQUEsOEJBQUEsQ0FBK0YsbUJBQUEsQ0FBb0IsQ0FBQyxlQUFBLGlCQUFBLDRCQUFBLENBQUEsZUFBQSxjQUFBLDRCQUFBLENBQTJGLGlCQUFBLENBQWtCLENBQUMsZUFBQSxpQkFBQSwrQkFBQSxDQUFBLGVBQUEsY0FBQSwrQkFBQSxDQUFpRyxtQkFBQSxHQUFzQixDQUFDLFVBQUEsV0FBQSxJQUFBLENBQTBCLENBQUMsZUFBQSxlQUFBLDhCQUFBLENBQUEsZUFBQSxnQkFBQSw4QkFBQSxDQUErRixrQkFBQSxDQUFtQixDQUFDLGVBQUEsZUFBQSw0QkFBQSxDQUFBLGVBQUEsZ0JBQUEsNEJBQUEsQ0FBMkYsZ0JBQUEsQ0FBaUIsQ0FBQyxlQUFBLGVBQUEsK0JBQUEsQ0FBQSxlQUFBLGdCQUFBLCtCQUFBLENBQWlHLGtCQUFBLEdBQXFCLENBQUMsVUFBQSxXQUFBLElBQUEsQ0FBMEIsQ0FBQyxlQUFBLDZCQUFBLENBQStCLFVBQUEsV0FBQSxLQUFBLENBQTJCLENBQUMsZUFBQSxlQUFBLCtCQUFBLENBQWdELFVBQUEsVUFBQSxJQUFBLENBQUEsS0FBQSxDQUErQixDQUFDLGVBQUEsZUFBQSw0QkFBQSxDQUE2QyxVQUFBLFVBQUEsS0FBQSxDQUFBLEtBQUEsQ0FBZ0MsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJUb29sdGlwV3JhcHBlci5zdmVsdGUiXX0= */");
}
var get_tooltip_slot_changes2 = (dirty) => ({});
var get_tooltip_slot_context2 = (ctx) => ({});
function create_if_block16(ctx) {
  let div;
  let tooltipsurface;
  let updating_element;
  let div_class_value;
  let div_style_value;
  let div_intro;
  let current;
  const tooltipsurface_spread_levels = [
    /*$$restProps*/
    ctx[15]
  ];
  function tooltipsurface_element_binding(value) {
    ctx[19](value);
  }
  let tooltipsurface_props = {
    $$slots: { default: [create_default_slot8] },
    $$scope: { ctx }
  };
  for (let i = 0; i < tooltipsurface_spread_levels.length; i += 1) {
    tooltipsurface_props = assign(tooltipsurface_props, tooltipsurface_spread_levels[i]);
  }
  if (
    /*tooltipElement*/
    ctx[1] !== void 0
  ) {
    tooltipsurface_props.element = /*tooltipElement*/
    ctx[1];
  }
  tooltipsurface = new TooltipSurface_default({
    props: tooltipsurface_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(tooltipsurface, "element", tooltipsurface_element_binding));
  const block = {
    c: function create() {
      div = element("div");
      create_component(tooltipsurface.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      claim_component(tooltipsurface.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "tooltip-anchor placement-" + /*placement*/
      ctx[6] + " alignment-" + /*alignment*/
      ctx[7] + " svelte-jkic00");
      attr_dev(div, "style", div_style_value = /*placement*/
      (ctx[6] === "auto" ? `top: calc(${/*currentPosition*/
      ctx[10].y}px - var(--fds-tooltip-offset));
				   left: ${/*currentPosition*/
      ctx[10].x}px;` : "") + " --fds-tooltip-offset: " + /*offset*/
      ctx[5] + "px");
      add_location(div, file24, 77, 2, 2574);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(tooltipsurface, div, null);
      ctx[20](div);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const tooltipsurface_changes = dirty & /*$$restProps*/
      32768 ? get_spread_update(tooltipsurface_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx[15]
      )]) : {};
      if (dirty & /*$$scope, text*/
      8388624) {
        tooltipsurface_changes.$$scope = { dirty, ctx };
      }
      if (!updating_element && dirty & /*tooltipElement*/
      2) {
        updating_element = true;
        tooltipsurface_changes.element = /*tooltipElement*/
        ctx[1];
        add_flush_callback(() => updating_element = false);
      }
      tooltipsurface.$set(tooltipsurface_changes);
      if (!current || dirty & /*placement, alignment*/
      192 && div_class_value !== (div_class_value = "tooltip-anchor placement-" + /*placement*/
      ctx[6] + " alignment-" + /*alignment*/
      ctx[7] + " svelte-jkic00")) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*placement, currentPosition, offset*/
      1120 && div_style_value !== (div_style_value = /*placement*/
      (ctx[6] === "auto" ? `top: calc(${/*currentPosition*/
      ctx[10].y}px - var(--fds-tooltip-offset));
				   left: ${/*currentPosition*/
      ctx[10].x}px;` : "") + " --fds-tooltip-offset: " + /*offset*/
      ctx[5] + "px")) {
        attr_dev(div, "style", div_style_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tooltipsurface.$$.fragment, local);
      if (local) {
        if (!div_intro) {
          add_render_callback(() => {
            div_intro = create_in_transition(div, fade, {
              duration: getCSSDuration("--fds-control-fast-duration")
            });
            div_intro.start();
          });
        }
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(tooltipsurface.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(tooltipsurface);
      ctx[20](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block16.name,
    type: "if",
    source: "(77:1) {#if visible}",
    ctx
  });
  return block;
}
function create_default_slot8(ctx) {
  let t0;
  let t1;
  let current;
  const tooltip_slot_template = (
    /*#slots*/
    ctx[18].tooltip
  );
  const tooltip_slot = create_slot(
    tooltip_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    get_tooltip_slot_context2
  );
  const block = {
    c: function create() {
      t0 = text(
        /*text*/
        ctx[4]
      );
      t1 = space();
      if (tooltip_slot)
        tooltip_slot.c();
    },
    l: function claim(nodes) {
      t0 = claim_text(
        nodes,
        /*text*/
        ctx[4]
      );
      t1 = claim_space(nodes);
      if (tooltip_slot)
        tooltip_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (tooltip_slot) {
        tooltip_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*text*/
      16)
        set_data_dev(
          t0,
          /*text*/
          ctx2[4]
        );
      if (tooltip_slot) {
        if (tooltip_slot.p && (!current || dirty & /*$$scope*/
        8388608)) {
          update_slot_base(
            tooltip_slot,
            tooltip_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              tooltip_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              get_tooltip_slot_changes2
            ),
            get_tooltip_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tooltip_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tooltip_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
      if (tooltip_slot)
        tooltip_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: "(87:3) <TooltipSurface bind:element={tooltipElement} {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment24(ctx) {
  let div;
  let t;
  let div_title_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    null
  );
  let if_block = (
    /*visible*/
    ctx[0] && create_if_block16(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, title: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "tooltip-wrapper svelte-jkic00");
      attr_dev(div, "title", div_title_value = /*mounted*/
      ctx[9] ? void 0 : (
        /*text*/
        ctx[4]
      ));
      add_location(div, file24, 62, 0, 2218);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_hydration_dev(div, t);
      if (if_block)
        if_block.m(div, null);
      ctx[21](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "scroll",
            /*destroyTooltip*/
            ctx[14],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mountTooltip*/
            ctx[13],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*destroyTooltip*/
            ctx[14],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mousemove",
            /*updateMousePosition*/
            ctx[11],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mousemove",
            /*mousemove_handler*/
            ctx[22],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8388608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*visible*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*visible*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block16(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*mounted, text*/
      528 && div_title_value !== (div_title_value = /*mounted*/
      ctx2[9] ? void 0 : (
        /*text*/
        ctx2[4]
      ))) {
        attr_dev(div, "title", div_title_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[21](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "text",
    "offset",
    "placement",
    "alignment",
    "followCursor",
    "persistent",
    "visible",
    "delay",
    "tooltipElement",
    "anchorElement",
    "wrapperElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TooltipWrapper", slots, ["default", "tooltip"]);
  let { text: text2 = "" } = $$props;
  let { offset = 24 } = $$props;
  let { placement = "auto" } = $$props;
  let { alignment = "center" } = $$props;
  let { followCursor = false } = $$props;
  let { persistent = false } = $$props;
  let { visible = false } = $$props;
  let { delay = 1e3 } = $$props;
  let { tooltipElement = null } = $$props;
  let { anchorElement = null } = $$props;
  let { wrapperElement = null } = $$props;
  let mounted = false;
  let tooltipDurationTimeout;
  let currentPosition = { x: 0, y: 0 };
  let mousePosition = { x: 0, y: 0 };
  onMount(() => $$invalidate(9, mounted = true));
  function updateMousePosition({ clientX, clientY }) {
    mousePosition.x = clientX;
    mousePosition.y = clientY;
  }
  function updateTooltipPositionAuto(wrapperPosition) {
    const { left, top } = wrapperPosition;
    $$invalidate(10, currentPosition.x = mousePosition.x - left, currentPosition);
    $$invalidate(10, currentPosition.y = mousePosition.y - top, currentPosition);
  }
  function mountTooltip() {
    tooltipDurationTimeout = setTimeout(
      () => {
        if (placement === "auto" && wrapperElement)
          updateTooltipPositionAuto(wrapperElement.getBoundingClientRect());
        $$invalidate(0, visible = true);
      },
      delay
    );
  }
  function destroyTooltip() {
    clearTimeout(tooltipDurationTimeout);
    if (!persistent)
      $$invalidate(0, visible = false);
  }
  function tooltipsurface_element_binding(value) {
    tooltipElement = value;
    $$invalidate(1, tooltipElement);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      anchorElement = $$value;
      $$invalidate(2, anchorElement);
    });
  }
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      wrapperElement = $$value;
      $$invalidate(3, wrapperElement);
    });
  }
  const mousemove_handler = () => placement === "auto" && followCursor && updateTooltipPositionAuto(wrapperElement.getBoundingClientRect());
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("text" in $$new_props)
      $$invalidate(4, text2 = $$new_props.text);
    if ("offset" in $$new_props)
      $$invalidate(5, offset = $$new_props.offset);
    if ("placement" in $$new_props)
      $$invalidate(6, placement = $$new_props.placement);
    if ("alignment" in $$new_props)
      $$invalidate(7, alignment = $$new_props.alignment);
    if ("followCursor" in $$new_props)
      $$invalidate(8, followCursor = $$new_props.followCursor);
    if ("persistent" in $$new_props)
      $$invalidate(16, persistent = $$new_props.persistent);
    if ("visible" in $$new_props)
      $$invalidate(0, visible = $$new_props.visible);
    if ("delay" in $$new_props)
      $$invalidate(17, delay = $$new_props.delay);
    if ("tooltipElement" in $$new_props)
      $$invalidate(1, tooltipElement = $$new_props.tooltipElement);
    if ("anchorElement" in $$new_props)
      $$invalidate(2, anchorElement = $$new_props.anchorElement);
    if ("wrapperElement" in $$new_props)
      $$invalidate(3, wrapperElement = $$new_props.wrapperElement);
    if ("$$scope" in $$new_props)
      $$invalidate(23, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    fade,
    getCSSDuration,
    TooltipSurface: TooltipSurface_default,
    text: text2,
    offset,
    placement,
    alignment,
    followCursor,
    persistent,
    visible,
    delay,
    tooltipElement,
    anchorElement,
    wrapperElement,
    mounted,
    tooltipDurationTimeout,
    currentPosition,
    mousePosition,
    updateMousePosition,
    updateTooltipPositionAuto,
    mountTooltip,
    destroyTooltip
  });
  $$self.$inject_state = ($$new_props) => {
    if ("text" in $$props)
      $$invalidate(4, text2 = $$new_props.text);
    if ("offset" in $$props)
      $$invalidate(5, offset = $$new_props.offset);
    if ("placement" in $$props)
      $$invalidate(6, placement = $$new_props.placement);
    if ("alignment" in $$props)
      $$invalidate(7, alignment = $$new_props.alignment);
    if ("followCursor" in $$props)
      $$invalidate(8, followCursor = $$new_props.followCursor);
    if ("persistent" in $$props)
      $$invalidate(16, persistent = $$new_props.persistent);
    if ("visible" in $$props)
      $$invalidate(0, visible = $$new_props.visible);
    if ("delay" in $$props)
      $$invalidate(17, delay = $$new_props.delay);
    if ("tooltipElement" in $$props)
      $$invalidate(1, tooltipElement = $$new_props.tooltipElement);
    if ("anchorElement" in $$props)
      $$invalidate(2, anchorElement = $$new_props.anchorElement);
    if ("wrapperElement" in $$props)
      $$invalidate(3, wrapperElement = $$new_props.wrapperElement);
    if ("mounted" in $$props)
      $$invalidate(9, mounted = $$new_props.mounted);
    if ("tooltipDurationTimeout" in $$props)
      tooltipDurationTimeout = $$new_props.tooltipDurationTimeout;
    if ("currentPosition" in $$props)
      $$invalidate(10, currentPosition = $$new_props.currentPosition);
    if ("mousePosition" in $$props)
      mousePosition = $$new_props.mousePosition;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    visible,
    tooltipElement,
    anchorElement,
    wrapperElement,
    text2,
    offset,
    placement,
    alignment,
    followCursor,
    mounted,
    currentPosition,
    updateMousePosition,
    updateTooltipPositionAuto,
    mountTooltip,
    destroyTooltip,
    $$restProps,
    persistent,
    delay,
    slots,
    tooltipsurface_element_binding,
    div_binding,
    div_binding_1,
    mousemove_handler,
    $$scope
  ];
}
var TooltipWrapper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance24,
      create_fragment24,
      safe_not_equal,
      {
        text: 4,
        offset: 5,
        placement: 6,
        alignment: 7,
        followCursor: 8,
        persistent: 16,
        visible: 0,
        delay: 17,
        tooltipElement: 1,
        anchorElement: 2,
        wrapperElement: 3
      },
      add_css24
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TooltipWrapper",
      options,
      id: create_fragment24.name
    });
  }
  get text() {
    throw new Error("<TooltipWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<TooltipWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get offset() {
    throw new Error("<TooltipWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set offset(value) {
    throw new Error("<TooltipWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placement() {
    throw new Error("<TooltipWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placement(value) {
    throw new Error("<TooltipWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alignment() {
    throw new Error("<TooltipWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alignment(value) {
    throw new Error("<TooltipWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get followCursor() {
    throw new Error("<TooltipWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set followCursor(value) {
    throw new Error("<TooltipWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get persistent() {
    throw new Error("<TooltipWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set persistent(value) {
    throw new Error("<TooltipWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<TooltipWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<TooltipWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get delay() {
    throw new Error("<TooltipWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set delay(value) {
    throw new Error("<TooltipWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipElement() {
    throw new Error("<TooltipWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipElement(value) {
    throw new Error("<TooltipWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchorElement() {
    throw new Error("<TooltipWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchorElement(value) {
    throw new Error("<TooltipWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapperElement() {
    throw new Error("<TooltipWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapperElement(value) {
    throw new Error("<TooltipWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TooltipWrapper_default = TooltipWrapper;

// node_modules/fluent-svelte/ContentDialog/ContentDialog.svelte
var file25 = "node_modules\\fluent-svelte\\ContentDialog\\ContentDialog.svelte";
function add_css25(target) {
  append_styles(target, "svelte-1p5e9lq", ".content-dialog.svelte-1p5e9lq{-webkit-animation:dialog-inner var(--fds-control-fast-duration) var(--fds-control-fast-out-slow-in-easing);animation:dialog-inner var(--fds-control-fast-duration) var(--fds-control-fast-out-slow-in-easing);background-clip:padding-box;background-color:var(--fds-solid-background-base);border:1px solid var(--fds-surface-stroke-default);border-radius:var(--fds-overlay-corner-radius);box-shadow:var(--fds-dialog-shadow);box-sizing:border-box;max-inline-size:calc(100% - 24px);overflow:hidden;position:fixed}.content-dialog.size-min.svelte-1p5e9lq{inline-size:320px}.content-dialog.size-standard.svelte-1p5e9lq{inline-size:448px}.content-dialog.size-max.svelte-1p5e9lq{inline-size:540px}.content-dialog-smoke.svelte-1p5e9lq{align-items:center;block-size:100%;display:flex;flex-direction:column;inline-size:100%;inset-block-start:0;inset-inline-start:0;justify-content:center;position:fixed;z-index:101}.content-dialog-smoke.darken.svelte-1p5e9lq{background-color:var(--fds-smoke-background-default)}.content-dialog.svelte-1p5e9lq .content-dialog-title{color:var(--fds-text-primary);display:block;margin-bottom:12px}.content-dialog-body.svelte-1p5e9lq,.content-dialog-footer.svelte-1p5e9lq{padding:24px}.content-dialog-body.svelte-1p5e9lq{background-color:var(--fds-layer-background-default);color:var(--fds-text-primary);font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;line-height:20px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.content-dialog-footer.svelte-1p5e9lq{grid-gap:8px;-webkit-border-before:1px solid var(--fds-card-stroke-default);border-block-start:1px solid var(--fds-card-stroke-default);display:grid;grid-auto-flow:column;grid-auto-rows:1fr;white-space:nowrap}.content-dialog-footer.svelte-1p5e9lq>.button:only-child{inline-size:50%;justify-self:end}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29udGVudERpYWxvZy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBd0dRLDhCQUFBLENBQWdCLGtCQUFBLFlBQUEsQ0FBQSxJQUFBLDJCQUFBLENBQUEsQ0FBQSxJQUFBLHFDQUFBLENBQTBHLENBQUMsVUFBQSxZQUFBLENBQUEsSUFBQSwyQkFBQSxDQUFBLENBQUEsSUFBQSxxQ0FBQSxDQUFrRyxDQUFDLGdCQUFBLFdBQTJCLENBQUMsaUJBQUEsSUFBQSwyQkFBQSxDQUFpRCxDQUFDLE9BQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLDRCQUFBLENBQWtELENBQUMsY0FBQSxJQUFBLDJCQUFBLENBQThDLENBQUMsV0FBQSxJQUFBLG1CQUFBLENBQW1DLENBQUMsV0FBQSxVQUFxQixDQUFDLGdCQUFBLEtBQUEsSUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQWlDLENBQUMsU0FBQSxNQUFlLENBQUMsU0FBQSxLQUFjLENBQUMsZUFBQSx3QkFBQSxDQUF5QixZQUFBLEtBQWlCLENBQUMsZUFBQSw2QkFBQSxDQUE4QixZQUFBLEtBQWlCLENBQUMsZUFBQSx3QkFBQSxDQUF5QixZQUFBLEtBQWlCLENBQUMsb0NBQUEsQ0FBc0IsWUFBQSxNQUFrQixDQUFDLFdBQUEsSUFBZSxDQUFDLFFBQUEsSUFBWSxDQUFDLGVBQUEsTUFBcUIsQ0FBQyxZQUFBLElBQWdCLENBQUMsa0JBQUEsQ0FBbUIsQ0FBQyxtQkFBQSxDQUFvQixDQUFDLGdCQUFBLE1BQXNCLENBQUMsU0FBQSxLQUFjLENBQUMsUUFBQSxHQUFXLENBQUMscUJBQUEsc0JBQUEsQ0FBNkIsaUJBQUEsSUFBQSw4QkFBQSxDQUFvRCxDQUFDLDhCQUFBLENBQUEsQUFBQSxxQkFBQSxBQUFBLENBQStDLE1BQUEsSUFBQSxrQkFBQSxDQUE2QixDQUFDLFFBQUEsS0FBYSxDQUFDLGNBQUEsSUFBa0IsQ0FBQyxtQ0FBQSxDQUFBLHFDQUFBLENBQTRDLFFBQUEsSUFBWSxDQUFDLG1DQUFBLENBQXFCLGlCQUFBLElBQUEsOEJBQUEsQ0FBb0QsQ0FBQyxNQUFBLElBQUEsa0JBQUEsQ0FBNkIsQ0FBQyxZQUFBLElBQUEsc0JBQUEsQ0FBdUMsQ0FBQyxVQUFBLElBQUEsb0JBQUEsQ0FBbUMsQ0FBQyxZQUFBLEdBQWUsQ0FBQyxZQUFBLElBQWdCLENBQUMsb0JBQUEsSUFBd0IsQ0FBQyxpQkFBQSxJQUFxQixDQUFDLGdCQUFBLElBQW9CLENBQUMsWUFBQSxJQUFnQixDQUFDLHFDQUFBLENBQXVCLFNBQUEsR0FBWSxDQUFDLHNCQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSx5QkFBQSxDQUE4RCxDQUFDLG1CQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSx5QkFBQSxDQUEyRCxDQUFDLFFBQUEsSUFBWSxDQUFDLGVBQUEsTUFBcUIsQ0FBQyxlQUFBLEdBQWtCLENBQUMsWUFBQSxNQUFrQixDQUFDLHFDQUFBLENBQUEsQUFBQSxrQkFBQSxBQUFBLENBQW1ELFlBQUEsR0FBZSxDQUFDLGFBQUEsR0FBZ0IsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDb250ZW50RGlhbG9nLnN2ZWx0ZSJdfQ== */");
}
var get_outer_slot_changes = (dirty) => ({});
var get_outer_slot_context = (ctx) => ({});
var get_footer_slot_changes = (dirty) => ({});
var get_footer_slot_context = (ctx) => ({});
function create_if_block17(ctx) {
  let div2;
  let div1;
  let div0;
  let t0;
  let t1;
  let div1_class_value;
  let div1_aria_labelledby_value;
  let forwardEvents_action;
  let div1_transition;
  let t2;
  let mountDialog_action;
  let _focusTrap_action;
  let div2_transition;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*title*/
    ctx[5] && create_if_block_27(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    null
  );
  let if_block1 = (
    /*$$slots*/
    ctx[17].footer && create_if_block_113(ctx)
  );
  let div1_levels = [
    {
      class: div1_class_value = "content-dialog size-" + /*size*/
      ctx[6] + " " + /*className*/
      ctx[8]
    },
    { role: "dialog" },
    { "aria-modal": "true" },
    {
      "aria-labelledby": div1_aria_labelledby_value = /*title*/
      ctx[5] && /*titleId*/
      ctx[12]
    },
    { "aria-describedby": (
      /*bodyId*/
      ctx[13]
    ) },
    /*$$restProps*/
    ctx[16]
  ];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const outer_slot_template = (
    /*#slots*/
    ctx[21].outer
  );
  const outer_slot = create_slot(
    outer_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_outer_slot_context
  );
  const block = {
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (outer_slot)
        outer_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", {
        class: true,
        role: true,
        "aria-modal": true,
        "aria-labelledby": true,
        "aria-describedby": true
      });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true, id: true });
      var div0_nodes = children(div0);
      if (if_block0)
        if_block0.l(div0_nodes);
      t0 = claim_space(div0_nodes);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      if (if_block1)
        if_block1.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t2 = claim_space(div2_nodes);
      if (outer_slot)
        outer_slot.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "content-dialog-body svelte-1p5e9lq");
      attr_dev(
        div0,
        "id",
        /*bodyId*/
        ctx[13]
      );
      add_location(div0, file25, 86, 3, 2930);
      set_attributes(div1, div1_data);
      toggle_class(div1, "svelte-1p5e9lq", true);
      add_location(div1, file25, 71, 2, 2566);
      attr_dev(div2, "class", "content-dialog-smoke svelte-1p5e9lq");
      toggle_class(
        div2,
        "darken",
        /*darken*/
        ctx[7]
      );
      add_location(div2, file25, 61, 1, 2245);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration_dev(div0, t0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[22](div0);
      append_hydration_dev(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      ctx[24](div1);
      append_hydration_dev(div2, t2);
      if (outer_slot) {
        outer_slot.m(div2, null);
      }
      ctx[27](div2);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[10].call(null, div1)),
          listen_dev(div2, "click", self(
            /*click_handler*/
            ctx[25]
          ), false, false, false),
          listen_dev(div2, "mousedown", self(
            /*mousedown_handler*/
            ctx[26]
          ), false, false, false),
          action_destroyer(mountDialog_action = /*mountDialog*/
          ctx[14].call(null, div2)),
          action_destroyer(_focusTrap_action = /*_focusTrap*/
          ctx[9].call(null, div2))
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*title*/
        ctx[5]
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty & /*title*/
          32) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_27(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        268435456)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[28]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[28],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*$$slots*/
        ctx[17].footer
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty & /*$$slots*/
          131072) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_113(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [
        (!current || dirty & /*size, className*/
        320 && div1_class_value !== (div1_class_value = "content-dialog size-" + /*size*/
        ctx[6] + " " + /*className*/
        ctx[8])) && { class: div1_class_value },
        { role: "dialog" },
        { "aria-modal": "true" },
        (!current || dirty & /*title*/
        32 && div1_aria_labelledby_value !== (div1_aria_labelledby_value = /*title*/
        ctx[5] && /*titleId*/
        ctx[12])) && {
          "aria-labelledby": div1_aria_labelledby_value
        },
        { "aria-describedby": (
          /*bodyId*/
          ctx[13]
        ) },
        dirty & /*$$restProps*/
        65536 && /*$$restProps*/
        ctx[16]
      ]));
      toggle_class(div1, "svelte-1p5e9lq", true);
      if (outer_slot) {
        if (outer_slot.p && (!current || dirty & /*$$scope*/
        268435456)) {
          update_slot_base(
            outer_slot,
            outer_slot_template,
            ctx,
            /*$$scope*/
            ctx[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[28]
            ) : get_slot_changes(
              outer_slot_template,
              /*$$scope*/
              ctx[28],
              dirty,
              get_outer_slot_changes
            ),
            get_outer_slot_context
          );
        }
      }
      if (!current || dirty & /*darken*/
      128) {
        toggle_class(
          div2,
          "darken",
          /*darken*/
          ctx[7]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      transition_in(if_block1);
      if (local) {
        add_render_callback(() => {
          if (!div1_transition)
            div1_transition = create_bidirectional_transition(
              div1,
              scale,
              {
                duration: getCSSDuration("--fds-control-fast-duration"),
                start: 1.05,
                easing: circOut
              },
              true
            );
          div1_transition.run(1);
        });
      }
      transition_in(outer_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!div2_transition)
            div2_transition = create_bidirectional_transition(
              div2,
              fade,
              {
                duration: getCSSDuration("--fds-control-faster-duration")
              },
              true
            );
          div2_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      transition_out(if_block1);
      if (local) {
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(
            div1,
            scale,
            {
              duration: getCSSDuration("--fds-control-fast-duration"),
              start: 1.05,
              easing: circOut
            },
            false
          );
        div1_transition.run(0);
      }
      transition_out(outer_slot, local);
      if (local) {
        if (!div2_transition)
          div2_transition = create_bidirectional_transition(
            div2,
            fade,
            {
              duration: getCSSDuration("--fds-control-faster-duration")
            },
            false
          );
        div2_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block0)
        if_block0.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[22](null);
      if (if_block1)
        if_block1.d();
      ctx[24](null);
      if (detaching && div1_transition)
        div1_transition.end();
      if (outer_slot)
        outer_slot.d(detaching);
      ctx[27](null);
      if (detaching && div2_transition)
        div2_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block17.name,
    type: "if",
    source: "(61:0) {#if open}",
    ctx
  });
  return block;
}
function create_if_block_27(ctx) {
  let textblock;
  let current;
  textblock = new TextBlock_default({
    props: {
      variant: "subtitle",
      class: "content-dialog-title",
      id: (
        /*titleId*/
        ctx[12]
      ),
      $$slots: { default: [create_default_slot9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(textblock.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(textblock.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(textblock, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const textblock_changes = {};
      if (dirty & /*$$scope, title*/
      268435488) {
        textblock_changes.$$scope = { dirty, ctx: ctx2 };
      }
      textblock.$set(textblock_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(textblock.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(textblock.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(textblock, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_27.name,
    type: "if",
    source: "(88:4) {#if title}",
    ctx
  });
  return block;
}
function create_default_slot9(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*title*/
        ctx[5]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*title*/
        ctx[5]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      32)
        set_data_dev(
          t,
          /*title*/
          ctx2[5]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot9.name,
    type: "slot",
    source: '(89:5) <TextBlock variant=\\"subtitle\\" class=\\"content-dialog-title\\" id={titleId}>',
    ctx
  });
  return block;
}
function create_if_block_113(ctx) {
  let footer;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[21].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_footer_slot_context
  );
  const block = {
    c: function create() {
      footer = element("footer");
      if (footer_slot)
        footer_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      footer = claim_element(nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      if (footer_slot)
        footer_slot.l(footer_nodes);
      footer_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(footer, "class", "content-dialog-footer svelte-1p5e9lq");
      add_location(footer, file25, 95, 4, 3187);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, footer, anchor);
      if (footer_slot) {
        footer_slot.m(footer, null);
      }
      ctx[23](footer);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty & /*$$scope*/
        268435456)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              get_footer_slot_changes
            ),
            get_footer_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(footer);
      if (footer_slot)
        footer_slot.d(detaching);
      ctx[23](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_113.name,
    type: "if",
    source: "(95:3) {#if $$slots.footer}",
    ctx
  });
  return block;
}
function create_fragment25(ctx) {
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*open*/
    ctx[0] && create_if_block17(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window,
          "keydown",
          /*handleEscapeKey*/
          ctx[15],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*open*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*open*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block17(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  let _focusTrap;
  const omit_props_names = [
    "open",
    "title",
    "size",
    "closable",
    "append",
    "darken",
    "trapFocus",
    "class",
    "element",
    "backdropElement",
    "bodyElement",
    "footerElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContentDialog", slots, ["default", "footer", "outer"]);
  const $$slots = compute_slots(slots);
  let { open = false } = $$props;
  let { title = "" } = $$props;
  let { size = "standard" } = $$props;
  let { closable = true } = $$props;
  let { append = void 0 } = $$props;
  let { darken = true } = $$props;
  let { trapFocus = true } = $$props;
  let { class: className = "" } = $$props;
  let { element: element2 = null } = $$props;
  let { backdropElement = null } = $$props;
  let { bodyElement = null } = $$props;
  let { footerElement = null } = $$props;
  const forwardEvents = createEventForwarder(get_current_component(), ["open", "close", "backdropclick", "backdropmousedown"]);
  const dispatch = createEventDispatcher();
  const titleId = uid("fds-dialog-title-");
  const bodyId = uid("fds-dialog-body-");
  function mountDialog(node) {
    dispatch("open");
    if (append)
      append.appendChild(node);
    node.focus();
  }
  function close() {
    $$invalidate(0, open = false);
  }
  function handleEscapeKey({ key }) {
    if (key === "Escape" && open && closable)
      close();
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      bodyElement = $$value;
      $$invalidate(3, bodyElement);
    });
  }
  function footer_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      footerElement = $$value;
      $$invalidate(4, footerElement);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  const click_handler3 = (e) => dispatch("backdropclick", e);
  const mousedown_handler = (e) => dispatch("backdropmousedown", e);
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      backdropElement = $$value;
      $$invalidate(2, backdropElement);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("title" in $$new_props)
      $$invalidate(5, title = $$new_props.title);
    if ("size" in $$new_props)
      $$invalidate(6, size = $$new_props.size);
    if ("closable" in $$new_props)
      $$invalidate(18, closable = $$new_props.closable);
    if ("append" in $$new_props)
      $$invalidate(19, append = $$new_props.append);
    if ("darken" in $$new_props)
      $$invalidate(7, darken = $$new_props.darken);
    if ("trapFocus" in $$new_props)
      $$invalidate(20, trapFocus = $$new_props.trapFocus);
    if ("class" in $$new_props)
      $$invalidate(8, className = $$new_props.class);
    if ("element" in $$new_props)
      $$invalidate(1, element2 = $$new_props.element);
    if ("backdropElement" in $$new_props)
      $$invalidate(2, backdropElement = $$new_props.backdropElement);
    if ("bodyElement" in $$new_props)
      $$invalidate(3, bodyElement = $$new_props.bodyElement);
    if ("footerElement" in $$new_props)
      $$invalidate(4, footerElement = $$new_props.footerElement);
    if ("$$scope" in $$new_props)
      $$invalidate(28, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    get_current_component,
    fade,
    scale,
    circOut,
    uid,
    focusTrap,
    getCSSDuration,
    createEventForwarder,
    TextBlock: TextBlock_default,
    open,
    title,
    size,
    closable,
    append,
    darken,
    trapFocus,
    className,
    element: element2,
    backdropElement,
    bodyElement,
    footerElement,
    forwardEvents,
    dispatch,
    titleId,
    bodyId,
    mountDialog,
    close,
    handleEscapeKey,
    _focusTrap
  });
  $$self.$inject_state = ($$new_props) => {
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("title" in $$props)
      $$invalidate(5, title = $$new_props.title);
    if ("size" in $$props)
      $$invalidate(6, size = $$new_props.size);
    if ("closable" in $$props)
      $$invalidate(18, closable = $$new_props.closable);
    if ("append" in $$props)
      $$invalidate(19, append = $$new_props.append);
    if ("darken" in $$props)
      $$invalidate(7, darken = $$new_props.darken);
    if ("trapFocus" in $$props)
      $$invalidate(20, trapFocus = $$new_props.trapFocus);
    if ("className" in $$props)
      $$invalidate(8, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(1, element2 = $$new_props.element);
    if ("backdropElement" in $$props)
      $$invalidate(2, backdropElement = $$new_props.backdropElement);
    if ("bodyElement" in $$props)
      $$invalidate(3, bodyElement = $$new_props.bodyElement);
    if ("footerElement" in $$props)
      $$invalidate(4, footerElement = $$new_props.footerElement);
    if ("_focusTrap" in $$props)
      $$invalidate(9, _focusTrap = $$new_props._focusTrap);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open*/
    1) {
      $:
        if (!open)
          dispatch("close");
    }
    if ($$self.$$.dirty & /*trapFocus*/
    1048576) {
      $:
        $$invalidate(9, _focusTrap = trapFocus ? focusTrap : () => {
        });
    }
  };
  return [
    open,
    element2,
    backdropElement,
    bodyElement,
    footerElement,
    title,
    size,
    darken,
    className,
    _focusTrap,
    forwardEvents,
    dispatch,
    titleId,
    bodyId,
    mountDialog,
    handleEscapeKey,
    $$restProps,
    $$slots,
    closable,
    append,
    trapFocus,
    slots,
    div0_binding,
    footer_binding,
    div1_binding,
    click_handler3,
    mousedown_handler,
    div2_binding,
    $$scope
  ];
}
var ContentDialog = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance25,
      create_fragment25,
      safe_not_equal,
      {
        open: 0,
        title: 5,
        size: 6,
        closable: 18,
        append: 19,
        darken: 7,
        trapFocus: 20,
        class: 8,
        element: 1,
        backdropElement: 2,
        bodyElement: 3,
        footerElement: 4
      },
      add_css25
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContentDialog",
      options,
      id: create_fragment25.name
    });
  }
  get open() {
    throw new Error("<ContentDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<ContentDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ContentDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ContentDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<ContentDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ContentDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closable() {
    throw new Error("<ContentDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closable(value) {
    throw new Error("<ContentDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get append() {
    throw new Error("<ContentDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set append(value) {
    throw new Error("<ContentDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get darken() {
    throw new Error("<ContentDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set darken(value) {
    throw new Error("<ContentDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get trapFocus() {
    throw new Error("<ContentDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set trapFocus(value) {
    throw new Error("<ContentDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ContentDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ContentDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<ContentDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<ContentDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdropElement() {
    throw new Error("<ContentDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdropElement(value) {
    throw new Error("<ContentDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bodyElement() {
    throw new Error("<ContentDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bodyElement(value) {
    throw new Error("<ContentDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get footerElement() {
    throw new Error("<ContentDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set footerElement(value) {
    throw new Error("<ContentDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContentDialog_default = ContentDialog;

// node_modules/fluent-svelte/Expander/Expander.svelte
var file26 = "node_modules\\fluent-svelte\\Expander\\Expander.svelte";
function add_css26(target) {
  append_styles(target, "svelte-1rpjzrl", ".expander.svelte-1rpjzrl.svelte-1rpjzrl{border-radius:var(--fds-control-corner-radius);color:var(--fds-text-primary);display:flex;flex-direction:column;inline-size:100%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.expander.direction-down.svelte-1rpjzrl .expander-content.svelte-1rpjzrl{-webkit-border-before:none;border-block-start:none;border-radius:var(--fds-control-corner-radius);border-start-end-radius:0;border-start-start-radius:0;transform:translateY(-100%)}.expander.direction-down.expanded.svelte-1rpjzrl .expander-header.svelte-1rpjzrl{border-end-end-radius:0;border-end-start-radius:0;border-radius:var(--fds-control-corner-radius)}.expander.direction-up.svelte-1rpjzrl .expander-content.svelte-1rpjzrl{border-bottom:none;border-end-end-radius:0;border-end-start-radius:0;border-radius:var(--fds-control-corner-radius);transform:translateY(100%)}.expander.direction-up.svelte-1rpjzrl .expander-content-anchor.svelte-1rpjzrl{order:-1}.expander.direction-up.expanded.svelte-1rpjzrl .expander-header.svelte-1rpjzrl{border-radius:var(--fds-control-corner-radius);border-start-end-radius:0;border-start-start-radius:0}.expander.expanded.svelte-1rpjzrl .expander-content.svelte-1rpjzrl{transform:none;transition:var(--fds-control-slow-duration) var(--fds-control-fast-out-slow-in-easing) transform}.expander.expanded.svelte-1rpjzrl .expander-content-anchor.svelte-1rpjzrl{max-block-size:6.019999999999999e+23vmax;transition:none}.expander.expanded.svelte-1rpjzrl .expander-chevron svg.svelte-1rpjzrl{transform:rotate(180deg)}.expander-icon.svelte-1rpjzrl.svelte-1rpjzrl{-webkit-margin-end:16px;block-size:16px;color:var(--fds-text-primary);flex:0 0 auto;inline-size:16px;margin-inline-end:16px}.expander-icon.svelte-1rpjzrl>svg{fill:currentColor;block-size:auto;inline-size:16px}.expander-header.svelte-1rpjzrl.svelte-1rpjzrl{-webkit-padding-start:16px;align-items:center;background-clip:padding-box;background-color:var(--fds-card-background-default);border:1px solid var(--fds-card-stroke-default);border-radius:var(--fds-control-corner-radius);box-sizing:border-box;display:flex;font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;line-height:20px;outline:none;padding:8px;padding-inline-start:16px;text-align:start;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.expander-header-title.svelte-1rpjzrl.svelte-1rpjzrl{flex:1 1 auto}.expander-header.svelte-1rpjzrl.svelte-1rpjzrl:focus-visible{box-shadow:var(--fds-focus-stroke)}.expander-header.svelte-1rpjzrl:hover .expander-chevron.svelte-1rpjzrl{background-color:var(--fds-subtle-fill-secondary)}.expander-header.svelte-1rpjzrl:active .expander-chevron.svelte-1rpjzrl{background-color:var(--fds-subtle-fill-tertiary);color:var(--fds-text-secondary)}.expander-chevron.svelte-1rpjzrl.svelte-1rpjzrl{-webkit-margin-start:20px;align-items:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:var(--fds-subtle-fill-transparent);block-size:32px;border:none;border-radius:var(--fds-control-corner-radius);color:var(--fds-text-primary);display:flex;flex:0 0 auto;inline-size:32px;justify-content:center;margin-inline-start:20px;outline:none}.expander-chevron.svelte-1rpjzrl.svelte-1rpjzrl:focus-visible{box-shadow:var(--fds-focus-stroke)}.expander-chevron.svelte-1rpjzrl svg.svelte-1rpjzrl{fill:currentColor;block-size:12px;inline-size:12px;transition:calc(var(--fds-control-faster-duration)*1.2) linear transform var(--fds-control-faster-duration)}.expander-content.svelte-1rpjzrl.svelte-1rpjzrl{background-clip:padding-box;background-color:var(--fds-card-background-secondary);border:1px solid var(--fds-card-stroke-default);font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;line-height:20px;padding:16px;transition:var(--fds-control-fast-duration) cubic-bezier(1,1,0,1) transform;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.expander-content-anchor.svelte-1rpjzrl.svelte-1rpjzrl{max-height:0;overflow:hidden;position:relative;transition:0ms linear var(--fds-control-slow-duration) max-height}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRXhwYW5kZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTRHUSx1Q0FBQSxDQUFVLGNBQUEsSUFBQSwyQkFBQSxDQUE4QyxDQUFDLE1BQUEsSUFBQSxrQkFBQSxDQUE2QixDQUFDLFFBQUEsSUFBWSxDQUFDLGVBQUEsTUFBcUIsQ0FBQyxZQUFBLElBQWdCLENBQUMsb0JBQUEsSUFBd0IsQ0FBQyxpQkFBQSxJQUFxQixDQUFDLGdCQUFBLElBQW9CLENBQUMsWUFBQSxJQUFnQixDQUFDLFNBQUEsOEJBQUEsQ0FBQSxnQ0FBQSxDQUEyQyxzQkFBQSxJQUEwQixDQUFDLG1CQUFBLElBQXVCLENBQUMsY0FBQSxJQUFBLDJCQUFBLENBQThDLENBQUMsd0JBQUEsQ0FBeUIsQ0FBQywwQkFBQSxDQUEyQixDQUFDLFVBQUEsV0FBQSxLQUFBLENBQTJCLENBQUMsU0FBQSxlQUFBLHdCQUFBLENBQUEsK0JBQUEsQ0FBbUQsc0JBQUEsQ0FBdUIsQ0FBQyx3QkFBQSxDQUF5QixDQUFDLGNBQUEsSUFBQSwyQkFBQSxDQUE4QyxDQUFDLFNBQUEsNEJBQUEsQ0FBQSxnQ0FBQSxDQUF5QyxjQUFBLElBQWtCLENBQUMsc0JBQUEsQ0FBdUIsQ0FBQyx3QkFBQSxDQUF5QixDQUFDLGNBQUEsSUFBQSwyQkFBQSxDQUE4QyxDQUFDLFVBQUEsV0FBQSxJQUFBLENBQTBCLENBQUMsU0FBQSw0QkFBQSxDQUFBLHVDQUFBLENBQWdELE1BQUEsRUFBUSxDQUFDLFNBQUEsYUFBQSx3QkFBQSxDQUFBLCtCQUFBLENBQWlELGNBQUEsSUFBQSwyQkFBQSxDQUE4QyxDQUFDLHdCQUFBLENBQXlCLENBQUMsMEJBQUEsQ0FBMkIsQ0FBQyxTQUFBLHdCQUFBLENBQUEsZ0NBQUEsQ0FBcUMsVUFBQSxJQUFjLENBQUMsV0FBQSxJQUFBLDJCQUFBLENBQUEsQ0FBQSxJQUFBLHFDQUFBLENBQUEsQ0FBQSxTQUFnRyxDQUFDLFNBQUEsd0JBQUEsQ0FBQSx1Q0FBQSxDQUE0QyxlQUFBLHlCQUF3QyxDQUFDLFdBQUEsSUFBZSxDQUFDLFNBQUEsd0JBQUEsQ0FBQSxpQkFBQSxDQUFBLGtCQUFBLENBQXlDLFVBQUEsT0FBQSxNQUFBLENBQXdCLENBQUMsQUFBOEIsNENBQUEsQ0FBZSxtQkFBQSxJQUF1QixDQUFDLFdBQUEsSUFBZSxDQUFDLE1BQUEsSUFBQSxrQkFBQSxDQUE2QixDQUFDLEtBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxJQUFhLENBQUMsWUFBQSxJQUFnQixDQUFDLGtCQUFBLElBQXNCLENBQUMsNkJBQUEsQ0FBQSxBQUFBLEdBQUEsQUFBQSxDQUE0QixLQUFBLFlBQWlCLENBQUMsV0FBQSxJQUFlLENBQUMsWUFBQSxJQUFnQixDQUFDLDhDQUFBLENBQWlCLHNCQUFBLElBQTBCLENBQUMsWUFBQSxNQUFrQixDQUFDLGdCQUFBLFdBQTJCLENBQUMsaUJBQUEsSUFBQSw2QkFBQSxDQUFtRCxDQUFDLE9BQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLHlCQUFBLENBQStDLENBQUMsY0FBQSxJQUFBLDJCQUFBLENBQThDLENBQUMsV0FBQSxVQUFxQixDQUFDLFFBQUEsSUFBWSxDQUFDLFlBQUEsSUFBQSxzQkFBQSxDQUF1QyxDQUFDLFVBQUEsSUFBQSxvQkFBQSxDQUFtQyxDQUFDLFlBQUEsR0FBZSxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxRQUFBLElBQVksQ0FBQyxRQUFBLEdBQVcsQ0FBQyxxQkFBQSxJQUF5QixDQUFDLFdBQUEsS0FBZ0IsQ0FBQyxvQkFBQSxJQUF3QixDQUFDLGlCQUFBLElBQXFCLENBQUMsZ0JBQUEsSUFBb0IsQ0FBQyxZQUFBLElBQWdCLENBQUMsb0RBQUEsQ0FBdUIsS0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLElBQWEsQ0FBQyw4Q0FBQSxjQUFBLENBQStCLFdBQUEsSUFBQSxrQkFBQSxDQUFrQyxDQUFDLCtCQUFBLE1BQUEsQ0FBQSxnQ0FBQSxDQUF5QyxpQkFBQSxJQUFBLDJCQUFBLENBQWlELENBQUMsK0JBQUEsT0FBQSxDQUFBLGdDQUFBLENBQTBDLGlCQUFBLElBQUEsMEJBQUEsQ0FBZ0QsQ0FBQyxNQUFBLElBQUEsb0JBQUEsQ0FBK0IsQ0FBQywrQ0FBQSxDQUFrQixxQkFBQSxJQUF5QixDQUFDLFlBQUEsTUFBa0IsQ0FBQyxtQkFBQSxJQUF1QixDQUFDLGdCQUFBLElBQW9CLENBQUMsV0FBQSxJQUFlLENBQUMsaUJBQUEsSUFBQSw2QkFBQSxDQUFtRCxDQUFDLFdBQUEsSUFBZSxDQUFDLE9BQUEsSUFBVyxDQUFDLGNBQUEsSUFBQSwyQkFBQSxDQUE4QyxDQUFDLE1BQUEsSUFBQSxrQkFBQSxDQUE2QixDQUFDLFFBQUEsSUFBWSxDQUFDLEtBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxJQUFhLENBQUMsWUFBQSxJQUFnQixDQUFDLGdCQUFBLE1BQXNCLENBQUMsb0JBQUEsSUFBd0IsQ0FBQyxRQUFBLElBQVksQ0FBQywrQ0FBQSxjQUFBLENBQWdDLFdBQUEsSUFBQSxrQkFBQSxDQUFrQyxDQUFDLGdDQUFBLENBQUEsa0JBQUEsQ0FBc0IsS0FBQSxZQUFpQixDQUFDLFdBQUEsSUFBZSxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxXQUFBLEtBQUEsSUFBQSw2QkFBQSxDQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsTUFBQSxDQUFBLFNBQUEsQ0FBQSxJQUFBLDZCQUFBLENBQTJHLENBQUMsK0NBQUEsQ0FBa0IsZ0JBQUEsV0FBMkIsQ0FBQyxpQkFBQSxJQUFBLCtCQUFBLENBQXFELENBQUMsT0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEseUJBQUEsQ0FBK0MsQ0FBQyxZQUFBLElBQUEsc0JBQUEsQ0FBdUMsQ0FBQyxVQUFBLElBQUEsb0JBQUEsQ0FBbUMsQ0FBQyxZQUFBLEdBQWUsQ0FBQyxZQUFBLElBQWdCLENBQUMsUUFBQSxJQUFZLENBQUMsV0FBQSxJQUFBLDJCQUFBLENBQUEsQ0FBQSxhQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLFNBQTJFLENBQUMsb0JBQUEsSUFBd0IsQ0FBQyxpQkFBQSxJQUFxQixDQUFDLGdCQUFBLElBQW9CLENBQUMsWUFBQSxJQUFnQixDQUFDLHNEQUFBLENBQXlCLFdBQUEsQ0FBWSxDQUFDLFNBQUEsTUFBZSxDQUFDLFNBQUEsUUFBaUIsQ0FBQyxXQUFBLEdBQUEsQ0FBQSxNQUFBLENBQUEsSUFBQSwyQkFBQSxDQUFBLENBQUEsVUFBaUUsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJFeHBhbmRlci5zdmVsdGUiXX0= */");
}
var get_content_slot_changes = (dirty) => ({});
var get_content_slot_context = (ctx) => ({});
var get_icon_slot_changes4 = (dirty) => ({});
var get_icon_slot_context4 = (ctx) => ({});
function create_if_block_114(ctx) {
  let div;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[14].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_icon_slot_context4
  );
  const block = {
    c: function create() {
      div = element("div");
      if (icon_slot)
        icon_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (icon_slot)
        icon_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "expander-icon svelte-1rpjzrl");
      add_location(div, file26, 72, 4, 2314);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (icon_slot) {
        icon_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_icon_slot_changes4
            ),
            get_icon_slot_context4
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_114.name,
    type: "if",
    source: "(72:3) {#if $$slots.icon}",
    ctx
  });
  return block;
}
function create_else_block7(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M2.14645 7.35355C2.34171 7.54882 2.65829 7.54882 2.85355 7.35355L6 4.20711L9.14645 7.35355C9.34171 7.54882 9.65829 7.54882 9.85355 7.35355C10.0488 7.15829 10.0488 6.84171 9.85355 6.64645L6.35355 3.14645C6.15829 2.95118 5.84171 2.95118 5.64645 3.14645L2.14645 6.64645C1.95118 6.84171 1.95118 7.15829 2.14645 7.35355Z");
      add_location(path, file26, 92, 6, 3079);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block7.name,
    type: "else",
    source: "(92:5) {:else}",
    ctx
  });
  return block;
}
function create_if_block18(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M2.14645 4.64645C2.34171 4.45118 2.65829 4.45118 2.85355 4.64645L6 7.79289L9.14645 4.64645C9.34171 4.45118 9.65829 4.45118 9.85355 4.64645C10.0488 4.84171 10.0488 5.15829 9.85355 5.35355L6.35355 8.85355C6.15829 9.04882 5.84171 9.04882 5.64645 8.85355L2.14645 5.35355C1.95118 5.15829 1.95118 4.84171 2.14645 4.64645Z");
      add_location(path, file26, 87, 6, 2691);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block18.name,
    type: "if",
    source: '(87:5) {#if direction === \\"down\\"}',
    ctx
  });
  return block;
}
function create_fragment26(ctx) {
  let div3;
  let h;
  let div0;
  let t0;
  let span;
  let t1;
  let button;
  let svg;
  let t2;
  let div2;
  let div1;
  let div3_class_value;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$$slots*/
    ctx[11].icon && create_if_block_114(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*direction*/
      ctx2[4] === "down"
    )
      return create_if_block18;
    return create_else_block7;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block1 = current_block_type(ctx);
  const content_slot_template = (
    /*#slots*/
    ctx[14].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_content_slot_context
  );
  let div3_levels = [
    {
      class: div3_class_value = "expander direction-" + /*direction*/
      ctx[4] + " " + /*className*/
      ctx[5]
    },
    { role: "region" },
    /*$$restProps*/
    ctx[10]
  ];
  let div3_data = {};
  for (let i = 0; i < div3_levels.length; i += 1) {
    div3_data = assign(div3_data, div3_levels[i]);
  }
  const block = {
    c: function create() {
      div3 = element("div");
      h = element("h");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      span = element("span");
      if (default_slot)
        default_slot.c();
      t1 = space();
      button = element("button");
      svg = svg_element("svg");
      if_block1.c();
      t2 = space();
      div2 = element("div");
      div1 = element("div");
      if (content_slot)
        content_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true, role: true });
      var div3_nodes = children(div3);
      h = claim_element(div3_nodes, "H", {});
      var h_nodes = children(h);
      div0 = claim_element(h_nodes, "DIV", {
        role: true,
        id: true,
        "aria-controls": true,
        class: true,
        "aria-expanded": true,
        tabindex: true
      });
      var div0_nodes = children(div0);
      if (if_block0)
        if_block0.l(div0_nodes);
      t0 = claim_space(div0_nodes);
      span = claim_element(div0_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      t1 = claim_space(div0_nodes);
      button = claim_element(div0_nodes, "BUTTON", {
        class: true,
        tabindex: true,
        id: true,
        "aria-labelledby": true
      });
      var button_nodes = children(button);
      svg = claim_svg_element(button_nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        class: true
      });
      var svg_nodes = children(svg);
      if_block1.l(svg_nodes);
      svg_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      h_nodes.forEach(detach_dev);
      t2 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (content_slot)
        content_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "expander-header-title svelte-1rpjzrl");
      add_location(span, file26, 76, 3, 2391);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "12");
      attr_dev(svg, "height", "12");
      attr_dev(svg, "viewBox", "0 0 12 12");
      attr_dev(svg, "class", "svelte-1rpjzrl");
      add_location(svg, file26, 85, 4, 2569);
      attr_dev(button, "class", "expander-chevron svelte-1rpjzrl");
      attr_dev(button, "tabindex", "-1");
      attr_dev(
        button,
        "id",
        /*contentId*/
        ctx[8]
      );
      attr_dev(
        button,
        "aria-labelledby",
        /*headerId*/
        ctx[7]
      );
      add_location(button, file26, 79, 3, 2455);
      attr_dev(div0, "role", "button");
      attr_dev(
        div0,
        "id",
        /*headerId*/
        ctx[7]
      );
      attr_dev(
        div0,
        "aria-controls",
        /*contentId*/
        ctx[8]
      );
      attr_dev(div0, "class", "expander-header svelte-1rpjzrl");
      attr_dev(
        div0,
        "aria-expanded",
        /*expanded*/
        ctx[0]
      );
      attr_dev(div0, "tabindex", "0");
      add_location(div0, file26, 60, 2, 2043);
      add_location(h, file26, 59, 1, 2015);
      attr_dev(div1, "class", "expander-content svelte-1rpjzrl");
      add_location(div1, file26, 102, 2, 3552);
      attr_dev(div2, "class", "expander-content-anchor svelte-1rpjzrl");
      add_location(div2, file26, 101, 1, 3512);
      set_attributes(div3, div3_data);
      toggle_class(
        div3,
        "expanded",
        /*expanded*/
        ctx[0]
      );
      toggle_class(div3, "svelte-1rpjzrl", true);
      add_location(div3, file26, 51, 0, 1857);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, h);
      append_hydration_dev(h, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div0, span);
      if (default_slot) {
        default_slot.m(span, null);
      }
      append_hydration_dev(div0, t1);
      append_hydration_dev(div0, button);
      append_hydration_dev(button, svg);
      if_block1.m(svg, null);
      ctx[15](div0);
      append_hydration_dev(div3, t2);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, div1);
      if (content_slot) {
        content_slot.m(div1, null);
      }
      ctx[17](div1);
      ctx[18](div3);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div0,
            "keydown",
            /*handleKeydown*/
            ctx[9],
            false,
            false,
            false
          ),
          listen_dev(
            div0,
            "click",
            /*click_handler*/
            ctx[16],
            false,
            false,
            false
          ),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[6].call(null, div3))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[11].icon
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          2048) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_114(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(svg, null);
        }
      }
      if (!current || dirty & /*expanded*/
      1) {
        attr_dev(
          div0,
          "aria-expanded",
          /*expanded*/
          ctx2[0]
        );
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_content_slot_changes
            ),
            get_content_slot_context
          );
        }
      }
      set_attributes(div3, div3_data = get_spread_update(div3_levels, [
        (!current || dirty & /*direction, className*/
        48 && div3_class_value !== (div3_class_value = "expander direction-" + /*direction*/
        ctx2[4] + " " + /*className*/
        ctx2[5])) && { class: div3_class_value },
        { role: "region" },
        dirty & /*$$restProps*/
        1024 && /*$$restProps*/
        ctx2[10]
      ]));
      toggle_class(
        div3,
        "expanded",
        /*expanded*/
        ctx2[0]
      );
      toggle_class(div3, "svelte-1rpjzrl", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      transition_in(content_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      transition_out(content_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div3);
      if (if_block0)
        if_block0.d();
      if (default_slot)
        default_slot.d(detaching);
      if_block1.d();
      ctx[15](null);
      if (content_slot)
        content_slot.d(detaching);
      ctx[17](null);
      ctx[18](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "expanded",
    "direction",
    "headingLevel",
    "class",
    "containerElement",
    "headerElement",
    "contentElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Expander", slots, ["icon", "default", "content"]);
  const $$slots = compute_slots(slots);
  let { expanded = false } = $$props;
  let { direction = "down" } = $$props;
  let { headingLevel = 3 } = $$props;
  let { class: className = "" } = $$props;
  let { containerElement = null } = $$props;
  let { headerElement = null } = $$props;
  let { contentElement = null } = $$props;
  const dispatch = createEventDispatcher();
  const forwardEvents = createEventForwarder(get_current_component(), ["expand", "collapse"]);
  const headerId = uid("fds-expander-header-");
  const contentId = uid("fds-expander-content-");
  function handleKeydown({ key }) {
    if (key === "Enter" || key === " ") {
      event.preventDefault();
      $$invalidate(0, expanded = !expanded);
    }
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      headerElement = $$value;
      $$invalidate(2, headerElement);
    });
  }
  const click_handler3 = () => $$invalidate(0, expanded = !expanded);
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contentElement = $$value;
      $$invalidate(3, contentElement);
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      containerElement = $$value;
      $$invalidate(1, containerElement);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("expanded" in $$new_props)
      $$invalidate(0, expanded = $$new_props.expanded);
    if ("direction" in $$new_props)
      $$invalidate(4, direction = $$new_props.direction);
    if ("headingLevel" in $$new_props)
      $$invalidate(12, headingLevel = $$new_props.headingLevel);
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("containerElement" in $$new_props)
      $$invalidate(1, containerElement = $$new_props.containerElement);
    if ("headerElement" in $$new_props)
      $$invalidate(2, headerElement = $$new_props.headerElement);
    if ("contentElement" in $$new_props)
      $$invalidate(3, contentElement = $$new_props.contentElement);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    get_current_component,
    createEventForwarder,
    uid,
    expanded,
    direction,
    headingLevel,
    className,
    containerElement,
    headerElement,
    contentElement,
    dispatch,
    forwardEvents,
    headerId,
    contentId,
    handleKeydown
  });
  $$self.$inject_state = ($$new_props) => {
    if ("expanded" in $$props)
      $$invalidate(0, expanded = $$new_props.expanded);
    if ("direction" in $$props)
      $$invalidate(4, direction = $$new_props.direction);
    if ("headingLevel" in $$props)
      $$invalidate(12, headingLevel = $$new_props.headingLevel);
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("containerElement" in $$props)
      $$invalidate(1, containerElement = $$new_props.containerElement);
    if ("headerElement" in $$props)
      $$invalidate(2, headerElement = $$new_props.headerElement);
    if ("contentElement" in $$props)
      $$invalidate(3, contentElement = $$new_props.contentElement);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*expanded*/
    1) {
      $:
        if (expanded) {
          dispatch("expand");
        } else {
          dispatch("collapse");
        }
    }
  };
  return [
    expanded,
    containerElement,
    headerElement,
    contentElement,
    direction,
    className,
    forwardEvents,
    headerId,
    contentId,
    handleKeydown,
    $$restProps,
    $$slots,
    headingLevel,
    $$scope,
    slots,
    div0_binding,
    click_handler3,
    div1_binding,
    div3_binding
  ];
}
var Expander = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance26,
      create_fragment26,
      safe_not_equal,
      {
        expanded: 0,
        direction: 4,
        headingLevel: 12,
        class: 5,
        containerElement: 1,
        headerElement: 2,
        contentElement: 3
      },
      add_css26
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Expander",
      options,
      id: create_fragment26.name
    });
  }
  get expanded() {
    throw new Error("<Expander>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expanded(value) {
    throw new Error("<Expander>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<Expander>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<Expander>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headingLevel() {
    throw new Error("<Expander>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headingLevel(value) {
    throw new Error("<Expander>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Expander>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Expander>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerElement() {
    throw new Error("<Expander>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerElement(value) {
    throw new Error("<Expander>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headerElement() {
    throw new Error("<Expander>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headerElement(value) {
    throw new Error("<Expander>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contentElement() {
    throw new Error("<Expander>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contentElement(value) {
    throw new Error("<Expander>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Expander_default = Expander;

// node_modules/fluent-svelte/IconButton/IconButton.svelte
var file27 = "node_modules\\fluent-svelte\\IconButton\\IconButton.svelte";
function add_css27(target) {
  append_styles(target, "svelte-1vh2em1", ".icon-button.svelte-1vh2em1{align-items:center;background-color:var(--fds-subtle-fill-transparent);border:none;border-radius:var(--fds-control-corner-radius);box-sizing:border-box;color:var(--fds-text-primary);display:inline-flex;justify-content:center;min-block-size:30px;min-inline-size:30px;outline:none;padding:8px}.icon-button.svelte-1vh2em1:focus-visible{box-shadow:var(--fds-focus-stroke)}.icon-button.svelte-1vh2em1:hover{background-color:var(--fds-subtle-fill-secondary)}.icon-button.svelte-1vh2em1:active{background-color:var(--fds-subtle-fill-tertiary);color:var(--fds-text-secondary)}.icon-button.svelte-1vh2em1:disabled{background-color:var(--fds-subtle-fill-disabled);color:var(--fds-text-disabled)}.icon-button.svelte-1vh2em1 svg{fill:currentColor;block-size:auto;inline-size:16px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSWNvbkJ1dHRvbi5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBd0NRLDJCQUFBLENBQWEsWUFBQSxNQUFrQixDQUFDLGlCQUFBLElBQUEsNkJBQUEsQ0FBbUQsQ0FBQyxPQUFBLElBQVcsQ0FBQyxjQUFBLElBQUEsMkJBQUEsQ0FBOEMsQ0FBQyxXQUFBLFVBQXFCLENBQUMsTUFBQSxJQUFBLGtCQUFBLENBQTZCLENBQUMsUUFBQSxXQUFtQixDQUFDLGdCQUFBLE1BQXNCLENBQUMsZUFBQSxJQUFtQixDQUFDLGdCQUFBLElBQW9CLENBQUMsUUFBQSxJQUFZLENBQUMsUUFBQSxHQUFXLENBQUMsMkJBQUEsY0FBQSxDQUEyQixXQUFBLElBQUEsa0JBQUEsQ0FBa0MsQ0FBQywyQkFBQSxNQUFBLENBQW1CLGlCQUFBLElBQUEsMkJBQUEsQ0FBaUQsQ0FBQywyQkFBQSxPQUFBLENBQW9CLGlCQUFBLElBQUEsMEJBQUEsQ0FBZ0QsQ0FBQyxNQUFBLElBQUEsb0JBQUEsQ0FBK0IsQ0FBQywyQkFBQSxTQUFBLENBQXNCLGlCQUFBLElBQUEsMEJBQUEsQ0FBZ0QsQ0FBQyxNQUFBLElBQUEsbUJBQUEsQ0FBOEIsQ0FBQywyQkFBQSxDQUFBLEFBQUEsR0FBQSxBQUFBLENBQTBCLEtBQUEsWUFBaUIsQ0FBQyxXQUFBLElBQWUsQ0FBQyxZQUFBLElBQWdCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiSWNvbkJ1dHRvbi5zdmVsdGUiXX0= */");
}
function create_dynamic_element3(ctx) {
  let svelte_element;
  let svelte_element_role_value;
  let svelte_element_href_value;
  let svelte_element_class_value;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let svelte_element_levels = [
    {
      role: svelte_element_role_value = /*href*/
      ctx[1] && !/*disabled*/
      ctx[2] ? "button" : void 0
    },
    {
      href: svelte_element_href_value = /*href*/
      ctx[1] && !/*disabled*/
      ctx[2] ? (
        /*href*/
        ctx[1]
      ) : void 0
    },
    {
      class: svelte_element_class_value = "icon-button " + /*className*/
      ctx[3]
    },
    /*$$restProps*/
    ctx[5]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*href*/
        ctx[1] && !/*disabled*/
        ctx[2] ? "a" : "button"
      );
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*href*/
        ((ctx[1] && !/*disabled*/
        ctx[2] ? "a" : "button") || "null").toUpperCase(),
        { role: true, href: true, class: true }
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (/-/.test(
        /*href*/
        ctx[1] && !/*disabled*/
        ctx[2] ? "a" : "button"
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      toggle_class(
        svelte_element,
        "disabled",
        /*disabled*/
        ctx[2]
      );
      toggle_class(svelte_element, "svelte-1vh2em1", true);
      add_location(svelte_element, file27, 27, 0, 1179);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      ctx[8](svelte_element);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(forwardEvents_action = /*forwardEvents*/
        ctx[4].call(null, svelte_element));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty & /*href, disabled*/
        6 && svelte_element_role_value !== (svelte_element_role_value = /*href*/
        ctx2[1] && !/*disabled*/
        ctx2[2] ? "button" : void 0)) && { role: svelte_element_role_value },
        (!current || dirty & /*href, disabled*/
        6 && svelte_element_href_value !== (svelte_element_href_value = /*href*/
        ctx2[1] && !/*disabled*/
        ctx2[2] ? (
          /*href*/
          ctx2[1]
        ) : void 0)) && { href: svelte_element_href_value },
        (!current || dirty & /*className*/
        8 && svelte_element_class_value !== (svelte_element_class_value = "icon-button " + /*className*/
        ctx2[3])) && { class: svelte_element_class_value },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]);
      if (/-/.test(
        /*href*/
        ctx2[1] && !/*disabled*/
        ctx2[2] ? "a" : "button"
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      toggle_class(
        svelte_element,
        "disabled",
        /*disabled*/
        ctx2[2]
      );
      toggle_class(svelte_element, "svelte-1vh2em1", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if (default_slot)
        default_slot.d(detaching);
      ctx[8](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element3.name,
    type: "child_dynamic_element",
    source: '(28:0) <svelte:element  this={href && !disabled ? \\"a\\" : \\"button\\"}  use:forwardEvents  bind:this={element}  role={href && !disabled ? \\"button\\" : undefined}  href={href && !disabled ? href : undefined}  class=\\"icon-button {className}\\"  class:disabled  {...$$restProps} >',
    ctx
  });
  return block;
}
function create_fragment27(ctx) {
  let previous_tag = (
    /*href*/
    ctx[1] && !/*disabled*/
    ctx[2] ? "a" : "button"
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*href*/
    ctx[1] && !/*disabled*/
    ctx[2] ? "a" : "button"
  );
  validate_void_dynamic_element(
    /*href*/
    ctx[1] && !/*disabled*/
    ctx[2] ? "a" : "button"
  );
  let svelte_element = (
    /*href*/
    (ctx[1] && !/*disabled*/
    ctx[2] ? "a" : "button") && create_dynamic_element3(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*href*/
        ctx2[1] && !/*disabled*/
        ctx2[2] ? "a" : "button"
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element3(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*href*/
          ctx2[1] && !/*disabled*/
          ctx2[2] ? "a" : "button"
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*href*/
            ctx2[1] && !/*disabled*/
            ctx2[2] ? "a" : "button"
          );
          validate_void_dynamic_element(
            /*href*/
            ctx2[1] && !/*disabled*/
            ctx2[2] ? "a" : "button"
          );
          svelte_element = create_dynamic_element3(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = /*href*/
      ctx2[1] && !/*disabled*/
      ctx2[2] ? "a" : "button";
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  const omit_props_names = ["href", "disabled", "class", "element"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("IconButton", slots, ["default"]);
  let { href = "" } = $$props;
  let { disabled = false } = $$props;
  let { class: className = "" } = $$props;
  let { element: element2 = null } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("href" in $$new_props)
      $$invalidate(1, href = $$new_props.href);
    if ("disabled" in $$new_props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    get_current_component,
    createEventForwarder,
    href,
    disabled,
    className,
    element: element2,
    forwardEvents
  });
  $$self.$inject_state = ($$new_props) => {
    if ("href" in $$props)
      $$invalidate(1, href = $$new_props.href);
    if ("disabled" in $$props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    href,
    disabled,
    className,
    forwardEvents,
    $$restProps,
    $$scope,
    slots,
    svelte_element_binding
  ];
}
var IconButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance27,
      create_fragment27,
      safe_not_equal,
      {
        href: 1,
        disabled: 2,
        class: 3,
        element: 0
      },
      add_css27
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "IconButton",
      options,
      id: create_fragment27.name
    });
  }
  get href() {
    throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var IconButton_default = IconButton;

// node_modules/fluent-svelte/MenuBar/MenuBar.svelte
var file28 = "node_modules\\fluent-svelte\\MenuBar\\MenuBar.svelte";
function add_css28(target) {
  append_styles(target, "svelte-11gadz4", ".menu-bar.svelte-11gadz4{align-items:center;block-size:40px;cursor:default;display:flex;margin:0;padding:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVudUJhci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBMENRLHdCQUFBLENBQVUsWUFBQSxNQUFrQixDQUFDLFdBQUEsSUFBZSxDQUFDLE9BQUEsT0FBYyxDQUFDLFFBQUEsSUFBWSxDQUFDLE9BQUEsQ0FBUSxDQUFDLFFBQUEsQ0FBUyxDQUFDLG9CQUFBLElBQXdCLENBQUMsaUJBQUEsSUFBcUIsQ0FBQyxnQkFBQSxJQUFvQixDQUFDLFlBQUEsSUFBZ0IsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJNZW51QmFyLnN2ZWx0ZSJdfQ== */");
}
function create_fragment28(ctx) {
  let ul;
  let ul_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let ul_levels = [
    {
      class: ul_class_value = "menu-bar " + /*className*/
      ctx[1]
    },
    { role: "menubar" },
    /*$$restProps*/
    ctx[2]
  ];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", { class: true, role: true });
      var ul_nodes = children(ul);
      if (default_slot)
        default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(ul, ul_data);
      toggle_class(ul, "svelte-11gadz4", true);
      add_location(ul, file28, 38, 0, 1254);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      ctx[5](ul);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [
        (!current || dirty & /*className*/
        2 && ul_class_value !== (ul_class_value = "menu-bar " + /*className*/
        ctx2[1])) && { class: ul_class_value },
        { role: "menubar" },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
      toggle_class(ul, "svelte-11gadz4", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      if (default_slot)
        default_slot.d(detaching);
      ctx[5](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "element"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenuBar", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { element: element2 = null } = $$props;
  setContext("sideNavigation", (event2, activeItem) => {
    const { key } = event2;
    let tabOrder = [];
    for (const child of Array.from(element2.children)) {
      if (isTabbable(child))
        tabOrder.push(child);
    }
    const activeIndex = tabOrder.indexOf(activeItem);
    if (tabOrder.length < 0)
      return;
    if (key === "ArrowLeft" || key === "ArrowRight")
      event2.preventDefault();
    if (key === "ArrowLeft") {
      if (tabOrder[0] === activeItem) {
        tabOrder[tabOrder.length - 1].focus();
      } else if (tabOrder.includes(activeItem)) {
        tabOrder[activeIndex - 1].focus();
      }
    } else if (key === "ArrowRight") {
      if (tabOrder[tabOrder.length - 1] === activeItem) {
        tabOrder[0].focus();
      } else if (tabOrder.includes(activeItem)) {
        tabOrder[activeIndex + 1].focus();
      }
    }
  });
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    isTabbable,
    className,
    element: element2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [element2, className, $$restProps, $$scope, slots, ul_binding];
}
var MenuBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, { class: 1, element: 0 }, add_css28);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenuBar",
      options,
      id: create_fragment28.name
    });
  }
  get class() {
    throw new Error("<MenuBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MenuBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<MenuBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<MenuBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenuBar_default = MenuBar;

// node_modules/fluent-svelte/MenuBar/flyoutState.js
var currentMenu = writable(null);

// node_modules/fluent-svelte/MenuBar/MenuBarItem.svelte
var file29 = "node_modules\\fluent-svelte\\MenuBar\\MenuBarItem.svelte";
function add_css29(target) {
  append_styles(target, "svelte-1j4bc70", ".menu-bar-item.svelte-1j4bc70{align-items:center;background-color:var(--fds-subtle-fill-transparent);border-radius:var(--fds-control-corner-radius);color:var(--fds-text-primary);cursor:default;display:inline-flex;font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;line-height:20px;margin:4px;padding:5px 11px;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.menu-bar-item.svelte-1j4bc70:hover{background-color:var(--fds-subtle-fill-secondary)}.menu-bar-item.svelte-1j4bc70:active,.menu-bar-item[aria-expanded=true].svelte-1j4bc70{background-color:var(--fds-subtle-fill-tertiary)}.menu-bar-item.svelte-1j4bc70:active:hover,.menu-bar-item[aria-expanded=true].svelte-1j4bc70:hover{background-color:var(--fds-subtle-fill-secondary)}.menu-bar-item.svelte-1j4bc70:active{color:var(--fds-text-secondary)}.menu-bar-item.disabled.svelte-1j4bc70{background-color:var(--fds-subtle-fill-disabled)!important;color:var(--fds-text-disabled)}.menu-flyout-anchor.svelte-1j4bc70{inset-block-start:100%;inset-inline-start:0;position:absolute;z-index:10000}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVudUJhckl0ZW0uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXNIUSw2QkFBQSxDQUFlLFlBQUEsTUFBa0IsQ0FBQyxpQkFBQSxJQUFBLDZCQUFBLENBQW1ELENBQUMsY0FBQSxJQUFBLDJCQUFBLENBQThDLENBQUMsTUFBQSxJQUFBLGtCQUFBLENBQTZCLENBQUMsT0FBQSxPQUFjLENBQUMsUUFBQSxXQUFtQixDQUFDLFlBQUEsSUFBQSxzQkFBQSxDQUF1QyxDQUFDLFVBQUEsSUFBQSxvQkFBQSxDQUFtQyxDQUFDLFlBQUEsR0FBZSxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxPQUFBLEdBQVUsQ0FBQyxRQUFBLEdBQUEsQ0FBQSxJQUFnQixDQUFDLFNBQUEsUUFBaUIsQ0FBQyxvQkFBQSxJQUF3QixDQUFDLGlCQUFBLElBQXFCLENBQUMsZ0JBQUEsSUFBb0IsQ0FBQyxZQUFBLElBQWdCLENBQUMsNkJBQUEsTUFBQSxDQUFxQixpQkFBQSxJQUFBLDJCQUFBLENBQWlELENBQUMsNkJBQUEsT0FBQSxDQUFBLGNBQUEsQ0FBQSxhQUFBLENBQUEsSUFBQSxnQkFBQSxDQUF5RCxpQkFBQSxJQUFBLDBCQUFBLENBQWdELENBQUMsNkJBQUEsT0FBQSxNQUFBLENBQUEsY0FBQSxDQUFBLGFBQUEsQ0FBQSxJQUFBLGdCQUFBLE1BQUEsQ0FBcUUsaUJBQUEsSUFBQSwyQkFBQSxDQUFpRCxDQUFDLDZCQUFBLE9BQUEsQ0FBc0IsTUFBQSxJQUFBLG9CQUFBLENBQStCLENBQUMsY0FBQSx3QkFBQSxDQUF3QixpQkFBQSxJQUFBLDBCQUFBLENBQUEsVUFBMEQsQ0FBQyxNQUFBLElBQUEsbUJBQUEsQ0FBOEIsQ0FBQyxrQ0FBQSxDQUFvQixrQkFBQSxJQUFzQixDQUFDLG1CQUFBLENBQW9CLENBQUMsU0FBQSxRQUFpQixDQUFDLFFBQUEsS0FBYSxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIk1lbnVCYXJJdGVtLnN2ZWx0ZSJdfQ== */");
}
var get_flyout_slot_changes2 = (dirty) => ({});
var get_flyout_slot_context2 = (ctx) => ({});
function create_if_block19(ctx) {
  let div;
  let menuflyoutsurface;
  let updating_element;
  let arrowNavigation_action;
  let externalMouseEvents_action;
  let current;
  let mounted;
  let dispose;
  function menuflyoutsurface_element_binding(value) {
    ctx[18](value);
  }
  let menuflyoutsurface_props = {
    $$slots: { default: [create_default_slot10] },
    $$scope: { ctx }
  };
  if (
    /*menuElement*/
    ctx[3] !== void 0
  ) {
    menuflyoutsurface_props.element = /*menuElement*/
    ctx[3];
  }
  menuflyoutsurface = new MenuFlyoutSurface_default({
    props: menuflyoutsurface_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(menuflyoutsurface, "element", menuflyoutsurface_element_binding));
  ctx[19](menuflyoutsurface);
  const block = {
    c: function create() {
      div = element("div");
      create_component(menuflyoutsurface.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(menuflyoutsurface.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "menu-flyout-anchor svelte-1j4bc70");
      add_location(div, file29, 104, 2, 3041);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(menuflyoutsurface, div, null);
      ctx[21](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(arrowNavigation_action = arrowNavigation.call(null, div, { preventTab: true })),
          action_destroyer(externalMouseEvents_action = externalMouseEvents.call(null, div, { type: "mousedown", stopPropagation: true })),
          listen_dev(
            div,
            "outermousedown",
            /*outermousedown_handler*/
            ctx[20],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const menuflyoutsurface_changes = {};
      if (dirty & /*$$scope*/
      33554432) {
        menuflyoutsurface_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_element && dirty & /*menuElement*/
      8) {
        updating_element = true;
        menuflyoutsurface_changes.element = /*menuElement*/
        ctx2[3];
        add_flush_callback(() => updating_element = false);
      }
      menuflyoutsurface.$set(menuflyoutsurface_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(menuflyoutsurface.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(menuflyoutsurface.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[19](null);
      destroy_component(menuflyoutsurface);
      ctx[21](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block19.name,
    type: "if",
    source: "(104:1) {#if $$slots.flyout && open && !disabled}",
    ctx
  });
  return block;
}
function create_default_slot10(ctx) {
  let current;
  const flyout_slot_template = (
    /*#slots*/
    ctx[17].flyout
  );
  const flyout_slot = create_slot(
    flyout_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    get_flyout_slot_context2
  );
  const block = {
    c: function create() {
      if (flyout_slot)
        flyout_slot.c();
    },
    l: function claim(nodes) {
      if (flyout_slot)
        flyout_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (flyout_slot) {
        flyout_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (flyout_slot) {
        if (flyout_slot.p && (!current || dirty & /*$$scope*/
        33554432)) {
          update_slot_base(
            flyout_slot,
            flyout_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              flyout_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              get_flyout_slot_changes2
            ),
            get_flyout_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(flyout_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(flyout_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (flyout_slot)
        flyout_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot10.name,
    type: "slot",
    source: "(112:3) <MenuFlyoutSurface bind:element={menuElement} bind:this={menu}>",
    ctx
  });
  return block;
}
function create_fragment29(ctx) {
  let li;
  let t;
  let li_class_value;
  let li_tabindex_value;
  let li_aria_expanded_value;
  let li_aria_haspopup_value;
  let li_aria_controls_value;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    null
  );
  let if_block = (
    /*$$slots*/
    ctx[14].flyout && /*open*/
    ctx[0] && !/*disabled*/
    ctx[4] && create_if_block19(ctx)
  );
  let li_levels = [
    {
      class: li_class_value = "menu-bar-item " + /*className*/
      ctx[5]
    },
    { role: "menuitem" },
    {
      tabindex: li_tabindex_value = /*disabled*/
      ctx[4] ? -1 : 0
    },
    {
      "aria-expanded": li_aria_expanded_value = /*$$slots*/
      ctx[14].flyout && !/*disabled*/
      ctx[4] && /*open*/
      ctx[0]
    },
    {
      "aria-haspopup": li_aria_haspopup_value = /*$$slots*/
      ctx[14].flyout && !/*disabled*/
      ctx[4] && /*open*/
      ctx[0]
    },
    {
      "aria-controls": li_aria_controls_value = /*$$slots*/
      ctx[14].flyout && !/*disabled*/
      ctx[4] && /*menuId*/
      ctx[8]
    },
    /*$$restProps*/
    ctx[15]
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {
        class: true,
        role: true,
        tabindex: true,
        "aria-expanded": true,
        "aria-haspopup": true,
        "aria-controls": true
      });
      var li_nodes = children(li);
      if (default_slot)
        default_slot.l(li_nodes);
      t = claim_space(li_nodes);
      if (if_block)
        if_block.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(li, li_data);
      toggle_class(
        li,
        "disabled",
        /*disabled*/
        ctx[4]
      );
      toggle_class(li, "svelte-1j4bc70", true);
      add_location(li, file29, 85, 0, 2475);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      append_hydration_dev(li, t);
      if (if_block)
        if_block.m(li, null);
      ctx[22](li);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "keydown",
            /*handleEscapeKey*/
            ctx[10],
            false,
            false,
            false
          ),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[7].call(null, li)),
          listen_dev(
            li,
            "keydown",
            /*keydown_handler*/
            ctx[23],
            false,
            false,
            false
          ),
          listen_dev(li, "keydown", self(
            /*handleKeyDown*/
            ctx[12]
          ), false, false, false),
          listen_dev(
            li,
            "focus",
            /*handleFocus*/
            ctx[13],
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "mousedown",
            /*mousedown_handler*/
            ctx[24],
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "mouseenter",
            /*handleMouseEnter*/
            ctx[11],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*$$slots*/
        ctx2[14].flyout && /*open*/
        ctx2[0] && !/*disabled*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots, open, disabled*/
          16401) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block19(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(li, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        (!current || dirty & /*className*/
        32 && li_class_value !== (li_class_value = "menu-bar-item " + /*className*/
        ctx2[5])) && { class: li_class_value },
        { role: "menuitem" },
        (!current || dirty & /*disabled*/
        16 && li_tabindex_value !== (li_tabindex_value = /*disabled*/
        ctx2[4] ? -1 : 0)) && { tabindex: li_tabindex_value },
        (!current || dirty & /*$$slots, disabled, open*/
        16401 && li_aria_expanded_value !== (li_aria_expanded_value = /*$$slots*/
        ctx2[14].flyout && !/*disabled*/
        ctx2[4] && /*open*/
        ctx2[0])) && { "aria-expanded": li_aria_expanded_value },
        (!current || dirty & /*$$slots, disabled, open*/
        16401 && li_aria_haspopup_value !== (li_aria_haspopup_value = /*$$slots*/
        ctx2[14].flyout && !/*disabled*/
        ctx2[4] && /*open*/
        ctx2[0])) && { "aria-haspopup": li_aria_haspopup_value },
        (!current || dirty & /*$$slots, disabled*/
        16400 && li_aria_controls_value !== (li_aria_controls_value = /*$$slots*/
        ctx2[14].flyout && !/*disabled*/
        ctx2[4] && /*menuId*/
        ctx2[8])) && { "aria-controls": li_aria_controls_value },
        dirty & /*$$restProps*/
        32768 && /*$$restProps*/
        ctx2[15]
      ]));
      toggle_class(
        li,
        "disabled",
        /*disabled*/
        ctx2[4]
      );
      toggle_class(li, "svelte-1j4bc70", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[22](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance29($$self, $$props, $$invalidate) {
  const omit_props_names = ["open", "disabled", "class", "element", "anchorElement", "menuElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $currentMenu;
  validate_store(currentMenu, "currentMenu");
  component_subscribe($$self, currentMenu, ($$value) => $$invalidate(16, $currentMenu = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenuBarItem", slots, ["default", "flyout"]);
  const $$slots = compute_slots(slots);
  let { open = false } = $$props;
  let { disabled = false } = $$props;
  let { class: className = "" } = $$props;
  let { element: element2 = null } = $$props;
  let { anchorElement = null } = $$props;
  let { menuElement = null } = $$props;
  let menu;
  const forwardEvents = createEventForwarder(get_current_component(), ["open", "close", "select"]);
  const dispatch = createEventDispatcher();
  const menuId = uid("fds-menu-flyout-anchor-");
  const handleSideNavigation = getContext("sideNavigation");
  function focusFirstItem() {
    if (open && menu && tabbable(menuElement).length > 0)
      tabbable(menuElement)[0].focus();
  }
  function handleEscapeKey({ key }) {
    if (key === "Escape")
      $$invalidate(0, open = false);
  }
  function handleMouseEnter() {
    if ($currentMenu && $$slots.flyout) {
      set_store_value(currentMenu, $currentMenu = menu, $currentMenu);
      $$invalidate(0, open = true);
    }
  }
  function handleKeyDown2({ key }) {
    if (key === "Enter" || key === " ") {
      event.preventDefault();
      $$invalidate(0, open = !open);
    }
  }
  function handleFocus() {
    if (open) {
      focusFirstItem();
    } else if ($currentMenu) {
      set_store_value(currentMenu, $currentMenu = menu, $currentMenu);
      $$invalidate(0, open = true);
    }
  }
  setContext("closeFlyout", (event2) => {
    dispatch("select");
    event2.stopPropagation();
    $$invalidate(0, open = false);
  });
  function menuflyoutsurface_element_binding(value) {
    menuElement = value;
    $$invalidate(3, menuElement);
  }
  function menuflyoutsurface_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      menu = $$value;
      $$invalidate(6, menu);
    });
  }
  const outermousedown_handler = () => $$invalidate(0, open = false);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      anchorElement = $$value;
      $$invalidate(2, anchorElement);
    });
  }
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  const keydown_handler = (event2) => handleSideNavigation(event2, element2);
  const mousedown_handler = () => $$invalidate(0, open = !open);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("disabled" in $$new_props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("element" in $$new_props)
      $$invalidate(1, element2 = $$new_props.element);
    if ("anchorElement" in $$new_props)
      $$invalidate(2, anchorElement = $$new_props.anchorElement);
    if ("menuElement" in $$new_props)
      $$invalidate(3, menuElement = $$new_props.menuElement);
    if ("$$scope" in $$new_props)
      $$invalidate(25, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    currentMenu,
    tabbable,
    createEventDispatcher,
    getContext,
    setContext,
    get_current_component,
    createEventForwarder,
    arrowNavigation,
    externalMouseEvents,
    uid,
    MenuFlyoutSurface: MenuFlyoutSurface_default,
    open,
    disabled,
    className,
    element: element2,
    anchorElement,
    menuElement,
    menu,
    forwardEvents,
    dispatch,
    menuId,
    handleSideNavigation,
    focusFirstItem,
    handleEscapeKey,
    handleMouseEnter,
    handleKeyDown: handleKeyDown2,
    handleFocus,
    $currentMenu
  });
  $$self.$inject_state = ($$new_props) => {
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("disabled" in $$props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(1, element2 = $$new_props.element);
    if ("anchorElement" in $$props)
      $$invalidate(2, anchorElement = $$new_props.anchorElement);
    if ("menuElement" in $$props)
      $$invalidate(3, menuElement = $$new_props.menuElement);
    if ("menu" in $$props)
      $$invalidate(6, menu = $$new_props.menu);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*menu*/
    64) {
      $:
        if (menu) {
          focusFirstItem();
          set_store_value(currentMenu, $currentMenu = menu, $currentMenu);
        } else {
          set_store_value(currentMenu, $currentMenu = null, $currentMenu);
        }
    }
    if ($$self.$$.dirty & /*$currentMenu, menu*/
    65600) {
      $:
        if ($currentMenu !== menu)
          $$invalidate(0, open = false);
    }
    if ($$self.$$.dirty & /*menu, element*/
    66) {
      $:
        if (!menu && element2)
          element2.focus();
    }
    if ($$self.$$.dirty & /*open, disabled*/
    17) {
      $:
        if ($$slots.flyout && open && !disabled) {
          if (open) {
            dispatch("open");
          } else {
            dispatch("close");
          }
        }
    }
  };
  return [
    open,
    element2,
    anchorElement,
    menuElement,
    disabled,
    className,
    menu,
    forwardEvents,
    menuId,
    handleSideNavigation,
    handleEscapeKey,
    handleMouseEnter,
    handleKeyDown2,
    handleFocus,
    $$slots,
    $$restProps,
    $currentMenu,
    slots,
    menuflyoutsurface_element_binding,
    menuflyoutsurface_binding,
    outermousedown_handler,
    div_binding,
    li_binding,
    keydown_handler,
    mousedown_handler,
    $$scope
  ];
}
var MenuBarItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance29,
      create_fragment29,
      safe_not_equal,
      {
        open: 0,
        disabled: 4,
        class: 5,
        element: 1,
        anchorElement: 2,
        menuElement: 3
      },
      add_css29
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenuBarItem",
      options,
      id: create_fragment29.name
    });
  }
  get open() {
    throw new Error("<MenuBarItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<MenuBarItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<MenuBarItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<MenuBarItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MenuBarItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MenuBarItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<MenuBarItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<MenuBarItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchorElement() {
    throw new Error("<MenuBarItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchorElement(value) {
    throw new Error("<MenuBarItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get menuElement() {
    throw new Error("<MenuBarItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set menuElement(value) {
    throw new Error("<MenuBarItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenuBarItem_default = MenuBarItem;

// node_modules/fluent-svelte/MenuFlyout/MenuFlyoutWrapper.svelte
var file30 = "node_modules\\fluent-svelte\\MenuFlyout\\MenuFlyoutWrapper.svelte";
function add_css30(target) {
  append_styles(target, "svelte-1h8v3f2", ".menu-flyout-wrapper.svelte-1h8v3f2{display:inline-block;height:auto;position:relative}.menu-flyout-backdrop.svelte-1h8v3f2{height:100%;left:0;position:fixed;top:0;width:100%;z-index:9999}.menu-flyout-anchor.svelte-1h8v3f2{position:absolute;z-index:10000}.menu-flyout-anchor.placement-top.svelte-1h8v3f2{--fds-menu-flyout-transition-offset:50%;bottom:calc(100% + var(--fds-menu-flyout-offset))}.menu-flyout-anchor.placement-bottom.svelte-1h8v3f2{top:calc(100% + var(--fds-menu-flyout-offset))}.menu-flyout-anchor.placement-left.svelte-1h8v3f2{right:calc(100% + var(--fds-menu-flyout-offset))}.menu-flyout-anchor.placement-right.svelte-1h8v3f2{left:calc(100% + var(--fds-menu-flyout-offset))}.menu-flyout-anchor.placement-bottom.alignment-start.svelte-1h8v3f2,.menu-flyout-anchor.placement-top.alignment-start.svelte-1h8v3f2{inset-inline-start:0}.menu-flyout-anchor.placement-bottom.alignment-end.svelte-1h8v3f2,.menu-flyout-anchor.placement-top.alignment-end.svelte-1h8v3f2{inset-inline-end:0}.menu-flyout-anchor.placement-bottom.alignment-center.svelte-1h8v3f2,.menu-flyout-anchor.placement-top.alignment-center.svelte-1h8v3f2{inset-inline-start:50%;transform:translateX(-50%)}.menu-flyout-anchor.placement-left.alignment-start.svelte-1h8v3f2,.menu-flyout-anchor.placement-right.alignment-start.svelte-1h8v3f2{inset-block-start:0}.menu-flyout-anchor.placement-left.alignment-end.svelte-1h8v3f2,.menu-flyout-anchor.placement-right.alignment-end.svelte-1h8v3f2{inset-block-end:0}.menu-flyout-anchor.placement-left.alignment-center.svelte-1h8v3f2,.menu-flyout-anchor.placement-right.alignment-center.svelte-1h8v3f2{inset-block-start:50%;transform:translateY(-50%)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVudUZseW91dFdyYXBwZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTBGUSxtQ0FBQSxDQUFxQixRQUFBLFlBQW9CLENBQUMsT0FBQSxJQUFXLENBQUMsU0FBQSxRQUFpQixDQUFDLG9DQUFBLENBQXNCLE9BQUEsSUFBVyxDQUFDLEtBQUEsQ0FBTSxDQUFDLFNBQUEsS0FBYyxDQUFDLElBQUEsQ0FBSyxDQUFDLE1BQUEsSUFBVSxDQUFDLFFBQUEsSUFBWSxDQUFDLGtDQUFBLENBQW9CLFNBQUEsUUFBaUIsQ0FBQyxRQUFBLEtBQWEsQ0FBQyxtQkFBQSw2QkFBQSxDQUFrQyxvQ0FBQSxHQUF1QyxDQUFDLE9BQUEsS0FBQSxJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsd0JBQUEsQ0FBQSxDQUFpRCxDQUFDLG1CQUFBLGdDQUFBLENBQXFDLElBQUEsS0FBQSxJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsd0JBQUEsQ0FBQSxDQUE4QyxDQUFDLG1CQUFBLDhCQUFBLENBQW1DLE1BQUEsS0FBQSxJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsd0JBQUEsQ0FBQSxDQUFnRCxDQUFDLG1CQUFBLCtCQUFBLENBQW9DLEtBQUEsS0FBQSxJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsd0JBQUEsQ0FBQSxDQUErQyxDQUFDLG1CQUFBLGlCQUFBLCtCQUFBLENBQUEsbUJBQUEsY0FBQSwrQkFBQSxDQUF1RyxtQkFBQSxDQUFvQixDQUFDLG1CQUFBLGlCQUFBLDZCQUFBLENBQUEsbUJBQUEsY0FBQSw2QkFBQSxDQUFtRyxpQkFBQSxDQUFrQixDQUFDLG1CQUFBLGlCQUFBLGdDQUFBLENBQUEsbUJBQUEsY0FBQSxnQ0FBQSxDQUF5RyxtQkFBQSxHQUFzQixDQUFDLFVBQUEsV0FBQSxJQUFBLENBQTBCLENBQUMsbUJBQUEsZUFBQSwrQkFBQSxDQUFBLG1CQUFBLGdCQUFBLCtCQUFBLENBQXVHLGtCQUFBLENBQW1CLENBQUMsbUJBQUEsZUFBQSw2QkFBQSxDQUFBLG1CQUFBLGdCQUFBLDZCQUFBLENBQW1HLGdCQUFBLENBQWlCLENBQUMsbUJBQUEsZUFBQSxnQ0FBQSxDQUFBLG1CQUFBLGdCQUFBLGdDQUFBLENBQXlHLGtCQUFBLEdBQXFCLENBQUMsVUFBQSxXQUFBLElBQUEsQ0FBMEIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJNZW51Rmx5b3V0V3JhcHBlci5zdmVsdGUiXX0= */");
}
var get_flyout_slot_changes3 = (dirty) => ({});
var get_flyout_slot_context3 = (ctx) => ({});
function create_if_block20(ctx) {
  let div0;
  let menuflyoutsurface;
  let updating_element;
  let div0_class_value;
  let arrowNavigation_action;
  let t;
  let div1;
  let current;
  let mounted;
  let dispose;
  const menuflyoutsurface_spread_levels = [
    /*$$restProps*/
    ctx[14]
  ];
  function menuflyoutsurface_element_binding(value) {
    ctx[18](value);
  }
  let menuflyoutsurface_props = {
    $$slots: { default: [create_default_slot11] },
    $$scope: { ctx }
  };
  for (let i = 0; i < menuflyoutsurface_spread_levels.length; i += 1) {
    menuflyoutsurface_props = assign(menuflyoutsurface_props, menuflyoutsurface_spread_levels[i]);
  }
  if (
    /*menuElement*/
    ctx[1] !== void 0
  ) {
    menuflyoutsurface_props.element = /*menuElement*/
    ctx[1];
  }
  menuflyoutsurface = new MenuFlyoutSurface_default({
    props: menuflyoutsurface_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(menuflyoutsurface, "element", menuflyoutsurface_element_binding));
  ctx[19](menuflyoutsurface);
  const block = {
    c: function create() {
      div0 = element("div");
      create_component(menuflyoutsurface.$$.fragment);
      t = space();
      div1 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div0 = claim_element(nodes, "DIV", {
        id: true,
        class: true,
        style: true,
        tabindex: true
      });
      var div0_nodes = children(div0);
      claim_component(menuflyoutsurface.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      t = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      children(div1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div0,
        "id",
        /*menuId*/
        ctx[10]
      );
      attr_dev(div0, "class", div0_class_value = "menu-flyout-anchor placement-" + /*placement*/
      ctx[5] + " alignment-" + /*alignment*/
      ctx[6] + " svelte-1h8v3f2");
      set_style(
        div0,
        "--fds-menu-flyout-offset",
        /*offset*/
        ctx[7] + "px"
      );
      attr_dev(div0, "tabindex", "-1");
      add_location(div0, file30, 68, 2, 2455);
      attr_dev(div1, "class", "menu-flyout-backdrop svelte-1h8v3f2");
      add_location(div1, file30, 81, 2, 2879);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div0, anchor);
      mount_component(menuflyoutsurface, div0, null);
      ctx[20](div0);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, div1, anchor);
      ctx[21](div1);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(arrowNavigation_action = arrowNavigation.call(null, div0, { preventTab: true })),
          listen_dev(div0, "click", click_handler2, false, false, false),
          listen_dev(div1, "click", click_handler_12, false, false, false),
          listen_dev(
            div1,
            "mousedown",
            /*closeFlyout*/
            ctx[13],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const menuflyoutsurface_changes = dirty & /*$$restProps*/
      16384 ? get_spread_update(menuflyoutsurface_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[14]
      )]) : {};
      if (dirty & /*$$scope*/
      8388608) {
        menuflyoutsurface_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_element && dirty & /*menuElement*/
      2) {
        updating_element = true;
        menuflyoutsurface_changes.element = /*menuElement*/
        ctx2[1];
        add_flush_callback(() => updating_element = false);
      }
      menuflyoutsurface.$set(menuflyoutsurface_changes);
      if (!current || dirty & /*placement, alignment*/
      96 && div0_class_value !== (div0_class_value = "menu-flyout-anchor placement-" + /*placement*/
      ctx2[5] + " alignment-" + /*alignment*/
      ctx2[6] + " svelte-1h8v3f2")) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty & /*offset*/
      128) {
        set_style(
          div0,
          "--fds-menu-flyout-offset",
          /*offset*/
          ctx2[7] + "px"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(menuflyoutsurface.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(menuflyoutsurface.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div0);
      ctx[19](null);
      destroy_component(menuflyoutsurface);
      ctx[20](null);
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(div1);
      ctx[21](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block20.name,
    type: "if",
    source: "(68:1) {#if open}",
    ctx
  });
  return block;
}
function create_default_slot11(ctx) {
  let current;
  const flyout_slot_template = (
    /*#slots*/
    ctx[17].flyout
  );
  const flyout_slot = create_slot(
    flyout_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    get_flyout_slot_context3
  );
  const block = {
    c: function create() {
      if (flyout_slot)
        flyout_slot.c();
    },
    l: function claim(nodes) {
      if (flyout_slot)
        flyout_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (flyout_slot) {
        flyout_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (flyout_slot) {
        if (flyout_slot.p && (!current || dirty & /*$$scope*/
        8388608)) {
          update_slot_base(
            flyout_slot,
            flyout_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              flyout_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              get_flyout_slot_changes3
            ),
            get_flyout_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(flyout_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(flyout_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (flyout_slot)
        flyout_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot11.name,
    type: "slot",
    source: "(78:3) <MenuFlyoutSurface bind:element={menuElement} bind:this={menu} {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment30(ctx) {
  let div;
  let t;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    null
  );
  let if_block = (
    /*open*/
    ctx[0] && create_if_block20(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "aria-expanded": true,
        "aria-haspopup": true,
        "aria-controls": true
      });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "menu-flyout-wrapper " + /*className*/
      ctx[8] + " svelte-1h8v3f2");
      attr_dev(
        div,
        "aria-expanded",
        /*open*/
        ctx[0]
      );
      attr_dev(
        div,
        "aria-haspopup",
        /*open*/
        ctx[0]
      );
      attr_dev(
        div,
        "aria-controls",
        /*menuId*/
        ctx[10]
      );
      add_location(div, file30, 58, 0, 2262);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_hydration_dev(div, t);
      if (if_block)
        if_block.m(div, null);
      ctx[22](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "keydown",
            /*handleEscapeKey*/
            ctx[11],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "click",
            /*toggleFlyout*/
            ctx[12],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8388608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*open*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*open*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block20(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*className*/
      256 && div_class_value !== (div_class_value = "menu-flyout-wrapper " + /*className*/
      ctx2[8] + " svelte-1h8v3f2")) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*open*/
      1) {
        attr_dev(
          div,
          "aria-expanded",
          /*open*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*open*/
      1) {
        attr_dev(
          div,
          "aria-haspopup",
          /*open*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[22](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var click_handler2 = (e) => e.stopPropagation();
var click_handler_12 = (e) => e.stopPropagation();
function instance30($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "open",
    "closable",
    "closeOnSelect",
    "placement",
    "alignment",
    "offset",
    "class",
    "wrapperElement",
    "anchorElement",
    "menuElement",
    "backdropElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenuFlyoutWrapper", slots, ["default", "flyout"]);
  let { open = false } = $$props;
  let { closable = true } = $$props;
  let { closeOnSelect = true } = $$props;
  let { placement = "top" } = $$props;
  let { alignment = "center" } = $$props;
  let { offset = 4 } = $$props;
  let { class: className = "" } = $$props;
  let { wrapperElement = null } = $$props;
  let { anchorElement = null } = $$props;
  let { menuElement = null } = $$props;
  let { backdropElement = null } = $$props;
  const dispatch = createEventDispatcher();
  const menuId = uid("fds-menu-flyout-anchor-");
  let menu = null;
  let previousFocus = null;
  function handleEscapeKey({ key }) {
    if (key === "Escape" && closable)
      $$invalidate(0, open = false);
    previousFocus === null || previousFocus === void 0 ? void 0 : previousFocus.focus();
  }
  function toggleFlyout() {
    previousFocus = document.activeElement;
    $$invalidate(0, open = !open);
  }
  function closeFlyout() {
    if (closable)
      $$invalidate(0, open = false);
  }
  setContext("closeFlyout", (event2) => {
    dispatch("select");
    if (closeOnSelect && closable) {
      event2.stopPropagation();
      $$invalidate(0, open = false);
    }
  });
  function menuflyoutsurface_element_binding(value) {
    menuElement = value;
    $$invalidate(1, menuElement);
  }
  function menuflyoutsurface_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      menu = $$value;
      $$invalidate(9, menu);
    });
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      anchorElement = $$value;
      $$invalidate(3, anchorElement);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      backdropElement = $$value;
      $$invalidate(4, backdropElement);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      wrapperElement = $$value;
      $$invalidate(2, wrapperElement);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("closable" in $$new_props)
      $$invalidate(15, closable = $$new_props.closable);
    if ("closeOnSelect" in $$new_props)
      $$invalidate(16, closeOnSelect = $$new_props.closeOnSelect);
    if ("placement" in $$new_props)
      $$invalidate(5, placement = $$new_props.placement);
    if ("alignment" in $$new_props)
      $$invalidate(6, alignment = $$new_props.alignment);
    if ("offset" in $$new_props)
      $$invalidate(7, offset = $$new_props.offset);
    if ("class" in $$new_props)
      $$invalidate(8, className = $$new_props.class);
    if ("wrapperElement" in $$new_props)
      $$invalidate(2, wrapperElement = $$new_props.wrapperElement);
    if ("anchorElement" in $$new_props)
      $$invalidate(3, anchorElement = $$new_props.anchorElement);
    if ("menuElement" in $$new_props)
      $$invalidate(1, menuElement = $$new_props.menuElement);
    if ("backdropElement" in $$new_props)
      $$invalidate(4, backdropElement = $$new_props.backdropElement);
    if ("$$scope" in $$new_props)
      $$invalidate(23, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    tabbable,
    createEventDispatcher,
    setContext,
    arrowNavigation,
    uid,
    MenuFlyoutSurface: MenuFlyoutSurface_default,
    open,
    closable,
    closeOnSelect,
    placement,
    alignment,
    offset,
    className,
    wrapperElement,
    anchorElement,
    menuElement,
    backdropElement,
    dispatch,
    menuId,
    menu,
    previousFocus,
    handleEscapeKey,
    toggleFlyout,
    closeFlyout
  });
  $$self.$inject_state = ($$new_props) => {
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("closable" in $$props)
      $$invalidate(15, closable = $$new_props.closable);
    if ("closeOnSelect" in $$props)
      $$invalidate(16, closeOnSelect = $$new_props.closeOnSelect);
    if ("placement" in $$props)
      $$invalidate(5, placement = $$new_props.placement);
    if ("alignment" in $$props)
      $$invalidate(6, alignment = $$new_props.alignment);
    if ("offset" in $$props)
      $$invalidate(7, offset = $$new_props.offset);
    if ("className" in $$props)
      $$invalidate(8, className = $$new_props.className);
    if ("wrapperElement" in $$props)
      $$invalidate(2, wrapperElement = $$new_props.wrapperElement);
    if ("anchorElement" in $$props)
      $$invalidate(3, anchorElement = $$new_props.anchorElement);
    if ("menuElement" in $$props)
      $$invalidate(1, menuElement = $$new_props.menuElement);
    if ("backdropElement" in $$props)
      $$invalidate(4, backdropElement = $$new_props.backdropElement);
    if ("menu" in $$props)
      $$invalidate(9, menu = $$new_props.menu);
    if ("previousFocus" in $$props)
      previousFocus = $$new_props.previousFocus;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open*/
    1) {
      $:
        dispatch(open ? "open" : "close");
    }
    if ($$self.$$.dirty & /*menu, menuElement*/
    514) {
      $:
        if (menu && tabbable(menuElement).length > 0)
          tabbable(menuElement)[0].focus();
    }
  };
  return [
    open,
    menuElement,
    wrapperElement,
    anchorElement,
    backdropElement,
    placement,
    alignment,
    offset,
    className,
    menu,
    menuId,
    handleEscapeKey,
    toggleFlyout,
    closeFlyout,
    $$restProps,
    closable,
    closeOnSelect,
    slots,
    menuflyoutsurface_element_binding,
    menuflyoutsurface_binding,
    div0_binding,
    div1_binding,
    div_binding,
    $$scope
  ];
}
var MenuFlyoutWrapper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance30,
      create_fragment30,
      safe_not_equal,
      {
        open: 0,
        closable: 15,
        closeOnSelect: 16,
        placement: 5,
        alignment: 6,
        offset: 7,
        class: 8,
        wrapperElement: 2,
        anchorElement: 3,
        menuElement: 1,
        backdropElement: 4
      },
      add_css30
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenuFlyoutWrapper",
      options,
      id: create_fragment30.name
    });
  }
  get open() {
    throw new Error("<MenuFlyoutWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<MenuFlyoutWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closable() {
    throw new Error("<MenuFlyoutWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closable(value) {
    throw new Error("<MenuFlyoutWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnSelect() {
    throw new Error("<MenuFlyoutWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnSelect(value) {
    throw new Error("<MenuFlyoutWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placement() {
    throw new Error("<MenuFlyoutWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placement(value) {
    throw new Error("<MenuFlyoutWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alignment() {
    throw new Error("<MenuFlyoutWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alignment(value) {
    throw new Error("<MenuFlyoutWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get offset() {
    throw new Error("<MenuFlyoutWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set offset(value) {
    throw new Error("<MenuFlyoutWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MenuFlyoutWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MenuFlyoutWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapperElement() {
    throw new Error("<MenuFlyoutWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapperElement(value) {
    throw new Error("<MenuFlyoutWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchorElement() {
    throw new Error("<MenuFlyoutWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchorElement(value) {
    throw new Error("<MenuFlyoutWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get menuElement() {
    throw new Error("<MenuFlyoutWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set menuElement(value) {
    throw new Error("<MenuFlyoutWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdropElement() {
    throw new Error("<MenuFlyoutWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdropElement(value) {
    throw new Error("<MenuFlyoutWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenuFlyoutWrapper_default = MenuFlyoutWrapper;

// node_modules/fluent-svelte/MenuFlyout/MenuFlyoutItem.svelte
var file31 = "node_modules\\fluent-svelte\\MenuFlyout\\MenuFlyoutItem.svelte";
function add_css31(target) {
  append_styles(target, "svelte-1cfx437", '.menu-flyout-item.svelte-1cfx437.svelte-1cfx437{align-items:center;background-color:var(--fds-subtle-fill-transparent);block-size:28px;border-radius:var(--fds-control-corner-radius);box-sizing:border-box;color:var(--fds-text-primary);cursor:default;display:flex;flex:0 0 auto;font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;inline-size:calc(100% - 8px);line-height:20px;margin:2px 4px;outline:none;padding-inline:12px;position:relative;text-decoration:none;text-overflow:ellipsis;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;white-space:nowrap}.menu-flyout-item.svelte-1cfx437.svelte-1cfx437:before{background-color:var(--fds-accent-default);block-size:0;border-radius:3px;content:"";inline-size:3px;inset-inline-start:0;opacity:0;position:absolute;transition:transform var(--fds-control-fast-duration) var(--fds-control-fast-out-slow-in-easing)}.menu-flyout-item.svelte-1cfx437.svelte-1cfx437:focus-visible{box-shadow:var(--fds-focus-stroke)}.menu-flyout-item.selected.svelte-1cfx437.svelte-1cfx437,.menu-flyout-item.svelte-1cfx437.svelte-1cfx437:hover,.menu-flyout-item[aria-expanded=true].svelte-1cfx437.svelte-1cfx437{background-color:var(--fds-subtle-fill-secondary)}.menu-flyout-item.checked.svelte-1cfx437 .menu-flyout-item-bullet,.menu-flyout-item.checked.svelte-1cfx437 .menu-flyout-item-checkmark{visibility:visible}.menu-flyout-item.svelte-1cfx437.svelte-1cfx437:active{background-color:var(--fds-subtle-fill-tertiary)}.menu-flyout-item.svelte-1cfx437.svelte-1cfx437:active:before{transform:scaleY(.625)}.menu-flyout-item.disabled.svelte-1cfx437.svelte-1cfx437{background-color:var(--fds-subtle-fill-transparent);color:var(--fds-text-disabled);pointer-events:none}.menu-flyout-item.disabled.selected.svelte-1cfx437.svelte-1cfx437{background-color:var(--fds-subtle-fill-secondary)}.menu-flyout-item.disabled.selected.svelte-1cfx437.svelte-1cfx437:before{background-color:var(--fds-accent-disabled)}.menu-flyout-item.disabled.svelte-1cfx437>.menu-flyout-item-hint{color:var(--fds-text-disabled)}.menu-flyout-item.selected.svelte-1cfx437.svelte-1cfx437:before{block-size:16px;opacity:1}.menu-flyout-item.indented.svelte-1cfx437.svelte-1cfx437{-webkit-padding-start:40px;padding-inline-start:40px}.menu-flyout-item-bullet.svelte-1cfx437.svelte-1cfx437,.menu-flyout-item-checkmark.svelte-1cfx437.svelte-1cfx437{visibility:hidden}.menu-flyout-item.svelte-1cfx437 .menu-flyout-item-arrow.svelte-1cfx437{-webkit-margin-end:0;-webkit-margin-start:auto;-webkit-padding-start:24px;block-size:12px;box-sizing:content-box;inline-size:12px;margin-inline-end:0;margin-inline-start:auto;padding-inline-start:24px}.menu-flyout-item-checkmark.svelte-1cfx437.svelte-1cfx437{-webkit-margin-start:2px;-webkit-margin-end:14px;align-items:center;block-size:12px;display:flex;inline-size:12px;justify-content:center;margin-inline-end:14px;margin-inline-start:2px}.menu-flyout-item-bullet.svelte-1cfx437.svelte-1cfx437{-webkit-margin-start:6px;-webkit-margin-end:18px;background-color:currentColor;block-size:4px;border-radius:4px;inline-size:4px;margin-inline-end:18px;margin-inline-start:6px}.menu-flyout-item-input-label.svelte-1cfx437.svelte-1cfx437{display:contents}.menu-flyout-item.svelte-1cfx437>svg{fill:currentColor;-webkit-margin-end:12px;block-size:auto;inline-size:16px;margin-inline-end:12px}.menu-flyout-item.svelte-1cfx437>.menu-flyout-item-hint{color:var(--fds-text-secondary);flex:1 1 auto;overflow:hidden;padding-left:24px;text-align:end;text-overflow:ellipsis}.menu-flyout-submenu-anchor.svelte-1cfx437.svelte-1cfx437{--fds-menu-flyout-transition-offset:-50%;inset-block-start:0;inset-inline-start:100%;position:absolute;z-index:10000}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVudUZseW91dEl0ZW0uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQW9OUSwrQ0FBQSxDQUFrQixZQUFBLE1BQWtCLENBQUMsaUJBQUEsSUFBQSw2QkFBQSxDQUFtRCxDQUFDLFdBQUEsSUFBZSxDQUFDLGNBQUEsSUFBQSwyQkFBQSxDQUE4QyxDQUFDLFdBQUEsVUFBcUIsQ0FBQyxNQUFBLElBQUEsa0JBQUEsQ0FBNkIsQ0FBQyxPQUFBLE9BQWMsQ0FBQyxRQUFBLElBQVksQ0FBQyxLQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsSUFBYSxDQUFDLFlBQUEsSUFBQSxzQkFBQSxDQUF1QyxDQUFDLFVBQUEsSUFBQSxvQkFBQSxDQUFtQyxDQUFDLFlBQUEsR0FBZSxDQUFDLFlBQUEsS0FBQSxJQUFBLENBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBNEIsQ0FBQyxZQUFBLElBQWdCLENBQUMsT0FBQSxHQUFBLENBQUEsR0FBYyxDQUFDLFFBQUEsSUFBWSxDQUFDLGVBQUEsSUFBbUIsQ0FBQyxTQUFBLFFBQWlCLENBQUMsZ0JBQUEsSUFBb0IsQ0FBQyxjQUFBLFFBQXNCLENBQUMsb0JBQUEsSUFBd0IsQ0FBQyxpQkFBQSxJQUFxQixDQUFDLGdCQUFBLElBQW9CLENBQUMsWUFBQSxJQUFnQixDQUFDLFlBQUEsTUFBa0IsQ0FBQywrQ0FBQSxPQUFBLENBQXlCLGlCQUFBLElBQUEsb0JBQUEsQ0FBMEMsQ0FBQyxXQUFBLENBQVksQ0FBQyxjQUFBLEdBQWlCLENBQUMsUUFBQSxFQUFVLENBQUMsWUFBQSxHQUFlLENBQUMsbUJBQUEsQ0FBb0IsQ0FBQyxRQUFBLENBQVMsQ0FBQyxTQUFBLFFBQWlCLENBQUMsV0FBQSxTQUFBLENBQUEsSUFBQSwyQkFBQSxDQUFBLENBQUEsSUFBQSxxQ0FBQSxDQUFnRyxDQUFDLCtDQUFBLGNBQUEsQ0FBZ0MsV0FBQSxJQUFBLGtCQUFBLENBQWtDLENBQUMsaUJBQUEsdUNBQUEsQ0FBQSwrQ0FBQSxNQUFBLENBQUEsaUJBQUEsQ0FBQSxhQUFBLENBQUEsSUFBQSwrQkFBQSxDQUF5RixpQkFBQSxJQUFBLDJCQUFBLENBQWlELENBQUMsaUJBQUEsdUJBQUEsQ0FBQSxBQUFBLHdCQUFBLEFBQUEsQ0FBQSxpQkFBQSx1QkFBQSxDQUFBLEFBQUEsMkJBQUEsQUFBQSxDQUEySCxXQUFBLE9BQWtCLENBQUMsK0NBQUEsT0FBQSxDQUF5QixpQkFBQSxJQUFBLDBCQUFBLENBQWdELENBQUMsK0NBQUEsT0FBQSxPQUFBLENBQWdDLFVBQUEsT0FBQSxJQUFBLENBQXNCLENBQUMsaUJBQUEsdUNBQUEsQ0FBMkIsaUJBQUEsSUFBQSw2QkFBQSxDQUFtRCxDQUFDLE1BQUEsSUFBQSxtQkFBQSxDQUE4QixDQUFDLGVBQUEsSUFBbUIsQ0FBQyxpQkFBQSxTQUFBLHVDQUFBLENBQW9DLGlCQUFBLElBQUEsMkJBQUEsQ0FBaUQsQ0FBQyxpQkFBQSxTQUFBLHVDQUFBLE9BQUEsQ0FBMkMsaUJBQUEsSUFBQSxxQkFBQSxDQUEyQyxDQUFDLGlCQUFBLHdCQUFBLENBQUEsQUFBQSxzQkFBQSxBQUFBLENBQTJELE1BQUEsSUFBQSxtQkFBQSxDQUE4QixDQUFDLGlCQUFBLHVDQUFBLE9BQUEsQ0FBa0MsV0FBQSxJQUFlLENBQUMsUUFBQSxDQUFTLENBQUMsaUJBQUEsdUNBQUEsQ0FBMkIsc0JBQUEsSUFBMEIsQ0FBQyxxQkFBQSxJQUF5QixDQUFDLHNEQUFBLENBQUEseURBQUEsQ0FBcUQsV0FBQSxNQUFpQixDQUFDLGdDQUFBLENBQUEsc0NBQUEsQ0FBMEMsbUJBQUEsQ0FBb0IsQ0FBQyxxQkFBQSxJQUF5QixDQUFDLHNCQUFBLElBQTBCLENBQUMsV0FBQSxJQUFlLENBQUMsV0FBQSxXQUFzQixDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxrQkFBQSxDQUFtQixDQUFDLG9CQUFBLElBQXdCLENBQUMscUJBQUEsSUFBeUIsQ0FBQyx5REFBQSxDQUE0QixxQkFBQSxHQUF3QixDQUFDLG1CQUFBLElBQXVCLENBQUMsWUFBQSxNQUFrQixDQUFDLFdBQUEsSUFBZSxDQUFDLFFBQUEsSUFBWSxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxnQkFBQSxNQUFzQixDQUFDLGtCQUFBLElBQXNCLENBQUMsb0JBQUEsR0FBdUIsQ0FBQyxzREFBQSxDQUF5QixxQkFBQSxHQUF3QixDQUFDLG1CQUFBLElBQXVCLENBQUMsaUJBQUEsWUFBNkIsQ0FBQyxXQUFBLEdBQWMsQ0FBQyxjQUFBLEdBQWlCLENBQUMsWUFBQSxHQUFlLENBQUMsa0JBQUEsSUFBc0IsQ0FBQyxvQkFBQSxHQUF1QixDQUFDLDJEQUFBLENBQThCLFFBQUEsUUFBZ0IsQ0FBQyxnQ0FBQSxDQUFBLEFBQUEsR0FBQSxBQUFBLENBQStCLEtBQUEsWUFBaUIsQ0FBQyxtQkFBQSxJQUF1QixDQUFDLFdBQUEsSUFBZSxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxrQkFBQSxJQUFzQixDQUFDLGdDQUFBLENBQUEsQUFBQSxzQkFBQSxBQUFBLENBQWtELE1BQUEsSUFBQSxvQkFBQSxDQUErQixDQUFDLEtBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxJQUFhLENBQUMsU0FBQSxNQUFlLENBQUMsYUFBQSxJQUFpQixDQUFDLFdBQUEsR0FBYyxDQUFDLGNBQUEsUUFBc0IsQ0FBQyx5REFBQSxDQUE0QixvQ0FBQSxJQUF3QyxDQUFDLGtCQUFBLENBQW1CLENBQUMsbUJBQUEsSUFBdUIsQ0FBQyxTQUFBLFFBQWlCLENBQUMsUUFBQSxLQUFhLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTWVudUZseW91dEl0ZW0uc3ZlbHRlIl19 */');
}
var get_icon_slot_changes_12 = (dirty) => ({});
var get_icon_slot_context_12 = (ctx) => ({ slot: "icon" });
var get_flyout_slot_changes4 = (dirty) => ({});
var get_flyout_slot_context4 = (ctx) => ({});
var get_icon_slot_changes5 = (dirty) => ({});
var get_icon_slot_context5 = (ctx) => ({});
function create_if_block_44(ctx) {
  let label;
  let menuflyoutitem;
  let t;
  let current;
  menuflyoutitem = new MenuFlyoutItem({
    props: {
      checked: (
        /*checked*/
        ctx[2] || /*group*/
        ctx[3] === /*value*/
        ctx[4]
      ),
      selected: (
        /*selected*/
        ctx[12]
      ),
      variant: (
        /*variant*/
        ctx[9]
      ),
      indented: (
        /*indented*/
        ctx[13]
      ),
      group: (
        /*group*/
        ctx[3]
      ),
      disabled: (
        /*disabled*/
        ctx[14]
      ),
      __depth: true,
      $$slots: {
        icon: [create_icon_slot],
        default: [create_default_slot_24]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  function select_block_type_1(ctx2, dirty) {
    if (
      /*variant*/
      ctx2[9] === "radio"
    )
      return create_if_block_52;
    return create_else_block8;
  }
  let current_block_type = select_block_type_1(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      label = element("label");
      create_component(menuflyoutitem.$$.fragment);
      t = space();
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { class: true });
      var label_nodes = children(label);
      claim_component(menuflyoutitem.$$.fragment, label_nodes);
      t = claim_space(label_nodes);
      if_block.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label, "class", "menu-flyout-item-input-label svelte-1cfx437");
      add_location(label, file31, 152, 1, 5868);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      mount_component(menuflyoutitem, label, null);
      append_hydration_dev(label, t);
      if_block.m(label, null);
      ctx[42](label);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const menuflyoutitem_changes = {};
      if (dirty[0] & /*checked, group, value*/
      28)
        menuflyoutitem_changes.checked = /*checked*/
        ctx2[2] || /*group*/
        ctx2[3] === /*value*/
        ctx2[4];
      if (dirty[0] & /*selected*/
      4096)
        menuflyoutitem_changes.selected = /*selected*/
        ctx2[12];
      if (dirty[0] & /*variant*/
      512)
        menuflyoutitem_changes.variant = /*variant*/
        ctx2[9];
      if (dirty[0] & /*indented*/
      8192)
        menuflyoutitem_changes.indented = /*indented*/
        ctx2[13];
      if (dirty[0] & /*group*/
      8)
        menuflyoutitem_changes.group = /*group*/
        ctx2[3];
      if (dirty[0] & /*disabled*/
      16384)
        menuflyoutitem_changes.disabled = /*disabled*/
        ctx2[14];
      if (dirty[0] & /*variant*/
      512 | dirty[1] & /*$$scope*/
      4096) {
        menuflyoutitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuflyoutitem.$set(menuflyoutitem_changes);
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(label, null);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(menuflyoutitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(menuflyoutitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      destroy_component(menuflyoutitem);
      if_block.d();
      ctx[42](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_44.name,
    type: "if",
    source: "(151:54) ",
    ctx
  });
  return block;
}
function create_if_block21(ctx) {
  let li;
  let t0;
  let t1;
  let t2;
  let li_tabindex_value;
  let li_aria_expanded_value;
  let li_aria_haspopup_value;
  let li_aria_controls_value;
  let li_aria_selected_value;
  let li_class_value;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const icon_slot_template = (
    /*#slots*/
    ctx[26].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    get_icon_slot_context5
  );
  const default_slot_template = (
    /*#slots*/
    ctx[26].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    null
  );
  let if_block0 = (
    /*hint*/
    ctx[11] && create_if_block_34(ctx)
  );
  let if_block1 = (
    /*cascading*/
    ctx[10] && create_if_block_115(ctx)
  );
  let li_levels = [
    {
      tabindex: li_tabindex_value = /*disabled*/
      ctx[14] ? -1 : 0
    },
    { role: "menuitem" },
    {
      "aria-expanded": li_aria_expanded_value = /*$$slots*/
      ctx[24].flyout && !/*disabled*/
      ctx[14] && /*open*/
      ctx[0]
    },
    {
      "aria-haspopup": li_aria_haspopup_value = /*$$slots*/
      ctx[24].flyout && !/*disabled*/
      ctx[14] && /*open*/
      ctx[0]
    },
    {
      "aria-controls": li_aria_controls_value = /*$$slots*/
      ctx[24].flyout && !/*disabled*/
      ctx[14] && /*menuId*/
      ctx[19]
    },
    {
      "aria-selected": li_aria_selected_value = /*selected*/
      ctx[12] || /*checked*/
      ctx[2]
    },
    {
      class: li_class_value = "menu-flyout-item type-" + /*variant*/
      ctx[9] + " " + /*className*/
      ctx[16]
    },
    /*$$restProps*/
    ctx[25]
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if (icon_slot)
        icon_slot.c();
      t0 = space();
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {
        tabindex: true,
        role: true,
        "aria-expanded": true,
        "aria-haspopup": true,
        "aria-controls": true,
        "aria-selected": true,
        class: true
      });
      var li_nodes = children(li);
      if (icon_slot)
        icon_slot.l(li_nodes);
      t0 = claim_space(li_nodes);
      if (default_slot)
        default_slot.l(li_nodes);
      t1 = claim_space(li_nodes);
      if (if_block0)
        if_block0.l(li_nodes);
      t2 = claim_space(li_nodes);
      if (if_block1)
        if_block1.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(li, li_data);
      toggle_class(
        li,
        "cascading",
        /*cascading*/
        ctx[10]
      );
      toggle_class(
        li,
        "selected",
        /*selected*/
        ctx[12]
      );
      toggle_class(
        li,
        "checked",
        /*checked*/
        ctx[2]
      );
      toggle_class(
        li,
        "disabled",
        /*disabled*/
        ctx[14]
      );
      toggle_class(
        li,
        "indented",
        /*indented*/
        ctx[13]
      );
      toggle_class(li, "svelte-1cfx437", true);
      add_location(li, file31, 96, 1, 4101);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (icon_slot) {
        icon_slot.m(li, null);
      }
      append_hydration_dev(li, t0);
      if (default_slot) {
        default_slot.m(li, null);
      }
      append_hydration_dev(li, t1);
      if (if_block0)
        if_block0.m(li, null);
      append_hydration_dev(li, t2);
      if (if_block1)
        if_block1.m(li, null);
      ctx[36](li);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[18].call(null, li)),
          listen_dev(
            li,
            "click",
            /*close*/
            ctx[20],
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "mouseenter",
            /*handleMouseEnter*/
            ctx[22],
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "mouseleave",
            /*handleMouseLeave*/
            ctx[23],
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "keydown",
            /*handleKeyDown*/
            ctx[21],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              get_icon_slot_changes5
            ),
            get_icon_slot_context5
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*hint*/
        ctx2[11]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*hint*/
          2048) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_34(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(li, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*cascading*/
        ctx2[10]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*cascading*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_115(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(li, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        (!current || dirty[0] & /*disabled*/
        16384 && li_tabindex_value !== (li_tabindex_value = /*disabled*/
        ctx2[14] ? -1 : 0)) && { tabindex: li_tabindex_value },
        { role: "menuitem" },
        (!current || dirty[0] & /*$$slots, disabled, open*/
        16793601 && li_aria_expanded_value !== (li_aria_expanded_value = /*$$slots*/
        ctx2[24].flyout && !/*disabled*/
        ctx2[14] && /*open*/
        ctx2[0])) && { "aria-expanded": li_aria_expanded_value },
        (!current || dirty[0] & /*$$slots, disabled, open*/
        16793601 && li_aria_haspopup_value !== (li_aria_haspopup_value = /*$$slots*/
        ctx2[24].flyout && !/*disabled*/
        ctx2[14] && /*open*/
        ctx2[0])) && { "aria-haspopup": li_aria_haspopup_value },
        (!current || dirty[0] & /*$$slots, disabled*/
        16793600 && li_aria_controls_value !== (li_aria_controls_value = /*$$slots*/
        ctx2[24].flyout && !/*disabled*/
        ctx2[14] && /*menuId*/
        ctx2[19])) && { "aria-controls": li_aria_controls_value },
        (!current || dirty[0] & /*selected, checked*/
        4100 && li_aria_selected_value !== (li_aria_selected_value = /*selected*/
        ctx2[12] || /*checked*/
        ctx2[2])) && { "aria-selected": li_aria_selected_value },
        (!current || dirty[0] & /*variant, className*/
        66048 && li_class_value !== (li_class_value = "menu-flyout-item type-" + /*variant*/
        ctx2[9] + " " + /*className*/
        ctx2[16])) && { class: li_class_value },
        dirty[0] & /*$$restProps*/
        33554432 && /*$$restProps*/
        ctx2[25]
      ]));
      toggle_class(
        li,
        "cascading",
        /*cascading*/
        ctx2[10]
      );
      toggle_class(
        li,
        "selected",
        /*selected*/
        ctx2[12]
      );
      toggle_class(
        li,
        "checked",
        /*checked*/
        ctx2[2]
      );
      toggle_class(
        li,
        "disabled",
        /*disabled*/
        ctx2[14]
      );
      toggle_class(
        li,
        "indented",
        /*indented*/
        ctx2[13]
      );
      toggle_class(li, "svelte-1cfx437", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(default_slot, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot, local);
      transition_out(default_slot, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (icon_slot)
        icon_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[36](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block21.name,
    type: "if",
    source: '(96:0) {#if variant === \\"standard\\" || __depth}',
    ctx
  });
  return block;
}
function create_if_block_62(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        fill: true,
        xmlns: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true, fill: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9.85355 3.14645C10.0488 3.34171 10.0488 3.65829 9.85355 3.85355L5.35355 8.35355C5.15829 8.54882 4.84171 8.54882 4.64645 8.35355L2.64645 6.35355C2.45118 6.15829 2.45118 5.84171 2.64645 5.64645C2.84171 5.45118 3.15829 5.45118 3.35355 5.64645L5 7.29289L9.14645 3.14645C9.34171 2.95118 9.65829 2.95118 9.85355 3.14645Z");
      attr_dev(path, "fill", "currentColor");
      add_location(path, file31, 172, 6, 6370);
      attr_dev(svg, "width", "12");
      attr_dev(svg, "height", "12");
      attr_dev(svg, "viewBox", "0 0 12 12");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      add_location(svg, file31, 165, 5, 6232);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_62.name,
    type: "if",
    source: '(165:4) {#if variant === \\"toggle\\"}',
    ctx
  });
  return block;
}
function create_default_slot_24(ctx) {
  let div;
  let div_class_value;
  let t;
  let current;
  let if_block = (
    /*variant*/
    ctx[9] === "toggle" && create_if_block_62(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[26].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      t = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "menu-flyout-item-" + /*variant*/
      (ctx[9] === "radio" ? "bullet" : "checkmark") + " svelte-1cfx437");
      add_location(div, file31, 163, 3, 6118);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      insert_hydration_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*variant*/
        ctx2[9] === "toggle"
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block_62(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty[0] & /*variant*/
      512 && div_class_value !== (div_class_value = "menu-flyout-item-" + /*variant*/
      (ctx2[9] === "radio" ? "bullet" : "checkmark") + " svelte-1cfx437")) {
        attr_dev(div, "class", div_class_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_24.name,
    type: "slot",
    source: "(154:2) <svelte:self    checked={checked || group === value}    {selected}    {variant}    {indented}    {group}    {disabled}    __depth   >",
    ctx
  });
  return block;
}
function create_icon_slot(ctx) {
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[26].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    get_icon_slot_context_12
  );
  const block = {
    c: function create() {
      if (icon_slot)
        icon_slot.c();
    },
    l: function claim(nodes) {
      if (icon_slot)
        icon_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              get_icon_slot_changes_12
            ),
            get_icon_slot_context_12
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_icon_slot.name,
    type: "slot",
    source: "(163:3) ",
    ctx
  });
  return block;
}
function create_else_block8(ctx) {
  let input;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "checkbox");
      input.hidden = true;
      input.disabled = /*disabled*/
      ctx[14];
      ctx[38][0].push(input);
      add_location(input, file31, 196, 3, 7017);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      ctx[40](input);
      input.checked = ~/*group*/
      ctx[3].indexOf(input.__value);
      input.checked = /*checked*/
      ctx[2];
      set_input_value(
        input,
        /*value*/
        ctx[4]
      );
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*change_handler_1*/
            ctx[30],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_1*/
            ctx[31],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "beforeinput",
            /*beforeinput_handler_1*/
            ctx[32],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*input_change_handler_1*/
            ctx[41]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*disabled*/
      16384) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[14]
        );
      }
      if (dirty[0] & /*group*/
      8) {
        input.checked = ~/*group*/
        ctx2[3].indexOf(input.__value);
      }
      if (dirty[0] & /*checked*/
      4) {
        input.checked = /*checked*/
        ctx2[2];
      }
      if (dirty[0] & /*value*/
      16) {
        set_input_value(
          input,
          /*value*/
          ctx2[4]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[40](null);
      ctx[38][0].splice(
        /*$$binding_groups*/
        ctx[38][0].indexOf(input),
        1
      );
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block8.name,
    type: "else",
    source: "(196:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_52(ctx) {
  let input;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "radio");
      input.hidden = true;
      input.__value = /*value*/
      ctx[4];
      input.value = input.__value;
      input.checked = /*checked*/
      ctx[2];
      input.disabled = /*disabled*/
      ctx[14];
      ctx[38][0].push(input);
      add_location(input, file31, 183, 3, 6832);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      input.checked = input.__value === /*group*/
      ctx[3];
      ctx[39](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[27],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[28],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "beforeinput",
            /*beforeinput_handler*/
            ctx[29],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[37]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*value*/
      16) {
        prop_dev(
          input,
          "__value",
          /*value*/
          ctx2[4]
        );
        input.value = input.__value;
      }
      if (dirty[0] & /*checked*/
      4) {
        prop_dev(
          input,
          "checked",
          /*checked*/
          ctx2[2]
        );
      }
      if (dirty[0] & /*disabled*/
      16384) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[14]
        );
      }
      if (dirty[0] & /*group*/
      8) {
        input.checked = input.__value === /*group*/
        ctx2[3];
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[38][0].splice(
        /*$$binding_groups*/
        ctx[38][0].indexOf(input),
        1
      );
      ctx[39](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_52.name,
    type: "if",
    source: '(183:2) {#if variant === \\"radio\\"}',
    ctx
  });
  return block;
}
function create_if_block_34(ctx) {
  let textblock;
  let current;
  textblock = new TextBlock_default({
    props: {
      class: "menu-flyout-item-hint",
      variant: "caption",
      $$slots: { default: [create_default_slot_16] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(textblock.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(textblock.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(textblock, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const textblock_changes = {};
      if (dirty[0] & /*hint*/
      2048 | dirty[1] & /*$$scope*/
      4096) {
        textblock_changes.$$scope = { dirty, ctx: ctx2 };
      }
      textblock.$set(textblock_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(textblock.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(textblock.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(textblock, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_34.name,
    type: "if",
    source: "(120:2) {#if hint}",
    ctx
  });
  return block;
}
function create_default_slot_16(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*hint*/
        ctx[11]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*hint*/
        ctx[11]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*hint*/
      2048)
        set_data_dev(
          t,
          /*hint*/
          ctx2[11]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_16.name,
    type: "slot",
    source: '(121:3) <TextBlock class=\\"menu-flyout-item-hint\\" variant=\\"caption\\">',
    ctx
  });
  return block;
}
function create_if_block_115(ctx) {
  let svg;
  let path;
  let t;
  let if_block_anchor;
  let current;
  let if_block = (
    /*open*/
    ctx[0] && /*$$slots*/
    ctx[24].flyout && !/*disabled*/
    ctx[14] && create_if_block_28(ctx)
  );
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        class: true,
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        fill: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true, fill: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      t = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4.64645 2.14645C4.45118 2.34171 4.45118 2.65829 4.64645 2.85355L7.79289 6L4.64645 9.14645C4.45118 9.34171 4.45118 9.65829 4.64645 9.85355C4.84171 10.0488 5.15829 10.0488 5.35355 9.85355L8.85355 6.35355C9.04882 6.15829 9.04882 5.84171 8.85355 5.64645L5.35355 2.14645C5.15829 1.95118 4.84171 1.95118 4.64645 2.14645Z");
      attr_dev(path, "fill", "currentColor");
      add_location(path, file31, 131, 4, 4993);
      attr_dev(svg, "class", "menu-flyout-item-arrow svelte-1cfx437");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "12");
      attr_dev(svg, "height", "12");
      attr_dev(svg, "viewBox", "0 0 12 12");
      attr_dev(svg, "fill", "none");
      add_location(svg, file31, 123, 3, 4834);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      insert_hydration_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*open*/
        ctx2[0] && /*$$slots*/
        ctx2[24].flyout && !/*disabled*/
        ctx2[14]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*open, $$slots, disabled*/
          16793601) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_28(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (detaching)
        detach_dev(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_115.name,
    type: "if",
    source: "(123:2) {#if cascading}",
    ctx
  });
  return block;
}
function create_if_block_28(ctx) {
  let div;
  let menuflyoutsurface;
  let updating_element;
  let arrowNavigation_action;
  let current;
  let mounted;
  let dispose;
  function menuflyoutsurface_element_binding(value) {
    ctx[33](value);
  }
  let menuflyoutsurface_props = {
    $$slots: { default: [create_default_slot12] },
    $$scope: { ctx }
  };
  if (
    /*subMenuElement*/
    ctx[1] !== void 0
  ) {
    menuflyoutsurface_props.element = /*subMenuElement*/
    ctx[1];
  }
  menuflyoutsurface = new MenuFlyoutSurface_default({
    props: menuflyoutsurface_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(menuflyoutsurface, "element", menuflyoutsurface_element_binding));
  ctx[34](menuflyoutsurface);
  const block = {
    c: function create() {
      div = element("div");
      create_component(menuflyoutsurface.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true, class: true });
      var div_nodes = children(div);
      claim_component(menuflyoutsurface.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "id",
        /*menuId*/
        ctx[19]
      );
      attr_dev(div, "class", "menu-flyout-submenu-anchor svelte-1cfx437");
      add_location(div, file31, 137, 4, 5415);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(menuflyoutsurface, div, null);
      ctx[35](div);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(arrowNavigation_action = arrowNavigation.call(null, div, { preventTab: true, stopPropagation: true }));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const menuflyoutsurface_changes = {};
      if (dirty[1] & /*$$scope*/
      4096) {
        menuflyoutsurface_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_element && dirty[0] & /*subMenuElement*/
      2) {
        updating_element = true;
        menuflyoutsurface_changes.element = /*subMenuElement*/
        ctx2[1];
        add_flush_callback(() => updating_element = false);
      }
      menuflyoutsurface.$set(menuflyoutsurface_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(menuflyoutsurface.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(menuflyoutsurface.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[34](null);
      destroy_component(menuflyoutsurface);
      ctx[35](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_28.name,
    type: "if",
    source: "(137:3) {#if open && $$slots.flyout && !disabled}",
    ctx
  });
  return block;
}
function create_default_slot12(ctx) {
  let current;
  const flyout_slot_template = (
    /*#slots*/
    ctx[26].flyout
  );
  const flyout_slot = create_slot(
    flyout_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    get_flyout_slot_context4
  );
  const block = {
    c: function create() {
      if (flyout_slot)
        flyout_slot.c();
    },
    l: function claim(nodes) {
      if (flyout_slot)
        flyout_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (flyout_slot) {
        flyout_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (flyout_slot) {
        if (flyout_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            flyout_slot,
            flyout_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              flyout_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              get_flyout_slot_changes4
            ),
            get_flyout_slot_context4
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(flyout_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(flyout_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (flyout_slot)
        flyout_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot12.name,
    type: "slot",
    source: "(144:5) <MenuFlyoutSurface bind:element={subMenuElement} bind:this={menu}>",
    ctx
  });
  return block;
}
function create_fragment31(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block21, create_if_block_44];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*variant*/
      ctx2[9] === "standard" || /*__depth*/
      ctx2[15]
    )
      return 0;
    if (
      /*variant*/
      ctx2[9] === "radio" || /*variant*/
      ctx2[9] === "toggle"
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, [-1, -1]))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance31($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "variant",
    "cascading",
    "hint",
    "selected",
    "checked",
    "indented",
    "group",
    "value",
    "disabled",
    "open",
    "__depth",
    "class",
    "element",
    "inputElement",
    "inputLabelElement",
    "subMenuAnchorElement",
    "subMenuElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenuFlyoutItem", slots, ["icon", "default", "flyout"]);
  const $$slots = compute_slots(slots);
  let { variant = "standard" } = $$props;
  let { cascading = false } = $$props;
  let { hint = void 0 } = $$props;
  let { selected = false } = $$props;
  let { checked = false } = $$props;
  let { indented = false } = $$props;
  let { group = [] } = $$props;
  let { value = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { open = false } = $$props;
  let { __depth = false } = $$props;
  let { class: className = "" } = $$props;
  let { element: element2 = null } = $$props;
  let { inputElement = null } = $$props;
  let { inputLabelElement = null } = $$props;
  let { subMenuAnchorElement = null } = $$props;
  let { subMenuElement = null } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  const dispatch = createEventDispatcher();
  const closeFlyout = getContext("closeFlyout");
  const menuId = uid("fds-menu-flyout-submenu-");
  let menu = null;
  let subMenuQueue = { open: false, close: false };
  function close(event2) {
    setTimeout(() => {
      if (!cascading && closeFlyout)
        closeFlyout(event2);
    });
  }
  function handleKeyDown2(event2) {
    const { key, target } = event2;
    if (key === "Enter" || key === " ") {
      event2.preventDefault();
      target.click();
    }
    if (cascading) {
      if (key === "ArrowRight") {
        event2.stopPropagation();
        $$invalidate(0, open = true);
      } else if (open && key === "ArrowLeft") {
        event2.stopPropagation();
        $$invalidate(0, open = false);
        element2.focus();
      }
    }
  }
  function handleMouseEnter() {
    subMenuQueue.close = false;
    subMenuQueue.open = true;
    setTimeout(
      () => {
        if (subMenuQueue.open)
          $$invalidate(0, open = true);
      },
      500
    );
  }
  function handleMouseLeave() {
    subMenuQueue.close = true;
    subMenuQueue.open = false;
    setTimeout(
      () => {
        if (subMenuQueue.close)
          $$invalidate(0, open = false);
      },
      500
    );
  }
  const $$binding_groups = [[]];
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function beforeinput_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function change_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function beforeinput_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function menuflyoutsurface_element_binding(value2) {
    subMenuElement = value2;
    $$invalidate(1, subMenuElement);
  }
  function menuflyoutsurface_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      menu = $$value;
      $$invalidate(17, menu);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      subMenuAnchorElement = $$value;
      $$invalidate(8, subMenuAnchorElement);
    });
  }
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(5, element2);
    });
  }
  function input_change_handler() {
    group = this.__value;
    $$invalidate(3, group);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(6, inputElement);
    });
  }
  function input_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(6, inputElement);
    });
  }
  function input_change_handler_1() {
    group = get_binding_group_value($$binding_groups[0], this.__value, this.checked);
    checked = this.checked;
    value = this.value;
    $$invalidate(3, group);
    $$invalidate(2, checked);
    $$invalidate(4, value);
  }
  function label_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputLabelElement = $$value;
      $$invalidate(7, inputLabelElement);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(25, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("variant" in $$new_props)
      $$invalidate(9, variant = $$new_props.variant);
    if ("cascading" in $$new_props)
      $$invalidate(10, cascading = $$new_props.cascading);
    if ("hint" in $$new_props)
      $$invalidate(11, hint = $$new_props.hint);
    if ("selected" in $$new_props)
      $$invalidate(12, selected = $$new_props.selected);
    if ("checked" in $$new_props)
      $$invalidate(2, checked = $$new_props.checked);
    if ("indented" in $$new_props)
      $$invalidate(13, indented = $$new_props.indented);
    if ("group" in $$new_props)
      $$invalidate(3, group = $$new_props.group);
    if ("value" in $$new_props)
      $$invalidate(4, value = $$new_props.value);
    if ("disabled" in $$new_props)
      $$invalidate(14, disabled = $$new_props.disabled);
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("__depth" in $$new_props)
      $$invalidate(15, __depth = $$new_props.__depth);
    if ("class" in $$new_props)
      $$invalidate(16, className = $$new_props.class);
    if ("element" in $$new_props)
      $$invalidate(5, element2 = $$new_props.element);
    if ("inputElement" in $$new_props)
      $$invalidate(6, inputElement = $$new_props.inputElement);
    if ("inputLabelElement" in $$new_props)
      $$invalidate(7, inputLabelElement = $$new_props.inputLabelElement);
    if ("subMenuAnchorElement" in $$new_props)
      $$invalidate(8, subMenuAnchorElement = $$new_props.subMenuAnchorElement);
    if ("subMenuElement" in $$new_props)
      $$invalidate(1, subMenuElement = $$new_props.subMenuElement);
    if ("$$scope" in $$new_props)
      $$invalidate(43, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    getContext,
    get_current_component,
    arrowNavigation,
    uid,
    createEventForwarder,
    tabbable,
    MenuFlyoutSurface: MenuFlyoutSurface_default,
    TextBlock: TextBlock_default,
    variant,
    cascading,
    hint,
    selected,
    checked,
    indented,
    group,
    value,
    disabled,
    open,
    __depth,
    className,
    element: element2,
    inputElement,
    inputLabelElement,
    subMenuAnchorElement,
    subMenuElement,
    forwardEvents,
    dispatch,
    closeFlyout,
    menuId,
    menu,
    subMenuQueue,
    close,
    handleKeyDown: handleKeyDown2,
    handleMouseEnter,
    handleMouseLeave
  });
  $$self.$inject_state = ($$new_props) => {
    if ("variant" in $$props)
      $$invalidate(9, variant = $$new_props.variant);
    if ("cascading" in $$props)
      $$invalidate(10, cascading = $$new_props.cascading);
    if ("hint" in $$props)
      $$invalidate(11, hint = $$new_props.hint);
    if ("selected" in $$props)
      $$invalidate(12, selected = $$new_props.selected);
    if ("checked" in $$props)
      $$invalidate(2, checked = $$new_props.checked);
    if ("indented" in $$props)
      $$invalidate(13, indented = $$new_props.indented);
    if ("group" in $$props)
      $$invalidate(3, group = $$new_props.group);
    if ("value" in $$props)
      $$invalidate(4, value = $$new_props.value);
    if ("disabled" in $$props)
      $$invalidate(14, disabled = $$new_props.disabled);
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("__depth" in $$props)
      $$invalidate(15, __depth = $$new_props.__depth);
    if ("className" in $$props)
      $$invalidate(16, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(5, element2 = $$new_props.element);
    if ("inputElement" in $$props)
      $$invalidate(6, inputElement = $$new_props.inputElement);
    if ("inputLabelElement" in $$props)
      $$invalidate(7, inputLabelElement = $$new_props.inputLabelElement);
    if ("subMenuAnchorElement" in $$props)
      $$invalidate(8, subMenuAnchorElement = $$new_props.subMenuAnchorElement);
    if ("subMenuElement" in $$props)
      $$invalidate(1, subMenuElement = $$new_props.subMenuElement);
    if ("menu" in $$props)
      $$invalidate(17, menu = $$new_props.menu);
    if ("subMenuQueue" in $$props)
      subMenuQueue = $$new_props.subMenuQueue;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*open*/
    1) {
      $:
        dispatch(open ? "open" : "close");
    }
    if ($$self.$$.dirty[0] & /*open, menu, subMenuElement*/
    131075) {
      $:
        if (open && menu && tabbable(subMenuElement).length > 0)
          tabbable(subMenuElement)[0].focus();
    }
  };
  return [
    open,
    subMenuElement,
    checked,
    group,
    value,
    element2,
    inputElement,
    inputLabelElement,
    subMenuAnchorElement,
    variant,
    cascading,
    hint,
    selected,
    indented,
    disabled,
    __depth,
    className,
    menu,
    forwardEvents,
    menuId,
    close,
    handleKeyDown2,
    handleMouseEnter,
    handleMouseLeave,
    $$slots,
    $$restProps,
    slots,
    change_handler,
    input_handler,
    beforeinput_handler,
    change_handler_1,
    input_handler_1,
    beforeinput_handler_1,
    menuflyoutsurface_element_binding,
    menuflyoutsurface_binding,
    div_binding,
    li_binding,
    input_change_handler,
    $$binding_groups,
    input_binding,
    input_binding_1,
    input_change_handler_1,
    label_binding,
    $$scope
  ];
}
var MenuFlyoutItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance31,
      create_fragment31,
      safe_not_equal,
      {
        variant: 9,
        cascading: 10,
        hint: 11,
        selected: 12,
        checked: 2,
        indented: 13,
        group: 3,
        value: 4,
        disabled: 14,
        open: 0,
        __depth: 15,
        class: 16,
        element: 5,
        inputElement: 6,
        inputLabelElement: 7,
        subMenuAnchorElement: 8,
        subMenuElement: 1
      },
      add_css31,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenuFlyoutItem",
      options,
      id: create_fragment31.name
    });
  }
  get variant() {
    throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cascading() {
    throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cascading(value) {
    throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hint() {
    throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hint(value) {
    throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indented() {
    throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indented(value) {
    throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get __depth() {
    throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set __depth(value) {
    throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value) {
    throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputLabelElement() {
    throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputLabelElement(value) {
    throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subMenuAnchorElement() {
    throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subMenuAnchorElement(value) {
    throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subMenuElement() {
    throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subMenuElement(value) {
    throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenuFlyoutItem_default = MenuFlyoutItem;

// node_modules/fluent-svelte/MenuFlyout/MenuFlyoutDivider.svelte
var file32 = "node_modules\\fluent-svelte\\MenuFlyout\\MenuFlyoutDivider.svelte";
function add_css32(target) {
  append_styles(target, "svelte-fojomb", ".menu-flyout-divider.svelte-fojomb{-webkit-border-before:1px solid var(--fds-divider-stroke-default);block-size:1px;border:none;border-block-start:1px solid var(--fds-divider-stroke-default);inline-size:100%;margin-block:2px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVudUZseW91dERpdmlkZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQVNRLGtDQUFBLENBQXFCLHNCQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSw0QkFBQSxDQUFpRSxDQUFDLFdBQUEsR0FBYyxDQUFDLE9BQUEsSUFBVyxDQUFDLG1CQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSw0QkFBQSxDQUE4RCxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxhQUFBLEdBQWdCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTWVudUZseW91dERpdmlkZXIuc3ZlbHRlIl19 */");
}
function create_fragment32(ctx) {
  let hr;
  let hr_class_value;
  let hr_levels = [
    {
      class: hr_class_value = "menu-flyout-divider " + /*className*/
      ctx[1]
    },
    /*$$restProps*/
    ctx[2]
  ];
  let hr_data = {};
  for (let i = 0; i < hr_levels.length; i += 1) {
    hr_data = assign(hr_data, hr_levels[i]);
  }
  const block = {
    c: function create() {
      hr = element("hr");
      this.h();
    },
    l: function claim(nodes) {
      hr = claim_element(nodes, "HR", { class: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(hr, hr_data);
      toggle_class(hr, "svelte-fojomb", true);
      add_location(hr, file32, 7, 0, 220);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, hr, anchor);
      ctx[3](hr);
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(hr, hr_data = get_spread_update(hr_levels, [
        dirty & /*className*/
        2 && hr_class_value !== (hr_class_value = "menu-flyout-divider " + /*className*/
        ctx2[1]) && { class: hr_class_value },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
      toggle_class(hr, "svelte-fojomb", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(hr);
      ctx[3](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "element"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenuFlyoutDivider", slots, []);
  let { class: className = "" } = $$props;
  let { element: element2 = null } = $$props;
  function hr_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
  };
  $$self.$capture_state = () => ({ className, element: element2 });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [element2, className, $$restProps, hr_binding];
}
var MenuFlyoutDivider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, { class: 1, element: 0 }, add_css32);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenuFlyoutDivider",
      options,
      id: create_fragment32.name
    });
  }
  get class() {
    throw new Error("<MenuFlyoutDivider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MenuFlyoutDivider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<MenuFlyoutDivider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<MenuFlyoutDivider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenuFlyoutDivider_default = MenuFlyoutDivider;

// node_modules/fluent-svelte/ContextMenu/ContextMenu.svelte
var { window: window_12 } = globals;
var file33 = "node_modules\\fluent-svelte\\ContextMenu\\ContextMenu.svelte";
function add_css33(target) {
  append_styles(target, "svelte-vbmwyl", ".context-menu-wrapper.svelte-vbmwyl{display:contents}.context-menu-anchor.svelte-vbmwyl{position:fixed;z-index:10000}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29udGV4dE1lbnUuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXdGUSxtQ0FBQSxDQUFzQixRQUFBLFFBQWdCLENBQUMsa0NBQUEsQ0FBcUIsU0FBQSxLQUFjLENBQUMsUUFBQSxLQUFhLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQ29udGV4dE1lbnUuc3ZlbHRlIl19 */");
}
var get_flyout_slot_changes5 = (dirty) => ({});
var get_flyout_slot_context5 = (ctx) => ({});
function create_if_block22(ctx) {
  let div;
  let menuflyoutsurface;
  let updating_element;
  let mountMenu_action;
  let arrowNavigation_action;
  let externalMouseEvents_action;
  let current;
  let mounted;
  let dispose;
  const menuflyoutsurface_spread_levels = [
    /*$$restProps*/
    ctx[8]
  ];
  function menuflyoutsurface_element_binding(value) {
    ctx[14](value);
  }
  let menuflyoutsurface_props = {
    $$slots: { default: [create_default_slot13] },
    $$scope: { ctx }
  };
  for (let i = 0; i < menuflyoutsurface_spread_levels.length; i += 1) {
    menuflyoutsurface_props = assign(menuflyoutsurface_props, menuflyoutsurface_spread_levels[i]);
  }
  if (
    /*menuElement*/
    ctx[2] !== void 0
  ) {
    menuflyoutsurface_props.element = /*menuElement*/
    ctx[2];
  }
  menuflyoutsurface = new MenuFlyoutSurface_default({
    props: menuflyoutsurface_props,
    $$inline: true
  });
  ctx[13](menuflyoutsurface);
  binding_callbacks.push(() => bind(menuflyoutsurface, "element", menuflyoutsurface_element_binding));
  const block = {
    c: function create() {
      div = element("div");
      create_component(menuflyoutsurface.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      claim_component(menuflyoutsurface.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "context-menu-anchor svelte-vbmwyl");
      set_style(
        div,
        "top",
        /*menuPosition*/
        ctx[5].y + "px"
      );
      set_style(
        div,
        "left",
        /*menuPosition*/
        ctx[5].x + "px"
      );
      add_location(div, file33, 71, 2, 2191);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(menuflyoutsurface, div, null);
      ctx[15](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(mountMenu_action = mountMenu.call(null, div)),
          action_destroyer(arrowNavigation_action = arrowNavigation.call(null, div, { preventTab: true })),
          action_destroyer(externalMouseEvents_action = externalMouseEvents.call(null, div, { type: "mousedown" })),
          listen_dev(div, "contextmenu", stop_propagation(contextmenu_handler_1), false, false, true),
          listen_dev(
            div,
            "outermousedown",
            /*outermousedown_handler*/
            ctx[16],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const menuflyoutsurface_changes = dirty & /*$$restProps*/
      256 ? get_spread_update(menuflyoutsurface_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[8]
      )]) : {};
      if (dirty & /*$$scope*/
      262144) {
        menuflyoutsurface_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_element && dirty & /*menuElement*/
      4) {
        updating_element = true;
        menuflyoutsurface_changes.element = /*menuElement*/
        ctx2[2];
        add_flush_callback(() => updating_element = false);
      }
      menuflyoutsurface.$set(menuflyoutsurface_changes);
      if (!current || dirty & /*menuPosition*/
      32) {
        set_style(
          div,
          "top",
          /*menuPosition*/
          ctx2[5].y + "px"
        );
      }
      if (!current || dirty & /*menuPosition*/
      32) {
        set_style(
          div,
          "left",
          /*menuPosition*/
          ctx2[5].x + "px"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(menuflyoutsurface.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(menuflyoutsurface.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[13](null);
      destroy_component(menuflyoutsurface);
      ctx[15](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block22.name,
    type: "if",
    source: "(71:1) {#if open}",
    ctx
  });
  return block;
}
function create_default_slot13(ctx) {
  let current;
  const flyout_slot_template = (
    /*#slots*/
    ctx[11].flyout
  );
  const flyout_slot = create_slot(
    flyout_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_flyout_slot_context5
  );
  const block = {
    c: function create() {
      if (flyout_slot)
        flyout_slot.c();
    },
    l: function claim(nodes) {
      if (flyout_slot)
        flyout_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (flyout_slot) {
        flyout_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (flyout_slot) {
        if (flyout_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            flyout_slot,
            flyout_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              flyout_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_flyout_slot_changes5
            ),
            get_flyout_slot_context5
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(flyout_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(flyout_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (flyout_slot)
        flyout_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot13.name,
    type: "slot",
    source: "(82:3) <MenuFlyoutSurface bind:this={menu} bind:element={menuElement} {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment33(ctx) {
  let div;
  let t;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  let if_block = (
    /*open*/
    ctx[0] && create_if_block22(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "context-menu-wrapper svelte-vbmwyl");
      add_location(div, file33, 63, 0, 2019);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_hydration_dev(div, t);
      if (if_block)
        if_block.m(div, null);
      ctx[17](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window_12,
            "keydown",
            /*handleEscapeKey*/
            ctx[7],
            false,
            false,
            false
          ),
          listen_dev(div, "contextmenu", stop_propagation(prevent_default(
            /*handleContextMenu*/
            ctx[6]
          )), false, true, true),
          listen_dev(
            div,
            "contextmenu",
            /*contextmenu_handler*/
            ctx[12],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*open*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*open*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block22(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[17](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function mountMenu(node) {
  document.body.appendChild(node);
  return { destroy: () => node.remove() };
}
var contextmenu_handler_1 = (e) => e.preventDefault();
function instance33($$self, $$props, $$invalidate) {
  const omit_props_names = ["closeOnSelect", "open", "wrapperElement", "anchorElement", "menuElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenu", slots, ["default", "flyout"]);
  let { closeOnSelect = true } = $$props;
  let { open = false } = $$props;
  let { wrapperElement = null } = $$props;
  let { anchorElement = null } = $$props;
  let { menuElement = null } = $$props;
  const dispatch = createEventDispatcher();
  let menu;
  let menuPosition = { x: 0, y: 0 };
  let mousePosition = { x: 0, y: 0 };
  async function handleContextMenu({ clientX, clientY }) {
    $$invalidate(0, open = true);
    $$invalidate(10, mousePosition = { x: clientX, y: clientY });
  }
  function handleEscapeKey({ key }) {
    if (key === "Escape")
      $$invalidate(0, open = false);
  }
  setContext("closeFlyout", (event2) => {
    dispatch("select");
    if (closeOnSelect)
      $$invalidate(0, open = false);
  });
  function contextmenu_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function menuflyoutsurface_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      menu = $$value;
      $$invalidate(4, menu);
    });
  }
  function menuflyoutsurface_element_binding(value) {
    menuElement = value;
    $$invalidate(2, menuElement);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      anchorElement = $$value;
      $$invalidate(1, anchorElement);
    });
  }
  const outermousedown_handler = () => $$invalidate(0, open = false);
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      wrapperElement = $$value;
      $$invalidate(3, wrapperElement);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("closeOnSelect" in $$new_props)
      $$invalidate(9, closeOnSelect = $$new_props.closeOnSelect);
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("wrapperElement" in $$new_props)
      $$invalidate(3, wrapperElement = $$new_props.wrapperElement);
    if ("anchorElement" in $$new_props)
      $$invalidate(1, anchorElement = $$new_props.anchorElement);
    if ("menuElement" in $$new_props)
      $$invalidate(2, menuElement = $$new_props.menuElement);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    setContext,
    externalMouseEvents,
    arrowNavigation,
    tabbable,
    MenuFlyoutSurface: MenuFlyoutSurface_default,
    closeOnSelect,
    open,
    wrapperElement,
    anchorElement,
    menuElement,
    dispatch,
    menu,
    menuPosition,
    mousePosition,
    handleContextMenu,
    handleEscapeKey,
    mountMenu
  });
  $$self.$inject_state = ($$new_props) => {
    if ("closeOnSelect" in $$props)
      $$invalidate(9, closeOnSelect = $$new_props.closeOnSelect);
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("wrapperElement" in $$props)
      $$invalidate(3, wrapperElement = $$new_props.wrapperElement);
    if ("anchorElement" in $$props)
      $$invalidate(1, anchorElement = $$new_props.anchorElement);
    if ("menuElement" in $$props)
      $$invalidate(2, menuElement = $$new_props.menuElement);
    if ("menu" in $$props)
      $$invalidate(4, menu = $$new_props.menu);
    if ("menuPosition" in $$props)
      $$invalidate(5, menuPosition = $$new_props.menuPosition);
    if ("mousePosition" in $$props)
      $$invalidate(10, mousePosition = $$new_props.mousePosition);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open*/
    1) {
      $:
        dispatch(open ? "open" : "close");
    }
    if ($$self.$$.dirty & /*menu, menuElement*/
    20) {
      $:
        if (menu && tabbable(menuElement).length > 0)
          tabbable(menuElement)[0].focus();
    }
    if ($$self.$$.dirty & /*anchorElement, mousePosition, menuPosition*/
    1058) {
      $:
        if (anchorElement) {
          const { width, height } = anchorElement.getBoundingClientRect();
          $$invalidate(5, menuPosition.x = Math.min(window.innerWidth - width, mousePosition.x), menuPosition);
          $$invalidate(
            5,
            menuPosition.y = mousePosition.y > window.innerHeight - height ? $$invalidate(10, mousePosition.y -= height, mousePosition) : mousePosition.y,
            menuPosition
          );
          if (menuPosition.y < 0)
            $$invalidate(5, menuPosition.y = 0, menuPosition);
        }
    }
  };
  return [
    open,
    anchorElement,
    menuElement,
    wrapperElement,
    menu,
    menuPosition,
    handleContextMenu,
    handleEscapeKey,
    $$restProps,
    closeOnSelect,
    mousePosition,
    slots,
    contextmenu_handler,
    menuflyoutsurface_binding,
    menuflyoutsurface_element_binding,
    div_binding,
    outermousedown_handler,
    div_binding_1,
    $$scope
  ];
}
var ContextMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance33,
      create_fragment33,
      safe_not_equal,
      {
        closeOnSelect: 9,
        open: 0,
        wrapperElement: 3,
        anchorElement: 1,
        menuElement: 2
      },
      add_css33
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenu",
      options,
      id: create_fragment33.name
    });
  }
  get closeOnSelect() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnSelect(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapperElement() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapperElement(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchorElement() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchorElement(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get menuElement() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set menuElement(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenu_default = ContextMenu;

// node_modules/fluent-svelte/CalendarView/CalendarView.svelte
var file34 = "node_modules\\fluent-svelte\\CalendarView\\CalendarView.svelte";
function add_css34(target) {
  append_styles(target, "svelte-n0o4i6", ".calendar-view.svelte-n0o4i6.svelte-n0o4i6{background-clip:padding-box;background-color:var(--fds-solid-background-quarternary);block-size:347px;border:1px solid var(--fds-surface-stroke-flyout);border-radius:var(--fds-control-corner-radius);color:var(--fds-text-primary);display:inline-flex;flex-direction:column;font-family:var(--fds-font-family-text);inline-size:300px;position:relative;text-align:start;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.calendar-view.floating.svelte-n0o4i6.svelte-n0o4i6{border-radius:var(--fds-overlay-corner-radius);box-shadow:var(--fds-flyout-shadow)}.calendar-view-header.svelte-n0o4i6.svelte-n0o4i6,.calendar-view-pagination-controls.svelte-n0o4i6.svelte-n0o4i6{align-items:center;display:flex}.calendar-view-pagination-controls.svelte-n0o4i6 button.svelte-n0o4i6{-webkit-margin-start:4px;inline-size:30px;margin-inline-start:4px;padding:0}.calendar-view-header.svelte-n0o4i6.svelte-n0o4i6{-webkit-border-after:1px solid var(--fds-card-stroke-default);border-block-end:1px solid var(--fds-card-stroke-default);box-sizing:border-box;inline-size:100%;padding:7px}.calendar-view-header.svelte-n0o4i6 button.svelte-n0o4i6{align-items:center;background-color:var(--fds-subtle-fill-transparent);border:none;border-radius:var(--fds-control-corner-radius);color:var(--fds-text-primary);display:flex;font-family:var(--fds-font-family-text);font-size:14px;font-weight:600;justify-content:center;line-height:20px;min-block-size:32px;outline:none;padding:0}.calendar-view-header.svelte-n0o4i6 button.svelte-n0o4i6:focus-visible{box-shadow:var(--fds-focus-stroke)}.calendar-view-header.svelte-n0o4i6 button.svelte-n0o4i6:hover{background-color:var(--fds-subtle-fill-secondary)}.calendar-view-header.svelte-n0o4i6 button.svelte-n0o4i6:active{background-color:var(--fds-subtle-fill-tertiary);color:var(--fds-text-secondary)}.calendar-view-header.svelte-n0o4i6 button.svelte-n0o4i6:disabled{background-color:var(--fds-sutble-fill-disabled);color:var(--fds-text-disabled)}.calendar-view-header.svelte-n0o4i6 button:disabled svg.svelte-n0o4i6{color:var(--fds-control-strong-fill-disabled)}.calendar-view-header.svelte-n0o4i6 button svg.svelte-n0o4i6{fill:currentColor;block-size:auto;color:var(--fds-control-strong-fill-default);inline-size:16px}.calendar-view-header-text.svelte-n0o4i6.svelte-n0o4i6{flex:1 1 auto}.calendar-view-header-text.svelte-n0o4i6 button.svelte-n0o4i6{flex:1 1 auto;inline-size:100%;justify-content:flex-start;padding-inline:9px}.calendar-view-table.svelte-n0o4i6.svelte-n0o4i6{block-size:calc(100% - 6px);box-sizing:border-box;display:block;font-size:14px;inline-size:calc(100% - 6px);inset:0;margin:3px;overflow:hidden;position:absolute}.calendar-view-table-wrapper.svelte-n0o4i6.svelte-n0o4i6{background-color:var(--fds-layer-on-acrylic-background-default);block-size:298px;contain:layout;inline-size:298px;overflow:hidden;position:relative}.calendar-view-table.view-months.svelte-n0o4i6.svelte-n0o4i6,.calendar-view-table.view-years.svelte-n0o4i6.svelte-n0o4i6{block-size:calc(100% - 22px);inline-size:calc(100% - 22px);margin:11px}.calendar-view-table.view-months.svelte-n0o4i6 tr.svelte-n0o4i6,.calendar-view-table.view-years.svelte-n0o4i6 tr.svelte-n0o4i6{grid-gap:17.3333333333px;-webkit-margin-after:17.3333333333px;grid-template-columns:repeat(4,1fr);margin-block-end:17.3333333333px}.calendar-view-table.svelte-n0o4i6 td.svelte-n0o4i6,.calendar-view-table.svelte-n0o4i6 th.svelte-n0o4i6{padding:0}.calendar-view-table.svelte-n0o4i6 th.svelte-n0o4i6{align-items:center;block-size:40px;display:flex;font-size:13px;font-weight:600;justify-content:center;text-align:center}.calendar-view-table.svelte-n0o4i6 tbody.svelte-n0o4i6,.calendar-view-table.svelte-n0o4i6 thead.svelte-n0o4i6{display:flex;flex-direction:column;inline-size:100%}.calendar-view-table.svelte-n0o4i6 tbody.svelte-n0o4i6,.calendar-view-table.svelte-n0o4i6 thead tr.svelte-n0o4i6{background-color:var(--fds-solid-background-quarternary);box-shadow:inset 0 0 0 100vmax var(--fds-layer-on-acrylic-background-default)}.calendar-view-table.svelte-n0o4i6 thead.svelte-n0o4i6{position:relative;z-index:1}.calendar-view-table.svelte-n0o4i6 tbody.svelte-n0o4i6{inset-block-end:0;inset-inline-start:0;position:absolute}.calendar-view-table.svelte-n0o4i6 tbody tr.svelte-n0o4i6:last-child{-webkit-margin-after:0;margin-block-end:0}.calendar-view-table.svelte-n0o4i6 tr.svelte-n0o4i6{grid-gap:2px;-webkit-margin-after:2px;display:grid;grid-template-columns:repeat(7,1fr);inline-size:100%;margin-block-end:2px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FsZW5kYXJWaWV3LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFzbkJRLDBDQUFBLENBQWUsZ0JBQUEsV0FBMkIsQ0FBQyxpQkFBQSxJQUFBLGtDQUFBLENBQXdELENBQUMsV0FBQSxLQUFnQixDQUFDLE9BQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLDJCQUFBLENBQWlELENBQUMsY0FBQSxJQUFBLDJCQUFBLENBQThDLENBQUMsTUFBQSxJQUFBLGtCQUFBLENBQTZCLENBQUMsUUFBQSxXQUFtQixDQUFDLGVBQUEsTUFBcUIsQ0FBQyxZQUFBLElBQUEsc0JBQUEsQ0FBdUMsQ0FBQyxZQUFBLEtBQWlCLENBQUMsU0FBQSxRQUFpQixDQUFDLFdBQUEsS0FBZ0IsQ0FBQyxvQkFBQSxJQUF3QixDQUFDLGlCQUFBLElBQXFCLENBQUMsZ0JBQUEsSUFBb0IsQ0FBQyxZQUFBLElBQWdCLENBQUMsY0FBQSxxQ0FBQSxDQUF3QixjQUFBLElBQUEsMkJBQUEsQ0FBOEMsQ0FBQyxXQUFBLElBQUEsbUJBQUEsQ0FBbUMsQ0FBQyxpREFBQSxDQUFBLDhEQUFBLENBQXlELFlBQUEsTUFBa0IsQ0FBQyxRQUFBLElBQVksQ0FBQyxnREFBQSxDQUFBLG9CQUFBLENBQTBDLHFCQUFBLEdBQXdCLENBQUMsWUFBQSxJQUFnQixDQUFDLG9CQUFBLEdBQXVCLENBQUMsUUFBQSxDQUFTLENBQUMsaURBQUEsQ0FBc0IscUJBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLHlCQUFBLENBQTZELENBQUMsaUJBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLHlCQUFBLENBQXlELENBQUMsV0FBQSxVQUFxQixDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxRQUFBLEdBQVcsQ0FBQyxtQ0FBQSxDQUFBLG9CQUFBLENBQTZCLFlBQUEsTUFBa0IsQ0FBQyxpQkFBQSxJQUFBLDZCQUFBLENBQW1ELENBQUMsT0FBQSxJQUFXLENBQUMsY0FBQSxJQUFBLDJCQUFBLENBQThDLENBQUMsTUFBQSxJQUFBLGtCQUFBLENBQTZCLENBQUMsUUFBQSxJQUFZLENBQUMsWUFBQSxJQUFBLHNCQUFBLENBQXVDLENBQUMsVUFBQSxJQUFjLENBQUMsWUFBQSxHQUFlLENBQUMsZ0JBQUEsTUFBc0IsQ0FBQyxZQUFBLElBQWdCLENBQUMsZUFBQSxJQUFtQixDQUFDLFFBQUEsSUFBWSxDQUFDLFFBQUEsQ0FBUyxDQUFDLG1DQUFBLENBQUEsb0JBQUEsY0FBQSxDQUEyQyxXQUFBLElBQUEsa0JBQUEsQ0FBa0MsQ0FBQyxtQ0FBQSxDQUFBLG9CQUFBLE1BQUEsQ0FBbUMsaUJBQUEsSUFBQSwyQkFBQSxDQUFpRCxDQUFDLG1DQUFBLENBQUEsb0JBQUEsT0FBQSxDQUFvQyxpQkFBQSxJQUFBLDBCQUFBLENBQWdELENBQUMsTUFBQSxJQUFBLG9CQUFBLENBQStCLENBQUMsbUNBQUEsQ0FBQSxvQkFBQSxTQUFBLENBQXNDLGlCQUFBLElBQUEsMEJBQUEsQ0FBZ0QsQ0FBQyxNQUFBLElBQUEsbUJBQUEsQ0FBOEIsQ0FBQyxtQ0FBQSxDQUFBLE1BQUEsU0FBQSxDQUFBLGlCQUFBLENBQTBDLE1BQUEsSUFBQSxrQ0FBQSxDQUE2QyxDQUFDLG1DQUFBLENBQUEsTUFBQSxDQUFBLGlCQUFBLENBQWlDLEtBQUEsWUFBaUIsQ0FBQyxXQUFBLElBQWUsQ0FBQyxNQUFBLElBQUEsaUNBQUEsQ0FBNEMsQ0FBQyxZQUFBLElBQWdCLENBQUMsc0RBQUEsQ0FBMkIsS0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLElBQWEsQ0FBQyx3Q0FBQSxDQUFBLG9CQUFBLENBQWtDLEtBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxJQUFhLENBQUMsWUFBQSxJQUFnQixDQUFDLGdCQUFBLFVBQTBCLENBQUMsZUFBQSxHQUFrQixDQUFDLGdEQUFBLENBQXFCLFdBQUEsS0FBQSxJQUFBLENBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBMkIsQ0FBQyxXQUFBLFVBQXFCLENBQUMsUUFBQSxLQUFhLENBQUMsVUFBQSxJQUFjLENBQUMsWUFBQSxLQUFBLElBQUEsQ0FBQSxDQUFBLENBQUEsR0FBQSxDQUE0QixDQUFDLE1BQUEsQ0FBTyxDQUFDLE9BQUEsR0FBVSxDQUFDLFNBQUEsTUFBZSxDQUFDLFNBQUEsUUFBaUIsQ0FBQyx3REFBQSxDQUE2QixpQkFBQSxJQUFBLHlDQUFBLENBQStELENBQUMsV0FBQSxLQUFnQixDQUFDLFFBQUEsTUFBYyxDQUFDLFlBQUEsS0FBaUIsQ0FBQyxTQUFBLE1BQWUsQ0FBQyxTQUFBLFFBQWlCLENBQUMsb0JBQUEsd0NBQUEsQ0FBQSxvQkFBQSx1Q0FBQSxDQUFpRSxXQUFBLEtBQUEsSUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQTRCLENBQUMsWUFBQSxLQUFBLElBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUE2QixDQUFDLE9BQUEsSUFBVyxDQUFDLG9CQUFBLDBCQUFBLENBQUEsZ0JBQUEsQ0FBQSxvQkFBQSx5QkFBQSxDQUFBLGdCQUFBLENBQXVFLFNBQUEsZUFBd0IsQ0FBQyxxQkFBQSxlQUFvQyxDQUFDLHNCQUFBLE9BQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBbUMsQ0FBQyxpQkFBQSxlQUFnQyxDQUFDLGtDQUFBLENBQUEsZ0JBQUEsQ0FBQSxrQ0FBQSxDQUFBLGdCQUFBLENBQWdELFFBQUEsQ0FBUyxDQUFDLGtDQUFBLENBQUEsZ0JBQUEsQ0FBd0IsWUFBQSxNQUFrQixDQUFDLFdBQUEsSUFBZSxDQUFDLFFBQUEsSUFBWSxDQUFDLFVBQUEsSUFBYyxDQUFDLFlBQUEsR0FBZSxDQUFDLGdCQUFBLE1BQXNCLENBQUMsV0FBQSxNQUFpQixDQUFDLGtDQUFBLENBQUEsbUJBQUEsQ0FBQSxrQ0FBQSxDQUFBLG1CQUFBLENBQXNELFFBQUEsSUFBWSxDQUFDLGVBQUEsTUFBcUIsQ0FBQyxZQUFBLElBQWdCLENBQUMsa0NBQUEsQ0FBQSxtQkFBQSxDQUFBLGtDQUFBLENBQUEsS0FBQSxDQUFBLGdCQUFBLENBQXlELGlCQUFBLElBQUEsa0NBQUEsQ0FBd0QsQ0FBQyxXQUFBLEtBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxPQUFBLENBQUEsSUFBQSx5Q0FBQSxDQUE2RSxDQUFDLGtDQUFBLENBQUEsbUJBQUEsQ0FBMkIsU0FBQSxRQUFpQixDQUFDLFFBQUEsQ0FBUyxDQUFDLGtDQUFBLENBQUEsbUJBQUEsQ0FBMkIsZ0JBQUEsQ0FBaUIsQ0FBQyxtQkFBQSxDQUFvQixDQUFDLFNBQUEsUUFBaUIsQ0FBQyxrQ0FBQSxDQUFBLEtBQUEsQ0FBQSxnQkFBQSxXQUFBLENBQXlDLHFCQUFBLENBQXNCLENBQUMsaUJBQUEsQ0FBa0IsQ0FBQyxrQ0FBQSxDQUFBLGdCQUFBLENBQXdCLFNBQUEsR0FBWSxDQUFDLHFCQUFBLEdBQXdCLENBQUMsUUFBQSxJQUFZLENBQUMsc0JBQUEsT0FBQSxDQUFBLENBQUEsR0FBQSxDQUFtQyxDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxpQkFBQSxHQUFvQixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkNhbGVuZGFyVmlldy5zdmVsdGUiXX0= */");
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[41] = list[i];
  child_ctx[51] = i;
  return child_ctx;
}
function get_each_context_4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[56] = list[i];
  child_ctx[49] = i;
  const constants_0 = (
    /*value*/
    child_ctx[0] !== null && (Array.isArray(
      /*value*/
      child_ctx[0]
    ) ? indexOfDate(
      /*value*/
      child_ctx[0],
      /*year*/
      child_ctx[56],
      "year"
    ) > -1 : compareDates(
      /*value*/
      child_ctx[0],
      /*year*/
      child_ctx[56],
      "year"
    ))
  );
  child_ctx[45] = constants_0;
  const constants_1 = compareDates(
    /*year*/
    child_ctx[56],
    /*page*/
    child_ctx[11],
    "decade"
  );
  child_ctx[57] = constants_1;
  const constants_2 = getCalendarYears(
    /*page*/
    child_ctx[11]
  ).find((d) => compareDates(
    d,
    /*page*/
    child_ctx[11],
    "decade"
  ) && (!/*min*/
  child_ctx[6] || /*min*/
  child_ctx[6].getFullYear() <= d.getFullYear()) && (!/*max*/
  child_ctx[7] || /*max*/
  child_ctx[7] >= d));
  child_ctx[58] = constants_2;
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[52] = list[i];
  child_ctx[49] = i;
  const constants_0 = (
    /*value*/
    child_ctx[0] !== null && (Array.isArray(
      /*value*/
      child_ctx[0]
    ) ? indexOfDate(
      /*value*/
      child_ctx[0],
      /*month*/
      child_ctx[52],
      "month"
    ) > -1 : compareDates(
      /*value*/
      child_ctx[0],
      /*month*/
      child_ctx[52],
      "month"
    ))
  );
  child_ctx[45] = constants_0;
  const constants_1 = (
    /*month*/
    child_ctx[52].getFullYear() === /*page*/
    child_ctx[11].getFullYear()
  );
  child_ctx[53] = constants_1;
  const constants_2 = getCalendarMonths(
    /*page*/
    child_ctx[11]
  ).find((d) => compareDates(
    d,
    /*page*/
    child_ctx[11],
    "year"
  ) && (!/*min*/
  child_ctx[6] || new Date(
    /*min*/
    child_ctx[6].getFullYear(),
    /*min*/
    child_ctx[6].getMonth(),
    1
  ) <= new Date(d.getFullYear(), d.getMonth(), 1)) && (!/*max*/
  child_ctx[7] || /*max*/
  child_ctx[7] >= d));
  child_ctx[54] = constants_2;
  return child_ctx;
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[41] = list[i];
  child_ctx[43] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[44] = list[i];
  child_ctx[49] = i;
  const constants_0 = (
    /*value*/
    child_ctx[0] !== null && (Array.isArray(
      /*value*/
      child_ctx[0]
    ) ? indexOfDate(
      /*value*/
      child_ctx[0],
      /*day*/
      child_ctx[44],
      "day"
    ) > -1 : compareDates(
      /*value*/
      child_ctx[0],
      /*day*/
      child_ctx[44],
      "day"
    ))
  );
  child_ctx[45] = constants_0;
  const constants_1 = compareDates(
    /*day*/
    child_ctx[44],
    /*page*/
    child_ctx[11],
    "month"
  );
  child_ctx[46] = constants_1;
  const constants_2 = (
    /*getCalendarDays*/
    child_ctx[19](
      /*page*/
      child_ctx[11]
    ).find((d) => compareDates(
      d,
      /*page*/
      child_ctx[11],
      "month"
    ) && (!/*blackout*/
    child_ctx[5] || indexOfDate(
      /*blackout*/
      child_ctx[5],
      d,
      "day"
    ) === -1) && (!/*min*/
    child_ctx[6] || /*min*/
    child_ctx[6] <= d) && (!/*max*/
    child_ctx[7] || /*max*/
    child_ctx[7] >= d))
  );
  child_ctx[47] = constants_2;
  return child_ctx;
}
function get_each_context_5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[41] = list[i];
  child_ctx[44] = i;
  return child_ctx;
}
function create_if_block_35(ctx) {
  let thead;
  let tr;
  let each_value_5 = Array(7);
  validate_each_argument(each_value_5);
  let each_blocks = [];
  for (let i = 0; i < each_value_5.length; i += 1) {
    each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
  }
  const block = {
    c: function create() {
      thead = element("thead");
      tr = element("tr");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      thead = claim_element(nodes, "THEAD", { class: true });
      var thead_nodes = children(thead);
      tr = claim_element(thead_nodes, "TR", { class: true });
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      tr_nodes.forEach(detach_dev);
      thead_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(tr, "class", "svelte-n0o4i6");
      add_location(tr, file34, 424, 6, 16581);
      attr_dev(thead, "class", "svelte-n0o4i6");
      add_location(thead, file34, 423, 5, 16567);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, thead, anchor);
      append_hydration_dev(thead, tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(tr, null);
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*locale, weekStart*/
      264) {
        each_value_5 = Array(7);
        validate_each_argument(each_value_5);
        let i;
        for (i = 0; i < each_value_5.length; i += 1) {
          const child_ctx = get_each_context_5(ctx2, each_value_5, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_5(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tr, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_5.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(thead);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_35.name,
    type: "if",
    source: '(423:4) {#if view === \\"days\\"}',
    ctx
  });
  return block;
}
function create_each_block_5(ctx) {
  let th;
  let t0_value = getWeekdayLocale(
    /*day*/
    ctx[44],
    {
      locale: (
        /*locale*/
        ctx[3]
      ),
      format: "short",
      offset: (
        /*weekStart*/
        ctx[8]
      )
    }
  ) + "";
  let t0;
  let t1;
  let th_levels = [
    { scope: "col" },
    {
      abbr: getWeekdayLocale(
        /*day*/
        ctx[44],
        {
          locale: (
            /*locale*/
            ctx[3]
          ),
          offset: (
            /*weekStart*/
            ctx[8]
          )
        }
      )
    }
  ];
  let th_data = {};
  for (let i = 0; i < th_levels.length; i += 1) {
    th_data = assign(th_data, th_levels[i]);
  }
  const block = {
    c: function create() {
      th = element("th");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { scope: true });
      var th_nodes = children(th);
      t0 = claim_text(th_nodes, t0_value);
      t1 = claim_space(th_nodes);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(th, th_data);
      toggle_class(th, "svelte-n0o4i6", true);
      add_location(th, file34, 426, 8, 16628);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      append_hydration_dev(th, t0);
      append_hydration_dev(th, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*locale, weekStart*/
      264 && t0_value !== (t0_value = getWeekdayLocale(
        /*day*/
        ctx2[44],
        {
          locale: (
            /*locale*/
            ctx2[3]
          ),
          format: "short",
          offset: (
            /*weekStart*/
            ctx2[8]
          )
        }
      ) + ""))
        set_data_dev(t0, t0_value);
      set_attributes(th, th_data = get_spread_update(th_levels, [
        { scope: "col" },
        dirty[0] & /*locale, weekStart*/
        264 && {
          abbr: getWeekdayLocale(
            /*day*/
            ctx2[44],
            {
              locale: (
                /*locale*/
                ctx2[3]
              ),
              offset: (
                /*weekStart*/
                ctx2[8]
              )
            }
          )
        }
      ]));
      toggle_class(th, "svelte-n0o4i6", true);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_5.name,
    type: "each",
    source: "(426:7) {#each Array(7) as _, day}",
    ctx
  });
  return block;
}
function create_else_block9(ctx) {
  let each_1_anchor;
  let current;
  let each_value_2 = Array(4);
  validate_each_argument(each_value_2);
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*page, min, max, headers, value, selectMonth, handleKeyDown, locale, view, selectYear*/
      54528219) {
        each_value_2 = Array(4);
        validate_each_argument(each_value_2);
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_2.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block9.name,
    type: "else",
    source: "(516:6) {:else}",
    ctx
  });
  return block;
}
function create_if_block23(ctx) {
  let each_1_anchor;
  let current;
  let each_value = Array(6);
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*getCalendarDays, page, min, max, blackout, headers, locale, value, selectDay, handleKeyDown*/
      13109497) {
        each_value = Array(6);
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block23.name,
    type: "if",
    source: '(469:6) {#if view === \\"days\\"}',
    ctx
  });
  return block;
}
function create_if_block_29(ctx) {
  let each_1_anchor;
  let current;
  let each_value_4 = getCalendarYears(
    /*page*/
    ctx[11]
  ).slice(
    /*row*/
    ctx[51] * 4,
    /*row*/
    ctx[51] * 4 + 4
  );
  validate_each_argument(each_value_4);
  let each_blocks = [];
  for (let i = 0; i < each_value_4.length; i += 1) {
    each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*page, min, max, value, selectYear, handleKeyDown*/
      37750977) {
        each_value_4 = getCalendarYears(
          /*page*/
          ctx2[11]
        ).slice(
          /*row*/
          ctx2[51] * 4,
          /*row*/
          ctx2[51] * 4 + 4
        );
        validate_each_argument(each_value_4);
        let i;
        for (i = 0; i < each_value_4.length; i += 1) {
          const child_ctx = get_each_context_4(ctx2, each_value_4, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_4(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_4.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_4.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_29.name,
    type: "if",
    source: "(583:36) ",
    ctx
  });
  return block;
}
function create_if_block_116(ctx) {
  let each_1_anchor;
  let current;
  let each_value_3 = getCalendarMonths(
    /*page*/
    ctx[11]
  ).slice(
    /*row*/
    ctx[51] * 4,
    /*row*/
    ctx[51] * 4 + 4
  );
  validate_each_argument(each_value_3);
  let each_blocks = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*page, min, max, headers, value, selectMonth, handleKeyDown, locale*/
      20973785) {
        each_value_3 = getCalendarMonths(
          /*page*/
          ctx2[11]
        ).slice(
          /*row*/
          ctx2[51] * 4,
          /*row*/
          ctx2[51] * 4 + 4
        );
        validate_each_argument(each_value_3);
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_3.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_3.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_116.name,
    type: "if",
    source: '(519:9) {#if view === \\"months\\"}',
    ctx
  });
  return block;
}
function create_default_slot_25(ctx) {
  let t_value = (
    /*year*/
    ctx[56].getFullYear() + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*page*/
      2048 && t_value !== (t_value = /*year*/
      ctx2[56].getFullYear() + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_25.name,
    type: "slot",
    source: '(602:12) <CalendarViewItem              on:click={() => selectYear(year)}              on:keydown={e => handleKeyDown(e, year)}              variant=\\"monthYear\\"              outOfRange={!inDecade}              current={compareDates(year, new Date(), \\"year\\")}              disabled={min?.getFullYear() >               year.getFullYear() || max < year}              {selected}              tabindex={firstFocusableYear &&              compareDates(firstFocusableYear, year, \\"year\\")               ? 0               : -1}             >',
    ctx
  });
  return block;
}
function create_each_block_4(ctx) {
  var _a;
  let td;
  let calendarviewitem;
  let t;
  let current;
  function click_handler_5() {
    return (
      /*click_handler_5*/
      ctx[35](
        /*year*/
        ctx[56]
      )
    );
  }
  function keydown_handler_2(...args) {
    return (
      /*keydown_handler_2*/
      ctx[36](
        /*year*/
        ctx[56],
        ...args
      )
    );
  }
  calendarviewitem = new CalendarViewItem_default({
    props: {
      variant: "monthYear",
      outOfRange: !/*inDecade*/
      ctx[57],
      current: compareDates(
        /*year*/
        ctx[56],
        new Date(),
        "year"
      ),
      disabled: (
        /*min*/
        ((_a = ctx[6]) == null ? void 0 : _a.getFullYear()) > /*year*/
        ctx[56].getFullYear() || /*max*/
        ctx[7] < /*year*/
        ctx[56]
      ),
      selected: (
        /*selected*/
        ctx[45]
      ),
      tabindex: (
        /*firstFocusableYear*/
        ctx[58] && compareDates(
          /*firstFocusableYear*/
          ctx[58],
          /*year*/
          ctx[56],
          "year"
        ) ? 0 : -1
      ),
      $$slots: { default: [create_default_slot_25] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  calendarviewitem.$on("click", click_handler_5);
  calendarviewitem.$on("keydown", keydown_handler_2);
  const block = {
    c: function create() {
      td = element("td");
      create_component(calendarviewitem.$$.fragment);
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { role: true, class: true });
      var td_nodes = children(td);
      claim_component(calendarviewitem.$$.fragment, td_nodes);
      t = claim_space(td_nodes);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td, "role", "gridcell");
      attr_dev(td, "class", "svelte-n0o4i6");
      add_location(td, file34, 600, 11, 21790);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      mount_component(calendarviewitem, td, null);
      append_hydration_dev(td, t);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      var _a2;
      ctx = new_ctx;
      const calendarviewitem_changes = {};
      if (dirty[0] & /*page*/
      2048)
        calendarviewitem_changes.outOfRange = !/*inDecade*/
        ctx[57];
      if (dirty[0] & /*page*/
      2048)
        calendarviewitem_changes.current = compareDates(
          /*year*/
          ctx[56],
          new Date(),
          "year"
        );
      if (dirty[0] & /*min, page, max*/
      2240)
        calendarviewitem_changes.disabled = /*min*/
        ((_a2 = ctx[6]) == null ? void 0 : _a2.getFullYear()) > /*year*/
        ctx[56].getFullYear() || /*max*/
        ctx[7] < /*year*/
        ctx[56];
      if (dirty[0] & /*value, page*/
      2049)
        calendarviewitem_changes.selected = /*selected*/
        ctx[45];
      if (dirty[0] & /*page, min, max*/
      2240)
        calendarviewitem_changes.tabindex = /*firstFocusableYear*/
        ctx[58] && compareDates(
          /*firstFocusableYear*/
          ctx[58],
          /*year*/
          ctx[56],
          "year"
        ) ? 0 : -1;
      if (dirty[0] & /*page*/
      2048 | dirty[1] & /*$$scope*/
      1073741824) {
        calendarviewitem_changes.$$scope = { dirty, ctx };
      }
      calendarviewitem.$set(calendarviewitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(calendarviewitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(calendarviewitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
      destroy_component(calendarviewitem);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_4.name,
    type: "each",
    source: "(584:10) {#each getCalendarYears(page).slice(row * 4, row * 4 + 4) as year, i}",
    ctx
  });
  return block;
}
function create_default_slot_17(ctx) {
  let t_value = getMonthLocale(
    /*month*/
    ctx[52].getMonth(),
    {
      locale: (
        /*locale*/
        ctx[3]
      ),
      format: "short"
    }
  ) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*page, locale*/
      2056 && t_value !== (t_value = getMonthLocale(
        /*month*/
        ctx2[52].getMonth(),
        {
          locale: (
            /*locale*/
            ctx2[3]
          ),
          format: "short"
        }
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_17.name,
    type: "slot",
    source: '(548:12) <CalendarViewItem              on:click={() => selectMonth(month)}              on:keydown={e => handleKeyDown(e, month)}              variant=\\"monthYear\\"              outOfRange={!inYear}              current={compareDates(               month,               new Date(),               \\"month\\"              )}              disabled={(min?.getMonth() > month.getMonth() &&               min?.getFullYear() ===                month.getFullYear()) ||               max < month}              header={page &&               headers &&               month.getMonth() === 0 &&               month.getFullYear().toString()}              {selected}              tabindex={firstFocusableMonth &&              compareDates(               firstFocusableMonth,               month,               \\"month\\"              )               ? 0               : -1}             >',
    ctx
  });
  return block;
}
function create_each_block_3(ctx) {
  var _a, _b;
  let td;
  let calendarviewitem;
  let t;
  let current;
  function click_handler_4() {
    return (
      /*click_handler_4*/
      ctx[33](
        /*month*/
        ctx[52]
      )
    );
  }
  function keydown_handler_1(...args) {
    return (
      /*keydown_handler_1*/
      ctx[34](
        /*month*/
        ctx[52],
        ...args
      )
    );
  }
  calendarviewitem = new CalendarViewItem_default({
    props: {
      variant: "monthYear",
      outOfRange: !/*inYear*/
      ctx[53],
      current: compareDates(
        /*month*/
        ctx[52],
        new Date(),
        "month"
      ),
      disabled: (
        /*min*/
        ((_a = ctx[6]) == null ? void 0 : _a.getMonth()) > /*month*/
        ctx[52].getMonth() && /*min*/
        ((_b = ctx[6]) == null ? void 0 : _b.getFullYear()) === /*month*/
        ctx[52].getFullYear() || /*max*/
        ctx[7] < /*month*/
        ctx[52]
      ),
      header: (
        /*page*/
        ctx[11] && /*headers*/
        ctx[4] && /*month*/
        ctx[52].getMonth() === 0 && /*month*/
        ctx[52].getFullYear().toString()
      ),
      selected: (
        /*selected*/
        ctx[45]
      ),
      tabindex: (
        /*firstFocusableMonth*/
        ctx[54] && compareDates(
          /*firstFocusableMonth*/
          ctx[54],
          /*month*/
          ctx[52],
          "month"
        ) ? 0 : -1
      ),
      $$slots: { default: [create_default_slot_17] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  calendarviewitem.$on("click", click_handler_4);
  calendarviewitem.$on("keydown", keydown_handler_1);
  const block = {
    c: function create() {
      td = element("td");
      create_component(calendarviewitem.$$.fragment);
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { role: true, class: true });
      var td_nodes = children(td);
      claim_component(calendarviewitem.$$.fragment, td_nodes);
      t = claim_space(td_nodes);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td, "role", "gridcell");
      attr_dev(td, "class", "svelte-n0o4i6");
      add_location(td, file34, 546, 11, 20040);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      mount_component(calendarviewitem, td, null);
      append_hydration_dev(td, t);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      var _a2, _b2;
      ctx = new_ctx;
      const calendarviewitem_changes = {};
      if (dirty[0] & /*page*/
      2048)
        calendarviewitem_changes.outOfRange = !/*inYear*/
        ctx[53];
      if (dirty[0] & /*page*/
      2048)
        calendarviewitem_changes.current = compareDates(
          /*month*/
          ctx[52],
          new Date(),
          "month"
        );
      if (dirty[0] & /*min, page, max*/
      2240)
        calendarviewitem_changes.disabled = /*min*/
        ((_a2 = ctx[6]) == null ? void 0 : _a2.getMonth()) > /*month*/
        ctx[52].getMonth() && /*min*/
        ((_b2 = ctx[6]) == null ? void 0 : _b2.getFullYear()) === /*month*/
        ctx[52].getFullYear() || /*max*/
        ctx[7] < /*month*/
        ctx[52];
      if (dirty[0] & /*page, headers*/
      2064)
        calendarviewitem_changes.header = /*page*/
        ctx[11] && /*headers*/
        ctx[4] && /*month*/
        ctx[52].getMonth() === 0 && /*month*/
        ctx[52].getFullYear().toString();
      if (dirty[0] & /*value, page*/
      2049)
        calendarviewitem_changes.selected = /*selected*/
        ctx[45];
      if (dirty[0] & /*page, min, max*/
      2240)
        calendarviewitem_changes.tabindex = /*firstFocusableMonth*/
        ctx[54] && compareDates(
          /*firstFocusableMonth*/
          ctx[54],
          /*month*/
          ctx[52],
          "month"
        ) ? 0 : -1;
      if (dirty[0] & /*page, locale*/
      2056 | dirty[1] & /*$$scope*/
      1073741824) {
        calendarviewitem_changes.$$scope = { dirty, ctx };
      }
      calendarviewitem.$set(calendarviewitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(calendarviewitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(calendarviewitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
      destroy_component(calendarviewitem);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_3.name,
    type: "each",
    source: "(520:10) {#each getCalendarMonths(page).slice(row * 4, row * 4 + 4) as month, i}",
    ctx
  });
  return block;
}
function create_each_block_2(ctx) {
  let tr;
  let current_block_type_index;
  let if_block;
  let t;
  let current;
  const if_block_creators = [create_if_block_116, create_if_block_29];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*view*/
      ctx2[1] === "months"
    )
      return 0;
    if (
      /*view*/
      ctx2[1] === "years"
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx, [-1, -1]))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      tr = element("tr");
      if (if_block)
        if_block.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", { class: true });
      var tr_nodes = children(tr);
      if (if_block)
        if_block.l(tr_nodes);
      t = claim_space(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(tr, "class", "svelte-n0o4i6");
      add_location(tr, file34, 517, 8, 19143);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(tr, null);
      }
      append_hydration_dev(tr, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(tr, t);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tr);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(517:7) {#each Array(4) as _, row}",
    ctx
  });
  return block;
}
function create_default_slot14(ctx) {
  let t_value = (
    /*day*/
    ctx[44].getDate() + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*page*/
      2048 && t_value !== (t_value = /*day*/
      ctx2[44].getDate() + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot14.name,
    type: "slot",
    source: '(489:11) <CalendarViewItem             on:click={() => selectDay(day)}             on:keydown={e => handleKeyDown(e, day)}             outOfRange={!inMonth}             current={compareDates(day, new Date(), \\"day\\")}             disabled={min > day || max < day}             blackout={blackout &&              indexOfDate(blackout, day, \\"day\\") > -1}             header={page &&              headers &&              day.getDate() === 1 &&              getMonthLocale(day.getMonth(), {               locale,               format: \\"short\\"              })}             tabindex={firstFocusableDay &&             compareDates(firstFocusableDay, day, \\"day\\")              ? 0              : -1}             {selected}            >',
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let td;
  let calendarviewitem;
  let current;
  function click_handler_3() {
    return (
      /*click_handler_3*/
      ctx[31](
        /*day*/
        ctx[44]
      )
    );
  }
  function keydown_handler(...args) {
    return (
      /*keydown_handler*/
      ctx[32](
        /*day*/
        ctx[44],
        ...args
      )
    );
  }
  calendarviewitem = new CalendarViewItem_default({
    props: {
      outOfRange: !/*inMonth*/
      ctx[46],
      current: compareDates(
        /*day*/
        ctx[44],
        new Date(),
        "day"
      ),
      disabled: (
        /*min*/
        ctx[6] > /*day*/
        ctx[44] || /*max*/
        ctx[7] < /*day*/
        ctx[44]
      ),
      blackout: (
        /*blackout*/
        ctx[5] && indexOfDate(
          /*blackout*/
          ctx[5],
          /*day*/
          ctx[44],
          "day"
        ) > -1
      ),
      header: (
        /*page*/
        ctx[11] && /*headers*/
        ctx[4] && /*day*/
        ctx[44].getDate() === 1 && getMonthLocale(
          /*day*/
          ctx[44].getMonth(),
          {
            locale: (
              /*locale*/
              ctx[3]
            ),
            format: "short"
          }
        )
      ),
      tabindex: (
        /*firstFocusableDay*/
        ctx[47] && compareDates(
          /*firstFocusableDay*/
          ctx[47],
          /*day*/
          ctx[44],
          "day"
        ) ? 0 : -1
      ),
      selected: (
        /*selected*/
        ctx[45]
      ),
      $$slots: { default: [create_default_slot14] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  calendarviewitem.$on("click", click_handler_3);
  calendarviewitem.$on("keydown", keydown_handler);
  const block = {
    c: function create() {
      td = element("td");
      create_component(calendarviewitem.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { role: true, class: true });
      var td_nodes = children(td);
      claim_component(calendarviewitem.$$.fragment, td_nodes);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td, "role", "gridcell");
      attr_dev(td, "class", "svelte-n0o4i6");
      add_location(td, file34, 487, 10, 18220);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      mount_component(calendarviewitem, td, null);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const calendarviewitem_changes = {};
      if (dirty[0] & /*page*/
      2048)
        calendarviewitem_changes.outOfRange = !/*inMonth*/
        ctx[46];
      if (dirty[0] & /*page*/
      2048)
        calendarviewitem_changes.current = compareDates(
          /*day*/
          ctx[44],
          new Date(),
          "day"
        );
      if (dirty[0] & /*min, page, max*/
      2240)
        calendarviewitem_changes.disabled = /*min*/
        ctx[6] > /*day*/
        ctx[44] || /*max*/
        ctx[7] < /*day*/
        ctx[44];
      if (dirty[0] & /*blackout, page*/
      2080)
        calendarviewitem_changes.blackout = /*blackout*/
        ctx[5] && indexOfDate(
          /*blackout*/
          ctx[5],
          /*day*/
          ctx[44],
          "day"
        ) > -1;
      if (dirty[0] & /*page, headers, locale*/
      2072)
        calendarviewitem_changes.header = /*page*/
        ctx[11] && /*headers*/
        ctx[4] && /*day*/
        ctx[44].getDate() === 1 && getMonthLocale(
          /*day*/
          ctx[44].getMonth(),
          {
            locale: (
              /*locale*/
              ctx[3]
            ),
            format: "short"
          }
        );
      if (dirty[0] & /*page, blackout, min, max*/
      2272)
        calendarviewitem_changes.tabindex = /*firstFocusableDay*/
        ctx[47] && compareDates(
          /*firstFocusableDay*/
          ctx[47],
          /*day*/
          ctx[44],
          "day"
        ) ? 0 : -1;
      if (dirty[0] & /*value, page*/
      2049)
        calendarviewitem_changes.selected = /*selected*/
        ctx[45];
      if (dirty[0] & /*page*/
      2048 | dirty[1] & /*$$scope*/
      1073741824) {
        calendarviewitem_changes.$$scope = { dirty, ctx };
      }
      calendarviewitem.$set(calendarviewitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(calendarviewitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(calendarviewitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
      destroy_component(calendarviewitem);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(472:9) {#each getCalendarDays(page).slice(week * 7, week * 7 + 7) as day, i}",
    ctx
  });
  return block;
}
function create_each_block4(ctx) {
  let tr;
  let t;
  let current;
  let each_value_1 = (
    /*getCalendarDays*/
    ctx[19](
      /*page*/
      ctx[11]
    ).slice(
      /*week*/
      ctx[43] * 7,
      /*week*/
      ctx[43] * 7 + 7
    )
  );
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      tr = element("tr");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", { class: true });
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      t = claim_space(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(tr, "class", "svelte-n0o4i6");
      add_location(tr, file34, 470, 8, 17586);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(tr, null);
      }
      append_hydration_dev(tr, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*getCalendarDays, page, min, max, blackout, headers, locale, value, selectDay, handleKeyDown*/
      13109497) {
        each_value_1 = /*getCalendarDays*/
        ctx2[19](
          /*page*/
          ctx2[11]
        ).slice(
          /*week*/
          ctx2[43] * 7,
          /*week*/
          ctx2[43] * 7 + 7
        );
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(tr, t);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tr);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(470:7) {#each Array(6) as _, week}",
    ctx
  });
  return block;
}
function create_key_block_1(ctx) {
  let tbody;
  let current_block_type_index;
  let if_block;
  let bodyElementBinding_action;
  let tbody_intro;
  let tbody_outro;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block23, create_else_block9];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*view*/
      ctx2[1] === "days"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      tbody = element("tbody");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      tbody = claim_element(nodes, "TBODY", { class: true });
      var tbody_nodes = children(tbody);
      if_block.l(tbody_nodes);
      tbody_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(tbody, "class", "svelte-n0o4i6");
      add_location(tbody, file34, 443, 5, 16965);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tbody, anchor);
      if_blocks[current_block_type_index].m(tbody, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(bodyElementBinding_action = /*bodyElementBinding*/
        ctx[18].call(null, tbody));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(tbody, null);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      add_render_callback(() => {
        if (tbody_outro)
          tbody_outro.end(1);
        tbody_intro = create_in_transition(tbody, fly, {
          opacity: 1,
          duration: (
            /*pageAnimationDuration*/
            ctx[15]
          ),
          easing: circOut,
          y: (
            /*pageAnimationDirection*/
            ctx[14] === "neutral" ? 0 : (
              /*pageAnimationDirection*/
              ctx[14] === "up" ? -198 : 198
            )
          )
        });
        tbody_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      if (tbody_intro)
        tbody_intro.invalidate();
      if (local) {
        tbody_outro = create_out_transition(tbody, fly, {
          opacity: 1,
          duration: (
            /*pageAnimationDuration*/
            ctx[15]
          ),
          easing: circOut,
          y: (
            /*pageAnimationDirection*/
            ctx[14] === "neutral" ? 0 : (
              /*pageAnimationDirection*/
              ctx[14] === "up" ? 198 : -198
            )
          )
        });
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tbody);
      if_blocks[current_block_type_index].d();
      if (detaching && tbody_outro)
        tbody_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_key_block_1.name,
    type: "key",
    source: "(443:4) {#key page}",
    ctx
  });
  return block;
}
function create_key_block(ctx) {
  let table;
  let t;
  let previous_key = (
    /*page*/
    ctx[11]
  );
  let table_class_value;
  let table_intro;
  let table_outro;
  let current;
  let if_block = (
    /*view*/
    ctx[1] === "days" && create_if_block_35(ctx)
  );
  let key_block = create_key_block_1(ctx);
  const block = {
    c: function create() {
      table = element("table");
      if (if_block)
        if_block.c();
      t = space();
      key_block.c();
      this.h();
    },
    l: function claim(nodes) {
      table = claim_element(nodes, "TABLE", { class: true, role: true });
      var table_nodes = children(table);
      if (if_block)
        if_block.l(table_nodes);
      t = claim_space(table_nodes);
      key_block.l(table_nodes);
      table_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(table, "class", table_class_value = "calendar-view-table view-" + /*view*/
      ctx[1] + " svelte-n0o4i6");
      attr_dev(table, "role", "grid");
      add_location(table, file34, 406, 3, 16034);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, table, anchor);
      if (if_block)
        if_block.m(table, null);
      append_hydration_dev(table, t);
      key_block.m(table, null);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*view*/
        ctx[1] === "days"
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_35(ctx);
          if_block.c();
          if_block.m(table, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*page*/
      2048 && safe_not_equal(previous_key, previous_key = /*page*/
      ctx[11])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block_1(ctx);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(table, null);
      } else {
        key_block.p(ctx, dirty);
      }
      if (!current || dirty[0] & /*view*/
      2 && table_class_value !== (table_class_value = "calendar-view-table view-" + /*view*/
      ctx[1] + " svelte-n0o4i6")) {
        attr_dev(table, "class", table_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(key_block);
      add_render_callback(() => {
        if (table_outro)
          table_outro.end(1);
        table_intro = create_in_transition(table, fadeScale, {
          duration: (
            /*viewAnimationDirection*/
            ctx[13] !== "neutral" ? 500 : 0
          ),
          easing: circOut,
          baseScale: (
            /*viewAnimationDirection*/
            ctx[13] === "up" ? 1.29 : 0.84
          ),
          delay: (
            /*viewAnimationDirection*/
            ctx[13] !== "neutral" ? 150 : 0
          )
        });
        table_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(key_block);
      if (table_intro)
        table_intro.invalidate();
      if (local) {
        table_outro = create_out_transition(table, fadeScale, {
          duration: (
            /*viewAnimationDirection*/
            ctx[13] !== "neutral" ? 150 : 0
          ),
          easing: circOut,
          baseScale: (
            /*viewAnimationDirection*/
            ctx[13] === "up" ? 0.84 : 1.29
          ),
          delay: 0
        });
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(table);
      if (if_block)
        if_block.d();
      key_block.d(detaching);
      if (detaching && table_outro)
        table_outro.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_key_block.name,
    type: "key",
    source: "(406:2) {#key view}",
    ctx
  });
  return block;
}
function create_fragment34(ctx) {
  let div3;
  let header_1;
  let div0;
  let button0;
  let t0;
  let button0_disabled_value;
  let t1;
  let div1;
  let button1;
  let svg0;
  let path0;
  let button1_disabled_value;
  let t2;
  let button2;
  let svg1;
  let path1;
  let button2_disabled_value;
  let t3;
  let div2;
  let previous_key = (
    /*view*/
    ctx[1]
  );
  let div3_class_value;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  let key_block = create_key_block(ctx);
  let div3_levels = [
    {
      class: div3_class_value = "calendar-view " + /*className*/
      ctx[10]
    },
    /*$$restProps*/
    ctx[26]
  ];
  let div3_data = {};
  for (let i = 0; i < div3_levels.length; i += 1) {
    div3_data = assign(div3_data, div3_levels[i]);
  }
  const block = {
    c: function create() {
      div3 = element("div");
      header_1 = element("header");
      div0 = element("div");
      button0 = element("button");
      t0 = text(
        /*header*/
        ctx[12]
      );
      t1 = space();
      div1 = element("div");
      button1 = element("button");
      svg0 = svg_element("svg");
      path0 = svg_element("path");
      t2 = space();
      button2 = element("button");
      svg1 = svg_element("svg");
      path1 = svg_element("path");
      t3 = space();
      div2 = element("div");
      key_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      header_1 = claim_element(div3_nodes, "HEADER", { class: true });
      var header_1_nodes = children(header_1);
      div0 = claim_element(header_1_nodes, "DIV", {
        class: true,
        role: true,
        "aria-live": true
      });
      var div0_nodes = children(div0);
      button0 = claim_element(div0_nodes, "BUTTON", { class: true });
      var button0_nodes = children(button0);
      t0 = claim_text(
        button0_nodes,
        /*header*/
        ctx[12]
      );
      button0_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(header_1_nodes);
      div1 = claim_element(header_1_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      button1 = claim_element(div1_nodes, "BUTTON", { class: true });
      var button1_nodes = children(button1);
      svg0 = claim_svg_element(button1_nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        xmlns: true,
        class: true
      });
      var svg0_nodes = children(svg0);
      path0 = claim_svg_element(svg0_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      svg0_nodes.forEach(detach_dev);
      button1_nodes.forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      button2 = claim_element(div1_nodes, "BUTTON", { class: true });
      var button2_nodes = children(button2);
      svg1 = claim_svg_element(button2_nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        xmlns: true,
        class: true
      });
      var svg1_nodes = children(svg1);
      path1 = claim_svg_element(svg1_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg1_nodes.forEach(detach_dev);
      button2_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      header_1_nodes.forEach(detach_dev);
      t3 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      key_block.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      button0.disabled = button0_disabled_value = /*view*/
      ctx[1] === "years";
      attr_dev(button0, "class", "svelte-n0o4i6");
      add_location(button0, file34, 382, 3, 14968);
      attr_dev(div0, "class", "calendar-view-header-text svelte-n0o4i6");
      attr_dev(div0, "role", "heading");
      attr_dev(div0, "aria-live", "polite");
      add_location(div0, file34, 381, 2, 14891);
      attr_dev(path0, "d", "M4.95681 10.998C4.14912 10.998 3.67466 10.09 4.13591 9.42698L6.76854 5.64257C7.36532 4.78469 8.63448 4.7847 9.23126 5.64257L11.8639 9.42698C12.3251 10.09 11.8507 10.998 11.043 10.998H4.95681Z");
      add_location(path0, file34, 390, 5, 15327);
      attr_dev(svg0, "width", "16");
      attr_dev(svg0, "height", "16");
      attr_dev(svg0, "viewBox", "0 0 16 16");
      attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg0, "class", "svelte-n0o4i6");
      add_location(svg0, file34, 389, 4, 15238);
      button1.disabled = button1_disabled_value = /*view*/
      ctx[1] && /*min*/
      ctx[6] >= /*page*/
      ctx[11];
      attr_dev(button1, "class", "svelte-n0o4i6");
      add_location(button1, file34, 388, 3, 15162);
      attr_dev(path1, "d", "M4.95681 5C4.14912 5 3.67466 5.90803 4.13591 6.57107L6.76854 10.3555C7.36532 11.2134 8.63448 11.2133 9.23126 10.3555L11.8639 6.57106C12.3251 5.90803 11.8507 5 11.043 5H4.95681Z");
      add_location(path1, file34, 397, 5, 15729);
      attr_dev(svg1, "width", "16");
      attr_dev(svg1, "height", "16");
      attr_dev(svg1, "viewBox", "0 0 16 16");
      attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg1, "class", "svelte-n0o4i6");
      add_location(svg1, file34, 396, 4, 15640);
      button2.disabled = button2_disabled_value = /*max*/
      ctx[7] < /*nextPage*/
      ctx[16];
      attr_dev(button2, "class", "svelte-n0o4i6");
      add_location(button2, file34, 395, 3, 15570);
      attr_dev(div1, "class", "calendar-view-pagination-controls svelte-n0o4i6");
      add_location(div1, file34, 387, 2, 15111);
      attr_dev(header_1, "class", "calendar-view-header svelte-n0o4i6");
      add_location(header_1, file34, 380, 1, 14851);
      attr_dev(div2, "class", "calendar-view-table-wrapper svelte-n0o4i6");
      add_location(div2, file34, 404, 1, 15975);
      set_attributes(div3, div3_data);
      toggle_class(
        div3,
        "floating",
        /*__floating*/
        ctx[9]
      );
      toggle_class(div3, "svelte-n0o4i6", true);
      add_location(div3, file34, 373, 0, 14721);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, header_1);
      append_hydration_dev(header_1, div0);
      append_hydration_dev(div0, button0);
      append_hydration_dev(button0, t0);
      append_hydration_dev(header_1, t1);
      append_hydration_dev(header_1, div1);
      append_hydration_dev(div1, button1);
      append_hydration_dev(button1, svg0);
      append_hydration_dev(svg0, path0);
      append_hydration_dev(div1, t2);
      append_hydration_dev(div1, button2);
      append_hydration_dev(button2, svg1);
      append_hydration_dev(svg1, path1);
      append_hydration_dev(div3, t3);
      append_hydration_dev(div3, div2);
      key_block.m(div2, null);
      ctx[37](div3);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "click",
            /*click_handler*/
            ctx[28],
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*click_handler_1*/
            ctx[29],
            false,
            false,
            false
          ),
          listen_dev(
            button2,
            "click",
            /*click_handler_2*/
            ctx[30],
            false,
            false,
            false
          ),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[17].call(null, div3))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*header*/
      4096)
        set_data_dev(
          t0,
          /*header*/
          ctx2[12]
        );
      if (!current || dirty[0] & /*view*/
      2 && button0_disabled_value !== (button0_disabled_value = /*view*/
      ctx2[1] === "years")) {
        prop_dev(button0, "disabled", button0_disabled_value);
      }
      if (!current || dirty[0] & /*view, min, page*/
      2114 && button1_disabled_value !== (button1_disabled_value = /*view*/
      ctx2[1] && /*min*/
      ctx2[6] >= /*page*/
      ctx2[11])) {
        prop_dev(button1, "disabled", button1_disabled_value);
      }
      if (!current || dirty[0] & /*max, nextPage*/
      65664 && button2_disabled_value !== (button2_disabled_value = /*max*/
      ctx2[7] < /*nextPage*/
      ctx2[16])) {
        prop_dev(button2, "disabled", button2_disabled_value);
      }
      if (dirty[0] & /*view*/
      2 && safe_not_equal(previous_key, previous_key = /*view*/
      ctx2[1])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(div2, null);
      } else {
        key_block.p(ctx2, dirty);
      }
      set_attributes(div3, div3_data = get_spread_update(div3_levels, [
        (!current || dirty[0] & /*className*/
        1024 && div3_class_value !== (div3_class_value = "calendar-view " + /*className*/
        ctx2[10])) && { class: div3_class_value },
        dirty[0] & /*$$restProps*/
        67108864 && /*$$restProps*/
        ctx2[26]
      ]));
      toggle_class(
        div3,
        "floating",
        /*__floating*/
        ctx2[9]
      );
      toggle_class(div3, "svelte-n0o4i6", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(key_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div3);
      key_block.d(detaching);
      ctx[37](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function getWeekdayLocale(day, { locale = void 0, format = "long", offset = 0 } = {}) {
  return new Intl.DateTimeFormat(locale, { weekday: format, timeZone: "UTC" }).format(new Date(Date.UTC(2e3, 1, day + offset - 1)));
}
function getMonthLocale(month, { locale = void 0, format = "long" } = {}) {
  return new Intl.DateTimeFormat(locale, { month: format }).format(new Date(2e3, month));
}
function getMonthLength(year, month) {
  return new Date(year, month + 1, 0).getDate() - 1;
}
function getMonthDays(year, month) {
  const days = [];
  for (let i = 0; i < getMonthLength(year, month) + 1; i++) {
    days.push(new Date(year, month, i + 1));
  }
  return days;
}
function getYearMonths(year) {
  const days = [];
  for (let i = 0; i < 12; i++) {
    days.push(new Date(year, i, 1));
  }
  return days;
}
function compareDates(a, b, precision = "time") {
  switch (precision) {
    case "time":
      return a.getTime() === b.getTime();
    case "day":
      return a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth() && a.getDate() === b.getDate();
    case "month":
      return a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth();
    case "year":
      return a.getFullYear() === b.getFullYear();
    case "decade":
      return Math.floor(a.getFullYear() / 10) * 10 === Math.floor(b.getFullYear() / 10) * 10;
  }
}
function indexOfDate(array, date, precision = "time") {
  return array.findIndex((d) => compareDates(d, date, precision));
}
function getCalendarMonths(date) {
  const year = date.getFullYear();
  let months = [];
  return months.concat(getYearMonths(year), getYearMonths(year + 1).slice(0, 4));
}
function getCalendarYears(date) {
  const decadeStart = Math.floor(date.getFullYear() / 10) * 10;
  let years = [];
  for (let i = 0; i < 12; i++) {
    years.push(new Date(decadeStart + i, 0, 1));
  }
  if (decadeStart % 20 === 0) {
    for (let i = 0; i < 2; i++) {
      years.unshift(new Date(decadeStart - (i + 1), 0, 1));
    }
    for (let i = 0; i < 4; i++) {
      years.push(new Date(decadeStart + i + 12, 0, 1));
    }
  } else {
    for (let i = 0; i < 6; i++) {
      years.push(new Date(decadeStart + i + 12, 0, 1));
    }
  }
  return years;
}
function getPageByOffset(offset, page, view) {
  if (view === "days") {
    return new Date(page.getFullYear(), page.getMonth() + offset, 1);
  } else if (view === "months") {
    return new Date(page.getFullYear() + offset, 0, 1);
  } else if (view === "years") {
    return new Date(Math.floor(page.getFullYear() / 10) * 10 + offset * 10, 0, 1);
  }
}
function fadeScale(node, { delay = 0, duration = 0, easing = (x) => x, baseScale = 0 }) {
  const o = +getComputedStyle(node).opacity;
  const is = 1 - baseScale;
  return {
    delay,
    duration,
    css: (t) => {
      const eased = easing(t);
      return `opacity: ${eased * o}; transform: scale(${eased * is + baseScale})`;
    }
  };
}
function instance34($$self, $$props, $$invalidate) {
  let nextPage;
  const omit_props_names = [
    "locale",
    "multiple",
    "headers",
    "value",
    "blackout",
    "min",
    "max",
    "view",
    "weekStart",
    "__floating",
    "class",
    "element"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CalendarView", slots, []);
  let { locale = void 0 } = $$props;
  let { multiple = false } = $$props;
  let { headers = false } = $$props;
  let { value = null } = $$props;
  let { blackout = void 0 } = $$props;
  let { min = void 0 } = $$props;
  let { max = void 0 } = $$props;
  let { view = "days" } = $$props;
  let { weekStart = 0 } = $$props;
  let { __floating = false } = $$props;
  let { class: className = "" } = $$props;
  let { element: element2 = null } = $$props;
  const dispatch = createEventDispatcher();
  const forwardEvents = createEventForwarder(get_current_component(), ["change"]);
  const bodyElementBinding = (node) => bodyElement = node;
  let header = "";
  let viewAnimationDirection = "neutral";
  let pageAnimationDirection = "neutral";
  let pageAnimationDuration = 0;
  let bodyElement = null;
  let firstValue = Array.isArray(value) ? value[0] : value;
  let page = (!min || firstValue >= min) && (!max || firstValue < max) ? new Date(
    (firstValue !== null && firstValue !== void 0 ? firstValue : new Date()).getFullYear(),
    (firstValue !== null && firstValue !== void 0 ? firstValue : new Date()).getMonth(),
    1
  ) : firstValue < min ? new Date(min.getFullYear(), min.getMonth(), 1) : new Date(max.getFullYear(), max.getMonth(), 1);
  onMount(() => {
    $$invalidate(15, pageAnimationDuration = getCSSDuration("--fds-control-slow-duration"));
  });
  function getCalendarDays(date) {
    const year = date.getFullYear();
    const month = date.getMonth();
    const firstWeekday = new Date(year, month, 1).getDay();
    const calendarRows = 6;
    let days = [];
    let nextMonth = month + 1;
    let lastMonth = month - 1;
    let nextMonthYear = year;
    let lastMonthYear = year;
    const daysBefore = (firstWeekday - weekStart + 7) % 7;
    if (daysBefore > 0) {
      if (lastMonth === -1) {
        lastMonth = 11;
        lastMonthYear = year - 1;
      }
      days = getMonthDays(lastMonthYear, lastMonth).slice(-daysBefore);
    }
    days = days.concat(getMonthDays(year, month));
    if (nextMonth === 12) {
      nextMonth = 0;
      nextMonthYear = year + 1;
    }
    const daysAfter = 7 * calendarRows - days.length;
    days = days.concat(getMonthDays(nextMonthYear, nextMonth).slice(0, daysAfter));
    return days;
  }
  function updatePage(amount = 0, directionOverride = void 0) {
    $$invalidate(11, page = getPageByOffset(amount, page, view));
    if (directionOverride) {
      $$invalidate(14, pageAnimationDirection = directionOverride);
      return;
    }
    if (amount <= -1) {
      $$invalidate(14, pageAnimationDirection = "up");
    } else if (amount >= 1) {
      $$invalidate(14, pageAnimationDirection = "down");
    } else {
      $$invalidate(14, pageAnimationDirection = "neutral");
    }
  }
  function updateView(newView) {
    if (view === "days" && newView === "months" || view === "months" && newView === "years") {
      $$invalidate(13, viewAnimationDirection = "up");
    } else if (view === "years" && newView === "months" || view === "months" && newView === "days") {
      $$invalidate(13, viewAnimationDirection = "down");
    } else {
      $$invalidate(13, viewAnimationDirection = "neutral");
    }
    $$invalidate(14, pageAnimationDirection = "neutral");
    $$invalidate(1, view = newView);
  }
  async function handleKeyDown2(event2, date) {
    const { key } = event2;
    if (key === "ArrowUp" || key === "ArrowDown" || key === "ArrowLeft" || key === "ArrowRight" || key === "Home" || key === "End") {
      event2.preventDefault();
    }
    if (event2.ctrlKey && (key === "ArrowUp" || key === "ArrowDown")) {
      if (key === "ArrowUp") {
        updateView(view === "days" ? "months" : "years");
      } else if (key === "ArrowDown") {
        updateView(view === "years" ? "months" : "days");
      }
      return;
    }
    let focusOrder = bodyElement.querySelectorAll("button");
    let focusedDate = date;
    const focusIndex = Array.from(focusOrder).indexOf(document.activeElement);
    if (focusOrder.length === 0)
      return;
    if (view === "days") {
      let focusIncrementAmount = {
        ArrowUp: -7,
        ArrowDown: 7,
        ArrowLeft: -1,
        ArrowRight: 1
      };
      if (!focusIncrementAmount[key] || event2.shiftKey)
        return;
      focusedDate = new Date(new Date(focusedDate).setDate(focusedDate.getDate() + focusIncrementAmount[key]));
      const nextDateIsBlackout = blackout && indexOfDate(blackout, focusedDate, "day") > -1;
      if (nextDateIsBlackout) {
        focusedDate.setDate(focusedDate.getDate() + focusIncrementAmount[key]);
      }
      const calendarDays = getCalendarDays(focusedDate);
      const newFocusedDate = calendarDays.find((day) => compareDates(day, focusedDate, "time"));
      if (min > newFocusedDate || max < newFocusedDate)
        return;
      if (focusedDate.getMonth() !== page.getMonth()) {
        if (key === "ArrowLeft" || key === "ArrowUp") {
          updatePage(-1, "neutral");
        } else if (key === "ArrowRight" || key === "ArrowDown") {
          updatePage(1, "neutral");
        }
        await tick();
        focusOrder = bodyElement.querySelectorAll("button");
        focusedDate = newFocusedDate;
        focusOrder === null || focusOrder === void 0 ? void 0 : focusOrder[calendarDays.indexOf(newFocusedDate)].focus();
        return;
      }
      focusOrder === null || focusOrder === void 0 ? void 0 : focusOrder[focusIndex + focusIncrementAmount[key] * (nextDateIsBlackout ? 2 : 1)].focus();
    } else if (view === "months" || view === "years") {
      let calendar = [];
      const focusIncrementAmount = {
        ArrowUp: -4,
        ArrowDown: 4,
        ArrowLeft: -1,
        ArrowRight: 1
      };
      if (!focusIncrementAmount[key] || event2.shiftKey)
        return;
      if (view === "months") {
        focusedDate = new Date(new Date(focusedDate).setMonth(focusedDate.getMonth() + focusIncrementAmount[key], 1));
      } else {
        focusedDate = new Date(new Date(focusedDate).setFullYear(focusedDate.getFullYear() + focusIncrementAmount[key]));
      }
      calendar = view === "months" ? getCalendarMonths(focusedDate) : getCalendarYears(focusedDate);
      const newFocusedDate = calendar.find((day) => compareDates(day, focusedDate, view === "months" ? "month" : "year"));
      const aboveMinimumMonths = (min === null || min === void 0 ? void 0 : min.getMonth()) > newFocusedDate.getMonth() && (min === null || min === void 0 ? void 0 : min.getFullYear()) === newFocusedDate.getFullYear();
      const aboveMinimumYears = (min === null || min === void 0 ? void 0 : min.getFullYear()) > newFocusedDate.getFullYear();
      if ((view === "months" ? aboveMinimumMonths : aboveMinimumYears) || max < newFocusedDate)
        return;
      if (!compareDates(focusedDate, page, view === "months" ? "year" : "decade")) {
        if (key === "ArrowLeft" || key === "ArrowUp") {
          updatePage(-1, "neutral");
        } else if (key === "ArrowRight" || key === "ArrowDown") {
          updatePage(1, "neutral");
        }
        await tick();
        focusedDate = newFocusedDate;
        focusOrder = bodyElement.querySelectorAll("button");
        focusOrder === null || focusOrder === void 0 ? void 0 : focusOrder[calendar.indexOf(newFocusedDate)].focus();
        return;
      }
      focusOrder === null || focusOrder === void 0 ? void 0 : focusOrder[focusIndex + focusIncrementAmount[key]].focus();
    }
  }
  function selectDay(day) {
    if (multiple) {
      if (!Array.isArray(value)) {
        if (value !== null) {
          $$invalidate(0, value = [value]);
        } else {
          $$invalidate(0, value = [day]);
          return;
        }
      }
      if (indexOfDate(value, day) === -1) {
        value.push(day);
        $$invalidate(0, value);
      } else {
        $$invalidate(0, value = value.slice(0, indexOfDate(value, day)).concat(value.slice(indexOfDate(value, day) + 1)));
      }
    } else {
      if (Array.isArray(value))
        $$invalidate(0, value = null);
      if (day.getTime() === (value === null || value === void 0 ? void 0 : value.getTime())) {
        $$invalidate(0, value = null);
      } else {
        $$invalidate(0, value = day);
      }
    }
    dispatch("change", value);
  }
  function selectMonth(month) {
    $$invalidate(11, page = new Date(new Date(month.setDate(1))));
    updateView("days");
  }
  function selectYear(month) {
    page.setFullYear(month.getFullYear());
    updateView("months");
  }
  const click_handler3 = () => updateView(view === "days" ? "months" : "years");
  const click_handler_13 = () => updatePage(-1);
  const click_handler_2 = () => updatePage(1);
  const click_handler_3 = (day) => selectDay(day);
  const keydown_handler = (day, e) => handleKeyDown2(e, day);
  const click_handler_4 = (month) => selectMonth(month);
  const keydown_handler_1 = (month, e) => handleKeyDown2(e, month);
  const click_handler_5 = (year) => selectYear(year);
  const keydown_handler_2 = (year, e) => handleKeyDown2(e, year);
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(26, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("locale" in $$new_props)
      $$invalidate(3, locale = $$new_props.locale);
    if ("multiple" in $$new_props)
      $$invalidate(27, multiple = $$new_props.multiple);
    if ("headers" in $$new_props)
      $$invalidate(4, headers = $$new_props.headers);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("blackout" in $$new_props)
      $$invalidate(5, blackout = $$new_props.blackout);
    if ("min" in $$new_props)
      $$invalidate(6, min = $$new_props.min);
    if ("max" in $$new_props)
      $$invalidate(7, max = $$new_props.max);
    if ("view" in $$new_props)
      $$invalidate(1, view = $$new_props.view);
    if ("weekStart" in $$new_props)
      $$invalidate(8, weekStart = $$new_props.weekStart);
    if ("__floating" in $$new_props)
      $$invalidate(9, __floating = $$new_props.__floating);
    if ("class" in $$new_props)
      $$invalidate(10, className = $$new_props.class);
    if ("element" in $$new_props)
      $$invalidate(2, element2 = $$new_props.element);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    tick,
    fly,
    circOut,
    get_current_component,
    createEventForwarder,
    getCSSDuration,
    CalendarViewItem: CalendarViewItem_default,
    locale,
    multiple,
    headers,
    value,
    blackout,
    min,
    max,
    view,
    weekStart,
    __floating,
    className,
    element: element2,
    dispatch,
    forwardEvents,
    bodyElementBinding,
    header,
    viewAnimationDirection,
    pageAnimationDirection,
    pageAnimationDuration,
    bodyElement,
    firstValue,
    page,
    getWeekdayLocale,
    getMonthLocale,
    getMonthLength,
    getMonthDays,
    getYearMonths,
    compareDates,
    indexOfDate,
    getCalendarDays,
    getCalendarMonths,
    getCalendarYears,
    getPageByOffset,
    updatePage,
    updateView,
    handleKeyDown: handleKeyDown2,
    selectDay,
    selectMonth,
    selectYear,
    fadeScale,
    nextPage
  });
  $$self.$inject_state = ($$new_props) => {
    if ("locale" in $$props)
      $$invalidate(3, locale = $$new_props.locale);
    if ("multiple" in $$props)
      $$invalidate(27, multiple = $$new_props.multiple);
    if ("headers" in $$props)
      $$invalidate(4, headers = $$new_props.headers);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("blackout" in $$props)
      $$invalidate(5, blackout = $$new_props.blackout);
    if ("min" in $$props)
      $$invalidate(6, min = $$new_props.min);
    if ("max" in $$props)
      $$invalidate(7, max = $$new_props.max);
    if ("view" in $$props)
      $$invalidate(1, view = $$new_props.view);
    if ("weekStart" in $$props)
      $$invalidate(8, weekStart = $$new_props.weekStart);
    if ("__floating" in $$props)
      $$invalidate(9, __floating = $$new_props.__floating);
    if ("className" in $$props)
      $$invalidate(10, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(2, element2 = $$new_props.element);
    if ("header" in $$props)
      $$invalidate(12, header = $$new_props.header);
    if ("viewAnimationDirection" in $$props)
      $$invalidate(13, viewAnimationDirection = $$new_props.viewAnimationDirection);
    if ("pageAnimationDirection" in $$props)
      $$invalidate(14, pageAnimationDirection = $$new_props.pageAnimationDirection);
    if ("pageAnimationDuration" in $$props)
      $$invalidate(15, pageAnimationDuration = $$new_props.pageAnimationDuration);
    if ("bodyElement" in $$props)
      bodyElement = $$new_props.bodyElement;
    if ("firstValue" in $$props)
      firstValue = $$new_props.firstValue;
    if ("page" in $$props)
      $$invalidate(11, page = $$new_props.page);
    if ("nextPage" in $$props)
      $$invalidate(16, nextPage = $$new_props.nextPage);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*value*/
    1) {
      $:
        firstValue = Array.isArray(value) ? value[0] : value;
    }
    if ($$self.$$.dirty[0] & /*view*/
    2) {
      $:
        view, updatePage(0);
    }
    if ($$self.$$.dirty[0] & /*page, view*/
    2050) {
      $:
        $$invalidate(16, nextPage = getPageByOffset(1, page, view));
    }
    if ($$self.$$.dirty[0] & /*view, locale, page*/
    2058) {
      $:
        if (view === "days") {
          $$invalidate(12, header = new Intl.DateTimeFormat(locale, { year: "numeric", month: "long" }).format(page));
        } else if (view === "months") {
          $$invalidate(12, header = new Intl.DateTimeFormat(locale, { year: "numeric" }).format(page));
        } else if (view === "years") {
          const decadeStart = Math.floor(page.getFullYear() / 10) * 10;
          const decadeEnd = decadeStart + 9;
          $$invalidate(12, header = new Intl.DateTimeFormat(locale, { year: "numeric" }).formatRange(new Date(decadeStart, 0, 1), new Date(decadeEnd, 0, 1)));
        }
    }
  };
  return [
    value,
    view,
    element2,
    locale,
    headers,
    blackout,
    min,
    max,
    weekStart,
    __floating,
    className,
    page,
    header,
    viewAnimationDirection,
    pageAnimationDirection,
    pageAnimationDuration,
    nextPage,
    forwardEvents,
    bodyElementBinding,
    getCalendarDays,
    updatePage,
    updateView,
    handleKeyDown2,
    selectDay,
    selectMonth,
    selectYear,
    $$restProps,
    multiple,
    click_handler3,
    click_handler_13,
    click_handler_2,
    click_handler_3,
    keydown_handler,
    click_handler_4,
    keydown_handler_1,
    click_handler_5,
    keydown_handler_2,
    div3_binding
  ];
}
var CalendarView = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance34,
      create_fragment34,
      safe_not_equal,
      {
        locale: 3,
        multiple: 27,
        headers: 4,
        value: 0,
        blackout: 5,
        min: 6,
        max: 7,
        view: 1,
        weekStart: 8,
        __floating: 9,
        class: 10,
        element: 2
      },
      add_css34,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CalendarView",
      options,
      id: create_fragment34.name
    });
  }
  get locale() {
    throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set locale(value) {
    throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headers() {
    throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headers(value) {
    throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blackout() {
    throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blackout(value) {
    throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get view() {
    throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set view(value) {
    throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get weekStart() {
    throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set weekStart(value) {
    throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get __floating() {
    throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set __floating(value) {
    throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CalendarView_default = CalendarView;

// node_modules/fluent-svelte/CalendarDatePicker/CalendarDatePicker.svelte
var file35 = "node_modules\\fluent-svelte\\CalendarDatePicker\\CalendarDatePicker.svelte";
function add_css35(target) {
  append_styles(target, "svelte-xd03cr", ".calendar-date-picker-label.svelte-xd03cr{-webkit-padding-end:2px;padding-inline-end:2px}.calendar-date-picker-label.placeholder.svelte-xd03cr:not(.disabled){color:var(--fds-text-secondary)}.calendar-date-picker-icon.svelte-xd03cr{fill:currentColor;-webkit-margin-start:8px;block-size:auto;color:currentColor;inline-size:12px;margin-inline-start:8px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FsZW5kYXJEYXRlUGlja2VyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUF3RVEseUNBQUEsQ0FBNEIsb0JBQUEsR0FBdUIsQ0FBQyxtQkFBQSxHQUFzQixDQUFDLDJCQUFBLDBCQUFBLEtBQUEsU0FBQSxDQUFBLENBQXVELE1BQUEsSUFBQSxvQkFBQSxDQUErQixDQUFDLHdDQUFBLENBQTJCLEtBQUEsWUFBaUIsQ0FBQyxxQkFBQSxHQUF3QixDQUFDLFdBQUEsSUFBZSxDQUFDLE1BQUEsWUFBa0IsQ0FBQyxZQUFBLElBQWdCLENBQUMsb0JBQUEsR0FBdUIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDYWxlbmRhckRhdGVQaWNrZXIuc3ZlbHRlIl19 */");
}
function create_default_slot_18(ctx) {
  var _a;
  let span;
  let t0_value = (
    /*value*/
    (((_a = ctx[0]) == null ? void 0 : _a.toLocaleDateString(
      /*locale*/
      ctx[2]
    )) ?? /*placeholder*/
    ctx[3]) + ""
  );
  let t0;
  let t1;
  let svg;
  let path;
  const block = {
    c: function create() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, t0_value);
      span_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      svg = claim_svg_element(nodes, "svg", {
        class: true,
        width: true,
        height: true,
        viewBox: true,
        fill: true,
        xmlns: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "calendar-date-picker-label svelte-xd03cr");
      toggle_class(
        span,
        "disabled",
        /*disabled*/
        ctx[4]
      );
      toggle_class(span, "placeholder", typeof /*value*/
      ctx[0] === "undefined" || /*value*/
      ctx[0] === null);
      add_location(span, file35, 40, 2, 1680);
      attr_dev(path, "d", "M9.2793 0.75C9.47461 0.75 9.66016 0.791016 9.83594 0.873047C10.0156 0.951172 10.1719 1.05859 10.3047 1.19531C10.4414 1.32813 10.5488 1.48437 10.627 1.66406C10.709 1.83984 10.75 2.02539 10.75 2.2207V9.7793C10.75 9.97461 10.709 10.1621 10.627 10.3418C10.5488 10.5176 10.4414 10.6738 10.3047 10.8105C10.1719 10.9434 10.0156 11.0508 9.83594 11.1328C9.66016 11.2109 9.47461 11.25 9.2793 11.25H1.7207C1.52539 11.25 1.33789 11.2109 1.1582 11.1328C0.982422 11.0508 0.826172 10.9434 0.689453 10.8105C0.556641 10.6738 0.449219 10.5176 0.367188 10.3418C0.289062 10.1621 0.25 9.97461 0.25 9.7793V2.2207C0.25 2.02539 0.289062 1.83984 0.367188 1.66406C0.449219 1.48437 0.556641 1.32813 0.689453 1.19531C0.826172 1.05859 0.982422 0.951172 1.1582 0.873047C1.33789 0.791016 1.52539 0.75 1.7207 0.75H9.2793ZM1.75 1.5C1.64453 1.5 1.54688 1.51953 1.45703 1.55859C1.36719 1.59766 1.28711 1.65234 1.2168 1.72266C1.15039 1.78906 1.09766 1.86719 1.05859 1.95703C1.01953 2.04688 1 2.14453 1 2.25V3H10V2.25C10 2.14844 9.98047 2.05273 9.94141 1.96289C9.90234 1.86914 9.84766 1.78906 9.77734 1.72266C9.71094 1.65234 9.63086 1.59766 9.53711 1.55859C9.44727 1.51953 9.35156 1.5 9.25 1.5H1.75ZM9.25 10.5C9.35547 10.5 9.45312 10.4805 9.54297 10.4414C9.63281 10.4023 9.71094 10.3496 9.77734 10.2832C9.84766 10.2129 9.90234 10.1328 9.94141 10.043C9.98047 9.95312 10 9.85547 10 9.75V3.75H1V9.75C1 9.85547 1.01953 9.95508 1.05859 10.0488C1.09766 10.1387 1.15039 10.2168 1.2168 10.2832C1.2832 10.3496 1.36133 10.4023 1.45117 10.4414C1.54492 10.4805 1.64453 10.5 1.75 10.5H9.25ZM2.5 6C2.5 5.89453 2.51953 5.79688 2.55859 5.70703C2.59766 5.61719 2.65039 5.53906 2.7168 5.47266C2.78711 5.40234 2.86719 5.34766 2.95703 5.30859C3.05078 5.26953 3.15039 5.25 3.25586 5.25C3.36133 5.25 3.45898 5.26953 3.54883 5.30859C3.63867 5.34766 3.7168 5.40039 3.7832 5.4668C3.84961 5.5332 3.90234 5.61133 3.94141 5.70117C3.98047 5.79102 4 5.88867 4 5.99414C4 6.09961 3.98047 6.19922 3.94141 6.29297C3.90234 6.38281 3.84766 6.46289 3.77734 6.5332C3.71094 6.59961 3.63281 6.65234 3.54297 6.69141C3.45312 6.73047 3.35547 6.75 3.25 6.75C3.14453 6.75 3.04492 6.73047 2.95117 6.69141C2.86133 6.65234 2.7832 6.59961 2.7168 6.5332C2.65039 6.4668 2.59766 6.38867 2.55859 6.29883C2.51953 6.20508 2.5 6.10547 2.5 6ZM4.75 6C4.75 5.89453 4.76953 5.79688 4.80859 5.70703C4.84766 5.61719 4.90039 5.53906 4.9668 5.47266C5.03711 5.40234 5.11719 5.34766 5.20703 5.30859C5.30078 5.26953 5.40039 5.25 5.50586 5.25C5.61133 5.25 5.70898 5.26953 5.79883 5.30859C5.88867 5.34766 5.9668 5.40039 6.0332 5.4668C6.09961 5.5332 6.15234 5.61133 6.19141 5.70117C6.23047 5.79102 6.25 5.88867 6.25 5.99414C6.25 6.09961 6.23047 6.19922 6.19141 6.29297C6.15234 6.38281 6.09766 6.46289 6.02734 6.5332C5.96094 6.59961 5.88281 6.65234 5.79297 6.69141C5.70312 6.73047 5.60547 6.75 5.5 6.75C5.39453 6.75 5.29492 6.73047 5.20117 6.69141C5.11133 6.65234 5.0332 6.59961 4.9668 6.5332C4.90039 6.4668 4.84766 6.38867 4.80859 6.29883C4.76953 6.20508 4.75 6.10547 4.75 6ZM8.5 5.99414C8.5 6.09961 8.48047 6.19922 8.44141 6.29297C8.40234 6.38281 8.34766 6.46289 8.27734 6.5332C8.21094 6.59961 8.13281 6.65234 8.04297 6.69141C7.95312 6.73047 7.85547 6.75 7.75 6.75C7.64453 6.75 7.54492 6.73047 7.45117 6.69141C7.36133 6.65234 7.2832 6.59961 7.2168 6.5332C7.15039 6.4668 7.09766 6.38867 7.05859 6.29883C7.01953 6.20508 7 6.10547 7 6C7 5.89453 7.01953 5.79688 7.05859 5.70703C7.09766 5.61719 7.15039 5.53906 7.2168 5.47266C7.28711 5.40234 7.36719 5.34766 7.45703 5.30859C7.55078 5.26953 7.65039 5.25 7.75586 5.25C7.86133 5.25 7.95898 5.26953 8.04883 5.30859C8.13867 5.34766 8.2168 5.40039 8.2832 5.4668C8.34961 5.5332 8.40234 5.61133 8.44141 5.70117C8.48047 5.79102 8.5 5.88867 8.5 5.99414ZM4 8.25C4 8.35547 3.98047 8.45312 3.94141 8.54297C3.90234 8.63281 3.84766 8.71289 3.77734 8.7832C3.71094 8.84961 3.63086 8.90234 3.53711 8.94141C3.44727 8.98047 3.34961 9 3.24414 9C3.13867 9 3.04102 8.98047 2.95117 8.94141C2.86133 8.90234 2.7832 8.84961 2.7168 8.7832C2.65039 8.7168 2.59766 8.63867 2.55859 8.54883C2.51953 8.45898 2.5 8.36133 2.5 8.25586C2.5 8.15039 2.51953 8.05273 2.55859 7.96289C2.59766 7.86914 2.65039 7.78906 2.7168 7.72266C2.78711 7.65234 2.86719 7.59766 2.95703 7.55859C3.04688 7.51953 3.14453 7.5 3.25 7.5C3.35547 7.5 3.45312 7.51953 3.54297 7.55859C3.63672 7.59766 3.7168 7.65039 3.7832 7.7168C3.84961 7.7832 3.90234 7.86328 3.94141 7.95703C3.98047 8.04688 4 8.14453 4 8.25ZM6.25 8.25C6.25 8.35547 6.23047 8.45312 6.19141 8.54297C6.15234 8.63281 6.09766 8.71289 6.02734 8.7832C5.96094 8.84961 5.88086 8.90234 5.78711 8.94141C5.69727 8.98047 5.59961 9 5.49414 9C5.38867 9 5.29102 8.98047 5.20117 8.94141C5.11133 8.90234 5.0332 8.84961 4.9668 8.7832C4.90039 8.7168 4.84766 8.63867 4.80859 8.54883C4.76953 8.45898 4.75 8.36133 4.75 8.25586C4.75 8.15039 4.76953 8.05273 4.80859 7.96289C4.84766 7.86914 4.90039 7.78906 4.9668 7.72266C5.03711 7.65234 5.11719 7.59766 5.20703 7.55859C5.29688 7.51953 5.39453 7.5 5.5 7.5C5.60547 7.5 5.70312 7.51953 5.79297 7.55859C5.88672 7.59766 5.9668 7.65039 6.0332 7.7168C6.09961 7.7832 6.15234 7.86328 6.19141 7.95703C6.23047 8.04688 6.25 8.14453 6.25 8.25Z");
      add_location(path, file35, 55, 3, 2036);
      attr_dev(svg, "class", "calendar-date-picker-icon svelte-xd03cr");
      attr_dev(svg, "width", "12");
      attr_dev(svg, "height", "12");
      attr_dev(svg, "viewBox", "0 0 11 12");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      add_location(svg, file35, 47, 2, 1882);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, dirty) {
      var _a2;
      if (dirty & /*value, locale, placeholder*/
      13 && t0_value !== (t0_value = /*value*/
      (((_a2 = ctx2[0]) == null ? void 0 : _a2.toLocaleDateString(
        /*locale*/
        ctx2[2]
      )) ?? /*placeholder*/
      ctx2[3]) + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*disabled*/
      16) {
        toggle_class(
          span,
          "disabled",
          /*disabled*/
          ctx2[4]
        );
      }
      if (dirty & /*value*/
      1) {
        toggle_class(span, "placeholder", typeof /*value*/
        ctx2[0] === "undefined" || /*value*/
        ctx2[0] === null);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_18.name,
    type: "slot",
    source: '(40:1) <Button class=\\"calendar-date-picker-button\\" {disabled}>',
    ctx
  });
  return block;
}
function create_default_slot15(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      class: "calendar-date-picker-button",
      disabled: (
        /*disabled*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot_18] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const button_changes = {};
      if (dirty & /*disabled*/
      16)
        button_changes.disabled = /*disabled*/
        ctx2[4];
      if (dirty & /*$$scope, disabled, value, locale, placeholder*/
      32797) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot15.name,
    type: "slot",
    source: '(31:0) <Flyout  class=\\"calendar-date-picker-container\\"  bind:open  {closable}  {placement}  {alignment}  {offset}  {trapFocus} >',
    ctx
  });
  return block;
}
function create_override_slot(ctx) {
  let calendarview;
  let updating_value;
  let current;
  const calendarview_spread_levels = [
    { slot: "override" },
    { class: "calendar-date-picker-calendar" },
    { multiple: false },
    { __floating: true },
    /*$$restProps*/
    ctx[11]
  ];
  function calendarview_value_binding(value) {
    ctx[12](value);
  }
  let calendarview_props = {};
  for (let i = 0; i < calendarview_spread_levels.length; i += 1) {
    calendarview_props = assign(calendarview_props, calendarview_spread_levels[i]);
  }
  if (
    /*value*/
    ctx[0] !== void 0
  ) {
    calendarview_props.value = /*value*/
    ctx[0];
  }
  calendarview = new CalendarView_default({
    props: calendarview_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(calendarview, "value", calendarview_value_binding));
  calendarview.$on(
    "keydown",
    /*handleKeyDown*/
    ctx[10]
  );
  calendarview.$on(
    "change",
    /*change_handler*/
    ctx[13]
  );
  const block = {
    c: function create() {
      create_component(calendarview.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(calendarview.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(calendarview, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const calendarview_changes = dirty & /*$$restProps*/
      2048 ? get_spread_update(calendarview_spread_levels, [
        calendarview_spread_levels[0],
        calendarview_spread_levels[1],
        calendarview_spread_levels[2],
        calendarview_spread_levels[3],
        get_spread_object(
          /*$$restProps*/
          ctx2[11]
        )
      ]) : {};
      if (!updating_value && dirty & /*value*/
      1) {
        updating_value = true;
        calendarview_changes.value = /*value*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      calendarview.$set(calendarview_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(calendarview.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(calendarview.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(calendarview, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_override_slot.name,
    type: "slot",
    source: "(61:1) ",
    ctx
  });
  return block;
}
function create_fragment35(ctx) {
  let flyout;
  let updating_open;
  let current;
  function flyout_open_binding(value) {
    ctx[14](value);
  }
  let flyout_props = {
    class: "calendar-date-picker-container",
    closable: (
      /*closable*/
      ctx[5]
    ),
    placement: (
      /*placement*/
      ctx[6]
    ),
    alignment: (
      /*alignment*/
      ctx[7]
    ),
    offset: (
      /*offset*/
      ctx[8]
    ),
    trapFocus: (
      /*trapFocus*/
      ctx[9]
    ),
    $$slots: {
      override: [create_override_slot],
      default: [create_default_slot15]
    },
    $$scope: { ctx }
  };
  if (
    /*open*/
    ctx[1] !== void 0
  ) {
    flyout_props.open = /*open*/
    ctx[1];
  }
  flyout = new FlyoutWrapper_default({ props: flyout_props, $$inline: true });
  binding_callbacks.push(() => bind(flyout, "open", flyout_open_binding));
  const block = {
    c: function create() {
      create_component(flyout.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(flyout.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(flyout, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const flyout_changes = {};
      if (dirty & /*closable*/
      32)
        flyout_changes.closable = /*closable*/
        ctx2[5];
      if (dirty & /*placement*/
      64)
        flyout_changes.placement = /*placement*/
        ctx2[6];
      if (dirty & /*alignment*/
      128)
        flyout_changes.alignment = /*alignment*/
        ctx2[7];
      if (dirty & /*offset*/
      256)
        flyout_changes.offset = /*offset*/
        ctx2[8];
      if (dirty & /*trapFocus*/
      512)
        flyout_changes.trapFocus = /*trapFocus*/
        ctx2[9];
      if (dirty & /*$$scope, $$restProps, value, open, disabled, locale, placeholder*/
      34847) {
        flyout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_open && dirty & /*open*/
      2) {
        updating_open = true;
        flyout_changes.open = /*open*/
        ctx2[1];
        add_flush_callback(() => updating_open = false);
      }
      flyout.$set(flyout_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(flyout.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(flyout.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(flyout, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "value",
    "open",
    "locale",
    "placeholder",
    "disabled",
    "closable",
    "placement",
    "alignment",
    "offset",
    "trapFocus"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CalendarDatePicker", slots, []);
  let { value } = $$props;
  let { open = false } = $$props;
  let { locale = void 0 } = $$props;
  let { placeholder = "Pick a date" } = $$props;
  let { disabled = false } = $$props;
  let { closable = true } = $$props;
  let { placement = "bottom" } = $$props;
  let { alignment = "center" } = $$props;
  let { offset = 4 } = $$props;
  let { trapFocus = true } = $$props;
  function handleKeyDown2(event2) {
    event2.stopPropagation();
    if (event2.key === "Escape")
      $$invalidate(1, open = false);
  }
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<CalendarDatePicker> was created without expected prop 'value'");
    }
  });
  function calendarview_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  const change_handler = () => $$invalidate(1, open = false);
  function flyout_open_binding(value2) {
    open = value2;
    $$invalidate(1, open);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("open" in $$new_props)
      $$invalidate(1, open = $$new_props.open);
    if ("locale" in $$new_props)
      $$invalidate(2, locale = $$new_props.locale);
    if ("placeholder" in $$new_props)
      $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("disabled" in $$new_props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("closable" in $$new_props)
      $$invalidate(5, closable = $$new_props.closable);
    if ("placement" in $$new_props)
      $$invalidate(6, placement = $$new_props.placement);
    if ("alignment" in $$new_props)
      $$invalidate(7, alignment = $$new_props.alignment);
    if ("offset" in $$new_props)
      $$invalidate(8, offset = $$new_props.offset);
    if ("trapFocus" in $$new_props)
      $$invalidate(9, trapFocus = $$new_props.trapFocus);
  };
  $$self.$capture_state = () => ({
    CalendarView: CalendarView_default,
    Flyout: FlyoutWrapper_default,
    Button: Button_default,
    value,
    open,
    locale,
    placeholder,
    disabled,
    closable,
    placement,
    alignment,
    offset,
    trapFocus,
    handleKeyDown: handleKeyDown2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("open" in $$props)
      $$invalidate(1, open = $$new_props.open);
    if ("locale" in $$props)
      $$invalidate(2, locale = $$new_props.locale);
    if ("placeholder" in $$props)
      $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("disabled" in $$props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("closable" in $$props)
      $$invalidate(5, closable = $$new_props.closable);
    if ("placement" in $$props)
      $$invalidate(6, placement = $$new_props.placement);
    if ("alignment" in $$props)
      $$invalidate(7, alignment = $$new_props.alignment);
    if ("offset" in $$props)
      $$invalidate(8, offset = $$new_props.offset);
    if ("trapFocus" in $$props)
      $$invalidate(9, trapFocus = $$new_props.trapFocus);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    value,
    open,
    locale,
    placeholder,
    disabled,
    closable,
    placement,
    alignment,
    offset,
    trapFocus,
    handleKeyDown2,
    $$restProps,
    calendarview_value_binding,
    change_handler,
    flyout_open_binding
  ];
}
var CalendarDatePicker = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance35,
      create_fragment35,
      safe_not_equal,
      {
        value: 0,
        open: 1,
        locale: 2,
        placeholder: 3,
        disabled: 4,
        closable: 5,
        placement: 6,
        alignment: 7,
        offset: 8,
        trapFocus: 9
      },
      add_css35
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CalendarDatePicker",
      options,
      id: create_fragment35.name
    });
  }
  get value() {
    throw new Error("<CalendarDatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<CalendarDatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<CalendarDatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<CalendarDatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get locale() {
    throw new Error("<CalendarDatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set locale(value) {
    throw new Error("<CalendarDatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<CalendarDatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<CalendarDatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<CalendarDatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<CalendarDatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closable() {
    throw new Error("<CalendarDatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closable(value) {
    throw new Error("<CalendarDatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placement() {
    throw new Error("<CalendarDatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placement(value) {
    throw new Error("<CalendarDatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alignment() {
    throw new Error("<CalendarDatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alignment(value) {
    throw new Error("<CalendarDatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get offset() {
    throw new Error("<CalendarDatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set offset(value) {
    throw new Error("<CalendarDatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get trapFocus() {
    throw new Error("<CalendarDatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set trapFocus(value) {
    throw new Error("<CalendarDatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CalendarDatePicker_default = CalendarDatePicker;

// node_modules/fluent-svelte/NavigationView/NavigationView.svelte
var file36 = "node_modules\\fluent-svelte\\NavigationView\\NavigationView.svelte";
function add_css36(target) {
  append_styles(target, "svelte-84rxrb", ".navigation-view.svelte-84rxrb.svelte-84rxrb{block-size:100%;display:flex;font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;inline-size:100%;line-height:20px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.navigation-view.variant--default.svelte-84rxrb .navigation-view-pane.svelte-84rxrb{inline-size:48px}.navigation-view.variant--default.svelte-84rxrb .navigation-view-pane.expanded.svelte-84rxrb{inline-size:320px}.navigation-view-pane.svelte-84rxrb.svelte-84rxrb{block-size:100%;display:flex;flex:0 0 auto;flex-direction:column;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.navigation-view-pane-header.svelte-84rxrb.svelte-84rxrb{-webkit-padding-before:4px;display:block;flex:0 0 auto;padding-block-start:4px}.navigation-view-page.svelte-84rxrb.svelte-84rxrb{-webkit-border-after:none;-webkit-border-end:none;background-clip:padding-box;background-color:var(--fds-layer-background-default);border:1px solid var(--fds-card-stroke-default);border-block-end:none;border-inline-end:none;border-start-start-radius:var(--fds-overlay-corner-radius);display:flex;flex:1 1 auto;flex-direction:column;padding-block:44px;padding-inline:56px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTmF2aWdhdGlvblZpZXcuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWtDUSw0Q0FBQSxDQUFpQixXQUFBLElBQWUsQ0FBQyxRQUFBLElBQVksQ0FBQyxZQUFBLElBQUEsc0JBQUEsQ0FBdUMsQ0FBQyxVQUFBLElBQUEsb0JBQUEsQ0FBbUMsQ0FBQyxZQUFBLEdBQWUsQ0FBQyxZQUFBLElBQWdCLENBQUMsWUFBQSxJQUFnQixDQUFDLG9CQUFBLElBQXdCLENBQUMsaUJBQUEsSUFBcUIsQ0FBQyxnQkFBQSxJQUFvQixDQUFDLFlBQUEsSUFBZ0IsQ0FBQyxnQkFBQSwrQkFBQSxDQUFBLG1DQUFBLENBQXdELFlBQUEsSUFBZ0IsQ0FBQyxnQkFBQSwrQkFBQSxDQUFBLHFCQUFBLHVCQUFBLENBQWlFLFlBQUEsS0FBaUIsQ0FBQyxpREFBQSxDQUFzQixXQUFBLElBQWUsQ0FBQyxRQUFBLElBQVksQ0FBQyxLQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsSUFBYSxDQUFDLGVBQUEsTUFBcUIsQ0FBQyxvQkFBQSxJQUF3QixDQUFDLGlCQUFBLElBQXFCLENBQUMsZ0JBQUEsSUFBb0IsQ0FBQyxZQUFBLElBQWdCLENBQUMsd0RBQUEsQ0FBNkIsdUJBQUEsR0FBMEIsQ0FBQyxRQUFBLEtBQWEsQ0FBQyxLQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsSUFBYSxDQUFDLG9CQUFBLEdBQXVCLENBQUMsaURBQUEsQ0FBc0IscUJBQUEsSUFBeUIsQ0FBQyxtQkFBQSxJQUF1QixDQUFDLGdCQUFBLFdBQTJCLENBQUMsaUJBQUEsSUFBQSw4QkFBQSxDQUFvRCxDQUFDLE9BQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLHlCQUFBLENBQStDLENBQUMsaUJBQUEsSUFBcUIsQ0FBQyxrQkFBQSxJQUFzQixDQUFDLDBCQUFBLElBQUEsMkJBQUEsQ0FBMEQsQ0FBQyxRQUFBLElBQVksQ0FBQyxLQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsSUFBYSxDQUFDLGVBQUEsTUFBcUIsQ0FBQyxjQUFBLElBQWtCLENBQUMsZUFBQSxJQUFtQixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIk5hdmlnYXRpb25WaWV3LnN2ZWx0ZSJdfQ== */");
}
var get_footer_slot_changes2 = (dirty) => ({});
var get_footer_slot_context2 = (ctx) => ({});
var get_items_slot_changes = (dirty) => ({});
var get_items_slot_context = (ctx) => ({});
var get_header_slot_changes = (dirty) => ({});
var get_header_slot_context = (ctx) => ({});
function create_if_block_117(ctx) {
  let button;
  let t_value = "<-";
  let t;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {});
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(button, file36, 12, 4, 409);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[7],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_117.name,
    type: "if",
    source: "(12:3) {#if backButton}",
    ctx
  });
  return block;
}
function create_if_block24(ctx) {
  let button;
  let t_value = "-";
  let t;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {});
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(button, file36, 17, 4, 511);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_1*/
          ctx[8],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block24.name,
    type: "if",
    source: "(17:3) {#if menuButton}",
    ctx
  });
  return block;
}
function create_fragment36(ctx) {
  let main;
  let aside;
  let header;
  let t0;
  let t1;
  let t2;
  let t3;
  let footer;
  let t4;
  let article;
  let main_class_value;
  let current;
  let if_block0 = (
    /*backButton*/
    ctx[3] && create_if_block_117(ctx)
  );
  let if_block1 = (
    /*menuButton*/
    ctx[2] && create_if_block24(ctx)
  );
  const header_slot_template = (
    /*#slots*/
    ctx[6].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_header_slot_context
  );
  const items_slot_template = (
    /*#slots*/
    ctx[6].items
  );
  const items_slot = create_slot(
    items_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_items_slot_context
  );
  const footer_slot_template = (
    /*#slots*/
    ctx[6].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_footer_slot_context2
  );
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      main = element("main");
      aside = element("aside");
      header = element("header");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (header_slot)
        header_slot.c();
      t2 = space();
      if (items_slot)
        items_slot.c();
      t3 = space();
      footer = element("footer");
      if (footer_slot)
        footer_slot.c();
      t4 = space();
      article = element("article");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      main = claim_element(nodes, "MAIN", { class: true });
      var main_nodes = children(main);
      aside = claim_element(main_nodes, "ASIDE", { class: true });
      var aside_nodes = children(aside);
      header = claim_element(aside_nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      if (if_block0)
        if_block0.l(header_nodes);
      t0 = claim_space(header_nodes);
      if (if_block1)
        if_block1.l(header_nodes);
      t1 = claim_space(header_nodes);
      if (header_slot)
        header_slot.l(header_nodes);
      header_nodes.forEach(detach_dev);
      t2 = claim_space(aside_nodes);
      if (items_slot)
        items_slot.l(aside_nodes);
      t3 = claim_space(aside_nodes);
      footer = claim_element(aside_nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      if (footer_slot)
        footer_slot.l(footer_nodes);
      footer_nodes.forEach(detach_dev);
      aside_nodes.forEach(detach_dev);
      t4 = claim_space(main_nodes);
      article = claim_element(main_nodes, "ARTICLE", { class: true });
      var article_nodes = children(article);
      if (default_slot)
        default_slot.l(article_nodes);
      article_nodes.forEach(detach_dev);
      main_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(header, "class", "navigation-view-pane-header svelte-84rxrb");
      add_location(header, file36, 10, 2, 340);
      attr_dev(footer, "class", "navigation-view-pane-footer");
      add_location(footer, file36, 25, 2, 659);
      attr_dev(aside, "class", "navigation-view-pane svelte-84rxrb");
      toggle_class(
        aside,
        "expanded",
        /*expanded*/
        ctx[0]
      );
      add_location(aside, file36, 9, 1, 286);
      attr_dev(article, "class", "navigation-view-page svelte-84rxrb");
      add_location(article, file36, 29, 1, 753);
      attr_dev(main, "class", main_class_value = "navigation-view variant-" + /*variant*/
      ctx[1] + " svelte-84rxrb");
      add_location(main, file36, 8, 0, 236);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, main, anchor);
      append_hydration_dev(main, aside);
      append_hydration_dev(aside, header);
      if (if_block0)
        if_block0.m(header, null);
      append_hydration_dev(header, t0);
      if (if_block1)
        if_block1.m(header, null);
      append_hydration_dev(header, t1);
      if (header_slot) {
        header_slot.m(header, null);
      }
      append_hydration_dev(aside, t2);
      if (items_slot) {
        items_slot.m(aside, null);
      }
      append_hydration_dev(aside, t3);
      append_hydration_dev(aside, footer);
      if (footer_slot) {
        footer_slot.m(footer, null);
      }
      append_hydration_dev(main, t4);
      append_hydration_dev(main, article);
      if (default_slot) {
        default_slot.m(article, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*backButton*/
        ctx2[3]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_117(ctx2);
          if_block0.c();
          if_block0.m(header, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*menuButton*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block24(ctx2);
          if_block1.c();
          if_block1.m(header, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_header_slot_changes
            ),
            get_header_slot_context
          );
        }
      }
      if (items_slot) {
        if (items_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            items_slot,
            items_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              items_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_items_slot_changes
            ),
            get_items_slot_context
          );
        }
      }
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_footer_slot_changes2
            ),
            get_footer_slot_context2
          );
        }
      }
      if (!current || dirty & /*expanded*/
      1) {
        toggle_class(
          aside,
          "expanded",
          /*expanded*/
          ctx2[0]
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*variant*/
      2 && main_class_value !== (main_class_value = "navigation-view variant-" + /*variant*/
      ctx2[1] + " svelte-84rxrb")) {
        attr_dev(main, "class", main_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      transition_in(items_slot, local);
      transition_in(footer_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      transition_out(items_slot, local);
      transition_out(footer_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(main);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (header_slot)
        header_slot.d(detaching);
      if (items_slot)
        items_slot.d(detaching);
      if (footer_slot)
        footer_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavigationView", slots, ["header", "items", "footer", "default"]);
  let { variant = "default" } = $$props;
  let { expanded = true } = $$props;
  let { menuButton = true } = $$props;
  let { backButton = true } = $$props;
  const dispatch = createEventDispatcher();
  const writable_props = ["variant", "expanded", "menuButton", "backButton"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<NavigationView> was created with unknown prop '${key}'`);
  });
  const click_handler3 = () => dispatch("back");
  const click_handler_13 = () => $$invalidate(0, expanded = !expanded);
  $$self.$$set = ($$props2) => {
    if ("variant" in $$props2)
      $$invalidate(1, variant = $$props2.variant);
    if ("expanded" in $$props2)
      $$invalidate(0, expanded = $$props2.expanded);
    if ("menuButton" in $$props2)
      $$invalidate(2, menuButton = $$props2.menuButton);
    if ("backButton" in $$props2)
      $$invalidate(3, backButton = $$props2.backButton);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    variant,
    expanded,
    menuButton,
    backButton,
    dispatch
  });
  $$self.$inject_state = ($$props2) => {
    if ("variant" in $$props2)
      $$invalidate(1, variant = $$props2.variant);
    if ("expanded" in $$props2)
      $$invalidate(0, expanded = $$props2.expanded);
    if ("menuButton" in $$props2)
      $$invalidate(2, menuButton = $$props2.menuButton);
    if ("backButton" in $$props2)
      $$invalidate(3, backButton = $$props2.backButton);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    expanded,
    variant,
    menuButton,
    backButton,
    dispatch,
    $$scope,
    slots,
    click_handler3,
    click_handler_13
  ];
}
var NavigationView = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance36,
      create_fragment36,
      safe_not_equal,
      {
        variant: 1,
        expanded: 0,
        menuButton: 2,
        backButton: 3
      },
      add_css36
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavigationView",
      options,
      id: create_fragment36.name
    });
  }
  get variant() {
    throw new Error("<NavigationView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<NavigationView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expanded() {
    throw new Error("<NavigationView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expanded(value) {
    throw new Error("<NavigationView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get menuButton() {
    throw new Error("<NavigationView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set menuButton(value) {
    throw new Error("<NavigationView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backButton() {
    throw new Error("<NavigationView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backButton(value) {
    throw new Error("<NavigationView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavigationView_default = NavigationView;
export {
  AutoSuggestBox_default as AutoSuggestBox,
  Button_default as Button,
  CalendarDatePicker_default as CalendarDatePicker,
  CalendarView_default as CalendarView,
  Checkbox_default as Checkbox,
  ComboBox_default as ComboBox,
  ContentDialog_default as ContentDialog,
  ContextMenu_default as ContextMenu,
  Expander_default as Expander,
  FlyoutWrapper_default as Flyout,
  IconButton_default as IconButton,
  InfoBadge_default as InfoBadge,
  InfoBar_default as InfoBar,
  ListItem_default as ListItem,
  MenuBar_default as MenuBar,
  MenuBarItem_default as MenuBarItem,
  MenuFlyoutWrapper_default as MenuFlyout,
  MenuFlyoutDivider_default as MenuFlyoutDivider,
  MenuFlyoutItem_default as MenuFlyoutItem,
  NavigationView_default as NavigationView,
  NumberBox_default as NumberBox,
  PersonPicture_default as PersonPicture,
  ProgressBar_default as ProgressBar,
  ProgressRing_default as ProgressRing,
  RadioButton_default as RadioButton,
  Slider_default as Slider,
  TextBlock_default as TextBlock,
  TextBox_default as TextBox,
  TextBoxButton_default as TextBoxButton,
  ToggleSwitch_default as ToggleSwitch,
  TooltipWrapper_default as Tooltip
};
//# sourceMappingURL=fluent-svelte.js.map
